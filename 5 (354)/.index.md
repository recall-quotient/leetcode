## 1899. Merge Triplets to Form Target Triplet_1899.py
```python
class Solution:
  def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:
    merged = [0] * len(target)

    for triplet in triplets:
      if all(a <= b for a, b in zip(triplet, target)):
        for i in range(3):
          merged[i] = max(merged[i], triplet[i])

    return merged == target

```

## 2351. First Letter to Appear Twice_2351.py
```python
class Solution:
  def repeatedCharacter(self, s: str) -> str:
    seen = [False] * 26

    for c in s:
      if seen[ord(c) - ord('a')]:
        return c
      seen[ord(c) - ord('a')] = True

```

## 2487. Remove Nodes From Linked List_2487.py
```python
class Solution:
  def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:
    if not head:
      return None
    head.next = self.removeNodes(head.next)
    return head.next if head.next and head.val < head.next.val else head

```

## 2433. Find The Original Array of Prefix Xor_2433.py
```python
class Solution:
  def findArray(self, pref: List[int]) -> List[int]:
    ans = [0] * len(pref)

    ans[0] = pref[0]
    for i in range(1, len(ans)):
      ans[i] = pref[i] ^ pref[i - 1]

    return ans

```

## 1968. Array With Elements Not Equal to Average of Neighbors_1968.py
```python
class Solution:
  def rearrangeArray(self, nums: List[int]) -> List[int]:
    nums.sort()
    for i in range(1, len(nums), 2):
      nums[i], nums[i - 1] = nums[i - 1], nums[i]
    return nums

```

## 1640. Check Array Formation Through Concatenation_1640.py
```python
class Solution:
  def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:
    concatenated = []
    startToPiece = {piece[0]: piece for piece in pieces}

    for a in arr:
      concatenated += startToPiece.get(a, [])

    return concatenated == arr

```

## 1287. Element Appearing More Than 25% In Sorted Array_1287.py
```python
class Solution:
  def findSpecialInteger(self, arr: List[int]) -> int:
    n = len(arr)
    quarter = n // 4

    for i in range(n - quarter):
      if arr[i] == arr[i + quarter]:
        return arr[i]

```

## 2890. Reshape Data: Melt_2890.py
```python
import pandas as pd


def meltTable(report: pd.DataFrame) -> pd.DataFrame:
  return pd.melt(
      report,
      id_vars=['product'],
      var_name='quarter',
      value_name='sales',
  )

```

## 2029. Stone Game IX_2029.py
```python
class Solution:
  def stoneGameIX(self, stones: List[int]) -> bool:
    count = collections.Counter(stone % 3 for stone in stones)
    if count[0] % 2 == 0:
      return min(count[1], count[2]) > 0
    return abs(count[1] - count[2]) > 2

```

## 1720. Decode XORed Array_1720.py
```python
class Solution:
  def decode(self, encoded: List[int], first: int) -> List[int]:
    ans = [first]

    for e in encoded:
      ans.append(e ^ ans[-1])

    return ans

```

## 2138. Divide a String Into Groups of Size k_2138.py
```python
class Solution:
  def divideString(self, s: str, k: int, fill: str) -> List[str]:
    return [
        s[i:] + fill * (i + k - len(s)) if i + k > len(s)
        else s[i:i + k]
        for i in range(0, len(s), k)
    ]

```

## 370. Range Addition_370.py
```python
class Solution:
  def getModifiedArray(self, length: int, updates: list[list[int]]) -> list[int]:
    line = [0] * length

    for start, end, inc in updates:
      line[start] += inc
      if end + 1 < length:
        line[end + 1] -= inc

    return itertools.accumulate(line)

```

## 961. N-Repeated Element in Size 2N Array_961.py
```python
class Solution:
  def repeatedNTimes(self, nums: List[int]) -> int:
    for i in range(len(nums) - 2):
      if nums[i] == nums[i + 1] or nums[i] == nums[i + 2]:
        return nums[i]
    return nums[-1]

```

## 1526. Minimum Number of Increments on Subarrays to Form a Target Array_1526.py
```python
class Solution:
  def minNumberOperations(self, target: List[int]) -> int:
    ans = target[0]

    for a, b in zip(target, target[1:]):
      if a < b:
        ans += b - a

    return ans

```

## 1208. Get Equal Substrings Within Budget_1208.py
```python
class Solution:
  def equalSubstring(self, s: str, t: str, maxCost: int) -> int:
    j = 0
    for i in range(len(s)):
      maxCost -= abs(ord(s[i]) - ord(t[i]))
      if maxCost < 0:
        maxCost += abs(ord(s[j]) - ord(t[j]))
        j += 1

    return len(s) - j

```

## 2882. Drop Duplicate Rows_2882.py
```python
import pandas as pd


def dropDuplicateEmails(customers: pd.DataFrame) -> pd.DataFrame:
  customers.drop_duplicates(subset='email', keep='first', inplace=True)
  return customers

```

## 497. Random Point in Non-overlapping Rectangles_497.py
```python
class Solution:
  def __init__(self, rects: List[List[int]]):
    self.rects = rects
    self.areas = list(itertools.accumulate(
        [(x2 - x1 + 1) * (y2 - y1 + 1) for x1, y1, x2, y2 in rects]))

  def pick(self) -> List[int]:
    index = bisect_right(self.areas, random.randint(0, self.areas[-1] - 1))
    x1, y1, x2, y2 = self.rects[index]
    return [random.randint(x1, x2), random.randint(y1, y2)]

```

## 1048. Longest String Chain_1048-2.py
```python
class Solution:
  def longestStrChain(self, words: List[str]) -> int:
    dp = {}

    for word in sorted(words, key=len):
      dp[word] = max(dp.get(word[:i] + word[i + 1:], 0) +
                     1 for i in range(len(word)))

    return max(dp.values())

```

## 1962. Remove Stones to Minimize the Total_1962.py
```python
class Solution:
  def minStoneSum(self, piles: List[int], k: int) -> int:
    maxHeap = [-pile for pile in piles]
    heapq.heapify(maxHeap)

    for _ in range(k):
      heapq.heapreplace(maxHeap, maxHeap[0] // 2)

    return -sum(maxHeap)

```

## 1846. Maximum Element After Decreasing and Rearranging_1846.py
```python
class Solution:
  def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -> int:
    arr.sort()
    arr[0] = 1

    for i in range(1, len(arr)):
      arr[i] = min(arr[i], arr[i - 1] + 1)

    return arr[-1]

```

## 371. Sum of Two Integers_371.py
```python
class Solution:
  def getSum(self, a: int, b: int) -> int:
    mask = 0xFFFFFFFF
    kMax = 2000

    while b != 0:
      a, b = (a ^ b) & mask, ((a & b) << 1) & mask

    return a if a < kMax else ~(a ^ mask)

```

## 2598. Smallest Missing Non-negative Integer After Operations_2598.py
```python
class Solution:
  def findSmallestInteger(self, nums: List[int], value: int) -> int:
    count = collections.Counter([num % value for num in nums])

    for i in range(len(nums)):
      if count[i % value] == 0:
        return i
      count[i % value] -= 1

    return len(nums)

```

## 2177. Find Three Consecutive Integers That Sum to a Given Number_2177.py
```python
class Solution:
  def sumOfThree(self, num: int) -> List[int]:
    if num % 3:
      return []
    x = num // 3
    return [x - 1, x, x + 1]

```

## 714. Best Time to Buy and Sell Stock with Transaction Fee_714.py
```python
class Solution:
  def maxProfit(self, prices: List[int], fee: int) -> int:
    sell = 0
    hold = -math.inf

    for price in prices:
      sell = max(sell, hold + price)
      hold = max(hold, sell - price - fee)

    return sell

```

## 1550. Three Consecutive Odds_1550.py
```python
class Solution:
  def threeConsecutiveOdds(self, arr: List[int]) -> bool:
    count = 0
    for a in arr:
      count = 0 if a % 2 == 0 else count + 1
      if count == 3:
        return True
    return False

```

## 1935. Maximum Number of Words You Can Type_1935.py
```python
class Solution:
  def canBeTypedWords(self, text: str, brokenLetters: str) -> int:
    ans = 0
    broken = set(brokenLetters)

    for word in text.split():
      ans += all(c not in broken for c in word)

    return ans

```

## 458. Poor Pigs_458.py
```python
class Solution:
  def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:
    base = minutesToTest // minutesToDie + 1
    ans = 0
    x = 1
    while x < buckets:
      ans += 1
      x *= base
    return ans

```

## 2331. Evaluate Boolean Binary Tree_2331.py
```python
class Solution:
  def evaluateTree(self, root: Optional[TreeNode]) -> bool:
    if root.val < 2:
      return root.val
    if root.val == 2:  # OR
      return self.evaluateTree(root.left) or self.evaluateTree(root.right)
    # AND
    return self.evaluateTree(root.left) and self.evaluateTree(root.right)

```

## 2428. Maximum Sum of an Hourglass_2428.py
```python
class Solution:
  def maxSum(self, grid: List[List[int]]) -> int:
    return max(grid[i - 1][j - 1] + grid[i - 1][j] + grid[i - 1][j + 1] + grid[i][j] +
               grid[i + 1][j - 1] + grid[i + 1][j] + grid[i + 1][j + 1]
               for i in range(1, len(grid) - 1)
               for j in range(1, len(grid[0]) - 1))

```

## 342. Power of Four_342.py
```python
class Solution:
  def isPowerOfFour(self, n: int) -> bool:
    # Why (4^n - 1) % 3 == 0?
    # (4^n - 1) = (2^n - 1)(2^n + 1) and 2^n - 1, 2^n, 2^n + 1 are
    # three consecutive numbers; among one of them, there must be a multiple
    # of 3, and that can't be 2^n, so it must be either 2^n - 1 or 2^n + 1.
    # Therefore, 4^n - 1 is a multiple of 3.
    return n > 0 and n.bit_count() == 1 and (n - 1) % 3 == 0

```

## 867. Transpose Matrix_867.py
```python
class Solution:
  def transpose(self, A: List[List[int]]) -> List[List[int]]:
    ans = [[0] * len(A) for _ in range(len(A[0]))]

    for i in range(len(A)):
      for j in range(len(A[0])):
        ans[j][i] = A[i][j]

    return ans

```

## 111. Minimum Depth of Binary Tree_111.py
```python
class Solution:
  def minDepth(self, root: Optional[TreeNode]) -> int:
    if not root:
      return 0
    if not root.left:
      return self.minDepth(root.right) + 1
    if not root.right:
      return self.minDepth(root.left) + 1
    return min(self.minDepth(root.left), self.minDepth(root.right)) + 1

```

## 634. Find the Derangement of An Array_634-2.py
```python
class Solution:
  def findDerangement(self, n: int) -> int:
    kMod = 1_000_000_007
    dp = [1] + [0] * n

    for i in range(2, n + 1):
      dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % kMod

    return dp[n]

```

## 544. Output Contest Matches_544-2.py
```python
class Solution:
  def findContestMatch(self, n: int) -> str:
    matches = [str(i + 1) for i in range(n)]

    while n > 1:
      for i in range(n // 2):
        matches[i] = '(' + matches[i] + ',' + matches[n - 1 - i] + ')'
      n //= 2

    return matches[0]

```

## 593. Valid Square_593.py
```python
class Solution:
  def validSquare(self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]) -> bool:
    def dist(p1: List[int], p2: List[int]) -> int:
      return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2

    distSet = set([dist(*pair)
                   for pair in list(itertools.combinations([p1, p2, p3, p4], 2))])

    return 0 not in distSet and len(distSet) == 2

```

## 605. Can Place Flowers_605.py
```python
class Solution:
  def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
    for i, flower in enumerate(flowerbed):
      if flower == 0 and (i == 0 or flowerbed[i - 1] == 0) and (i == len(flowerbed) - 1 or flowerbed[i + 1] == 0):
        flowerbed[i] = 1
        n -= 1
      if n <= 0:
        return True

    return False

```

## 2279. Maximum Bags With Full Capacity of Rocks_2279.py
```python
class Solution:
  def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:
    for i, d in enumerate(sorted([c - r for c, r in zip(capacity, rocks)])):
      if d > additionalRocks:
        return i
      additionalRocks -= d
    return len(capacity)

```

## 96. Unique Binary Search Trees_96.py
```python
class Solution:
  def numTrees(self, n: int) -> int:
    # dp[i] := the number of unique BST's that store values 1..i
    dp = [1, 1] + [0] * (n - 1)

    for i in range(2, n + 1):
      for j in range(i):
        dp[i] += dp[j] * dp[i - j - 1]

    return dp[n]

```

## 1359. Count All Valid Pickup and Delivery Options_1359.py
```python
class Solution:
  def countOrders(self, n: int) -> int:
    kMod = 1_000_000_007
    ans = 1

    for i in range(1, n + 1):
      ans = ans * i * (i * 2 - 1) % kMod

    return ans

```

## 448. Find All Numbers Disappeared in an Array_448.py
```python
class Solution:
  def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
    for num in nums:
      index = abs(num) - 1
      nums[index] = -abs(nums[index])

    return [i + 1 for i, num in enumerate(nums) if num > 0]

```

## 1760. Minimum Limit of Balls in a Bag_1760.py
```python
class Solution:
  def minimumSize(self, nums: List[int], maxOperations: int) -> int:
    # Returns the number of operations required to make m penalty.
    def numOperations(m: int) -> int:
      return sum((num - 1) // m for num in nums) <= maxOperations
    return bisect.bisect_left(range(1, max(nums)), True,
                              key=lambda m: numOperations(m)) + 1

```

## 700. Search in a Binary Search Tree_700.py
```python
class Solution:
  def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
    if not root:
      return None
    if root.val == val:
      return root
    if root.val > val:
      return self.searchBST(root.left, val)
    return self.searchBST(root.right, val)

```

## 121. Best Time to Buy and Sell Stock_121.py
```python
class Solution:
  def maxProfit(self, prices: List[int]) -> int:
    sellOne = 0
    holdOne = -math.inf

    for price in prices:
      sellOne = max(sellOne, holdOne + price)
      holdOne = max(holdOne, -price)

    return sellOne

```

## 1984. Minimum Difference Between Highest and Lowest of K Scores_1984.py
```python
class Solution:
  def minimumDifference(self, nums: List[int], k: int) -> int:
    nums.sort()
    ans = nums[k - 1] - nums[0]

    for i in range(k, len(nums)):
      ans = min(ans, nums[i] - nums[i - k + 1])

    return ans

```

## 285. Inorder Successor in BST_285.py
```python
class Solution:
  def inorderSuccessor(self, root: Optional[TreeNode], p: Optional[TreeNode]) -> Optional[TreeNode]:
    if not root:
      return None
    if root.val <= p.val:
      return self.inorderSuccessor(root.right, p)
    return self.inorderSuccessor(root.left, p) or root

```

## 2180. Count Integers With Even Digit Sum_2180.py
```python
class Solution:
  def countEven(self, num: int) -> int:
    return (num - self._getDigitSum(num) % 2) // 2

  def _getDigitSum(self, num: int) -> int:
    return sum(int(digit) for digit in str(num))

```

## 2652. Sum Multiples_2652.py
```python
class Solution:
  def sumOfMultiples(self, n: int) -> int:
    ans = 0
    for i in range(1, n + 1):
      if i % 3 == 0 or i % 5 == 0 or i % 7 == 0:
        ans += i
    return ans

```

## 3168. Minimum Number of Chairs in a Waiting Room_3168.py
```python
class Solution:
  def minimumChairs(self, s: str) -> int:
    ans = 0
    chairs = 0

    for c in s:
      chairs += 1 if c == 'E' else -1
      ans = max(ans, chairs)

    return ans

```

## 1911. Maximum Alternating Subsequence Sum_1911.py
```python
class Solution:
  def maxAlternatingSum(self, nums: List[int]) -> int:
    even = 0  # the maximum alternating sum ending in an even index
    odd = 0  # the maximum alternating sum ending in an odd index

    for num in nums:
      even = max(even, odd + num)
      odd = even - num

    return even

```

## 528. Random Pick with Weight_528.py
```python
class Solution:
  def __init__(self, w: List[int]):
    self.prefix = list(itertools.accumulate(w))

  def pickIndex(self) -> int:
    target = random.randint(0, self.prefix[-1] - 1)
    return bisect.bisect_right(range(len(self.prefix)), target,
                               key=lambda m: self.prefix[m])

```

## 1961. Check If String Is a Prefix of Array_1961.py
```python
class Solution:
  def isPrefixString(self, s: str, words: List[str]) -> bool:
    prefix = []
    for word in words:
      prefix.append(word)
      if ''.join(prefix) == s:
        return True
    return False

```

## 1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence_1455.py
```python
class Solution:
  def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:
    words = sentence.split()

    for i, word in enumerate(words):
      if word.startswith(searchWord):
        return i + 1

    return -1

```

## 1337. The K Weakest Rows in a Matrix_1337.py
```python
class Solution:
  def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
    candidates = []

    for i, row in enumerate(mat):
      candidates.append([sum(row), i])

    candidates.sort(key=lambda c: (c[0], c[1]))

    return [i for _, i in candidates[:k]]

```

## 686. Repeated String Match_686.py
```python
class Solution:
  def repeatedStringMatch(self, a: str, b: str) -> int:
    n = math.ceil(len(b) / len(a))
    s = a * n
    if b in s:
      return n
    if b in s + a:
      return n + 1
    return -1

```

## 1553. Minimum Number of Days to Eat N Oranges_1553.py
```python
class Solution:
  @functools.lru_cache(None)
  def minDays(self, n: int) -> int:
    if n <= 1:
      return n
    return 1 + min(self.minDays(n // 3) + n % 3,
                   self.minDays(n // 2) + n % 2)

```

## 1700. Number of Students Unable to Eat Lunch_1700.py
```python
class Solution:
  def countStudents(self, students: List[int], sandwiches: List[int]) -> int:
    count = collections.Counter(students)

    for i, sandwich in enumerate(sandwiches):
      if count[sandwich] == 0:
        return len(sandwiches) - i
      count[sandwich] -= 1

    return 0

```

## 215. Kth Largest Element in an Array_215.py
```python
class Solution:
  def findKthLargest(self, nums: List[int], k: int) -> int:
    minHeap = []

    for num in nums:
      heapq.heappush(minHeap, num)
      if len(minHeap) > k:
        heapq.heappop(minHeap)

    return minHeap[0]

```

## 1165. Single-Row Keyboard_1165.py
```python
class Solution:
  def calculateTime(self, keyboard: str, word: str) -> int:
    letterToIndex = {c: i for i, c in enumerate(keyboard)}
    return letterToIndex[word[0]] + \
        sum(abs(letterToIndex[a] - letterToIndex[b])
            for a, b in itertools.pairwise(word))

```

## 2881. Create a New Column_2881.py
```python
import pandas as pd


def createBonusColumn(employees: pd.DataFrame) -> pd.DataFrame:
  employees['bonus'] = employees['salary'] * 2
  return employees

```

## 2425. Bitwise XOR of All Pairings_2425.py
```python
class Solution:
  def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:
    xors1 = functools.reduce(operator.xor, nums1)
    xors2 = functools.reduce(operator.xor, nums2)
    # If the size of nums1 is m and the size of nums2 is n, then each number in
    # nums1 is repeated n times and each number in nums2 is repeated m times.
    return (len(nums1) % 2 * xors2) ^ (len(nums2) % 2 * xors1)

```

## 1732. Find the Highest Altitude_1732.py
```python
class Solution:
  def largestAltitude(self, gain: List[int]) -> int:
    ans = 0
    currAltitude = 0
    for g in gain:
      currAltitude += g
      ans = max(ans, currAltitude)
    return ans

```

## 775. Global and Local Inversions_775.py
```python
class Solution:
  def isIdealPermutation(self, nums: List[int]) -> bool:
    mx = -1  # the number that is most likely > nums[i + 2]

    for i in range(len(nums) - 2):
      mx = max(mx, nums[i])
      if mx > nums[i + 2]:
        return False

    return True

```

## 236. Lowest Common Ancestor of a Binary Tree_236.py
```python
class Solution:
  def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
    if not root or root == p or root == q:
      return root
    left = self.lowestCommonAncestor(root.left, p, q)
    right = self.lowestCommonAncestor(root.right, p, q)
    if left and right:
      return root
    return left or right

```

## 929. Unique Email Addresses_929.py
```python
class Solution:
  def numUniqueEmails(self, emails: List[str]) -> int:
    seen = set()

    for email in emails:
      local, domain = email.split('@')
      local = local.split('+')[0].replace('.', '')
      seen.add(local + '@' + domain)

    return len(seen)

```

## 179. Largest Number_179.py
```python
class LargerStrKey(str):
  def __lt__(x: str, y: str) -> bool:
    return x + y > y + x


class Solution:
  def largestNumber(self, nums: List[int]) -> str:
    return ''.join(sorted(map(str, nums), key=LargerStrKey)).lstrip('0') or '0'

```

## 1017. Convert to Base -2_1017.py
```python
class Solution:
  def baseNeg2(self, n: int) -> str:
    ans = []

    while n != 0:
      ans.append(str(n % 2))
      n = -(n >> 1)

    return ''.join(reversed(ans)) if ans else '0'

```

## 1879. Minimum XOR Sum of Two Arrays_1879.py
```python
class Solution:
  def minimumXORSum(self, nums1: List[int], nums2: List[int]) -> int:
    @functools.lru_cache(None)
    def dp(mask: int) -> int:
      i = mask.bit_count()
      if i == len(nums1):
        return 0
      return min((nums1[i] ^ nums2[j]) + dp(mask | 1 << j)
                 for j in range(len(nums2)) if not mask >> j & 1)
    return dp(0)

```

## 1346. Check If N and Its Double Exist_1346.py
```python
class Solution:
  def checkIfExist(self, arr: List[int]) -> bool:
    seen = set()

    for a in arr:
      if a * 2 in seen or a % 2 == 0 and a // 2 in seen:
        return True
      seen.add(a)

    return False

```

## 2898. Maximum Linear Stock Score_2898.py
```python
class Solution:
  def maxScore(self, prices: List[int]) -> int:
    groupIdToSum = collections.defaultdict(int)

    for i, price in enumerate(prices):
      groupIdToSum[price - i] += price

    return max(groupIdToSum.values())

```

## 3064. Guess the Number Using Bitwise Questions I_3064.py
```python
# Definition of commonSetBits API.
# def commonSetBits(num: int) -> int:

class Solution:
  def findNumber(self) -> int:
    return sum(1 << i for i in range(31)
               if commonSetBits(1 << i) == 1)

```

## 594. Longest Harmonious Subsequence_594.py
```python
class Solution:
  def findLHS(self, nums: List[int]) -> int:
    ans = 0
    count = collections.Counter(nums)

    for num, freq in count.items():
      if num + 1 in count:
        ans = max(ans, freq + count[num + 1])

    return ans

```

## 12. Integer to Roman_12-2.py
```python
class Solution:
  def intToRoman(self, num: int) -> str:
    M = ['', 'M', 'MM', 'MMM']
    C = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM']
    X = ['', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC']
    I = ['', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX']
    return M[num // 1000] + C[num % 1000 // 100] + X[num % 100 // 10] + I[num % 10]

```

## 2197. Replace Non-Coprime Numbers in Array_2197.py
```python
class Solution:
  def replaceNonCoprimes(self, nums: List[int]) -> List[int]:
    ans = []

    for num in nums:
      while ans and math.gcd(ans[-1], num) > 1:
        num = math.lcm(ans.pop(), num)
      ans.append(num)

    return ans

```

## 1433. Check If a String Can Break Another String_1433-2.py
```python
class Solution:
  def checkIfCanBreak(self, s1: str, s2: str) -> bool:
    count = collections.Counter(s1)
    count.subtract(collections.Counter(s2))

    for a, b in itertools.pairwise(string.ascii_lowercase):
      count[b] += count[a]

    return all(value <= 0 for value in count.values()) or \
        all(value >= 0 for value in count.values())

```

## 1399. Count Largest Group_1399.py
```python
class Solution:
  def countLargestGroup(self, n: int) -> int:
    count = [0] * (9 * 4 + 1)
    for i in range(1, n + 1):
      count[self._getDigitSum(i)] += 1
    return count.count(max(count))

  def _getDigitSum(self, num: int) -> int:
    return sum(int(digit) for digit in str(num))

```

## 1290. Convert Binary Number in a Linked List to Integer_1290.py
```python
class Solution:
  def getDecimalValue(self, head: ListNode) -> int:
    ans = 0

    while head:
      ans = ans * 2 + head.val
      head = head.next

    return ans

```

## 998. Maximum Binary Tree II_998-2.py
```python
class Solution:
  def insertIntoMaxTree(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
    if root.val < val:
      return TreeNode(val, root, None)
    curr = root
    while curr.right and curr.right.val > val:
      curr = curr.right
    inserted = TreeNode(val, curr.right, None)
    curr.right = inserted
    return root

```

## 2766. Relocate Marbles_2766.py
```python
class Solution:
  def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:
    numsSet = set(nums)

    for f, t in zip(moveFrom, moveTo):
      numsSet.remove(f)
      numsSet.add(t)

    return sorted(numsSet)

```

## 2248. Intersection of Multiple Arrays_2248.py
```python
class Solution:
  def intersection(self, nums: List[List[int]]) -> List[int]:
    count = [0] * 1001

    for A in nums:
      for a in A:
        count[a] += 1

    return [i for i, c in enumerate(count)
            if c == len(nums)]

```

## 2390. Removing Stars From a String_2390.py
```python
class Solution:
  def removeStars(self, s: str) -> str:
    ans = []
    for c in s:
      if c == '*':
        ans.pop()
      else:
        ans.append(c)
    return ''.join(ans)

```

## 1704. Determine if String Halves Are Alike_1704.py
```python
class Solution:
  def halvesAreAlike(self, s: str) -> bool:
    kVowels = 'aeiouAEIOU'
    aVowelsCount = sum(c in kVowels for c in s[:len(s) // 2])
    bVowelsCount = sum(c in kVowels for c in s[len(s) // 2:])
    return aVowelsCount == bVowelsCount

```

## 66. Plus One_66.py
```python
class Solution:
  def plusOne(self, digits: List[int]) -> List[int]:
    for i, d in reversed(list(enumerate(digits))):
      if d < 9:
        digits[i] += 1
        return digits
      digits[i] = 0

    return [1] + digits

```

## 2960. Count Tested Devices After Test Operations_2960.py
```python
class Solution:
  def countTestedDevices(self, batteryPercentages: List[int]) -> int:
    ans = 0

    for batteryPercentage in batteryPercentages:
      if batteryPercentage - ans > 0:
        ans += 1

    return ans

```

## 338. Counting Bits_338.py
```python
class Solution:
  def countBits(self, n: int) -> List[int]:
    # f(i) := i's number of 1s in bitmask
    # f(i) = f(i / 2) + i % 2
    ans = [0] * (n + 1)

    for i in range(1, n + 1):
      ans[i] = ans[i // 2] + (i & 1)

    return ans

```

## 1277. Count Square Submatrices with All Ones_1277.py
```python
class Solution:
  def countSquares(self, matrix: List[List[int]]) -> int:
    for i in range(len(matrix)):
      for j in range(len(matrix[0])):
        if matrix[i][j] == 1 and i > 0 and j > 0:
          matrix[i][j] += min(matrix[i - 1][j - 1],
                              matrix[i - 1][j], matrix[i][j - 1])
    return sum(map(sum, matrix))

```

## 263. Ugly Number_263.py
```python
class Solution:
  def isUgly(self, n: int) -> bool:
    if n == 0:
      return False

    for prime in 2, 3, 5:
      while n % prime == 0:
        n //= prime

    return n == 1

```

## 1969. Minimum Non-Zero Product of the Array Elements_1969.py
```python
class Solution:
  def minNonZeroProduct(self, p: int) -> int:
    kMod = 1_000_000_007
    # Can always turn [1..2^p - 1] to [1, 1, ..., 2^p - 2, 2^p - 2, 2^p - 1].
    n = 1 << p
    halfCount = n // 2 - 1
    return pow(n - 2, halfCount, kMod) * ((n - 1) % kMod) % kMod

```

## 359. Logger Rate Limiter_359-2.py
```python
class Logger:
  def __init__(self):
    self.okTime = {}  # {message: ok time}

  def shouldPrintMessage(self, timestamp: int, message: str) -> bool:
    if timestamp < self.okTime.get(message, 0):
      return False

    self.okTime[message] = timestamp + 10
    return True

```

## 954. Array of Doubled Pairs_954.py
```python
class Solution:
  def canReorderDoubled(self, arr: List[int]) -> bool:
    count = collections.Counter(arr)

    for key in sorted(count, key=abs):
      if count[key] > count[2 * key]:
        return False
      count[2 * key] -= count[key]

    return True

```

## 2505. Bitwise OR of All Subsequence Sums_2505.py
```python
class Solution:
  def subsequenceSumOr(self, nums: List[int]) -> int:
    ans = 0
    prefix = 0

    for num in nums:
      prefix += num
      ans |= num | prefix

    return ans

```

## 965. Univalued Binary Tree_965.py
```python
class Solution:
  def isUnivalTree(self, root: Optional[TreeNode]) -> bool:
    if not root:
      return True
    if root.left and root.left.val != root.val:
      return False
    if root.right and root.right.val != root.val:
      return False
    return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)

```

## 1380. Lucky Numbers in a Matrix_1380.py
```python
class Solution:
  def luckyNumbers(self, matrix: List[List[int]]) -> List[int]:
    for row in matrix:
      minIndex = row.index(min(row))
      if row[minIndex] == max(list(zip(*matrix))[minIndex]):
        return [row[minIndex]]
    return []

```

## 389. Find the Difference_389-2.py
```python
class Solution:
  def findTheDifference(self, s: str, t: str) -> str:
    count = collections.Counter(s)

    for c in t:
      if count[c] == 0:
        return c
      count[c] -= 1

```

## 1685. Sum of Absolute Differences in a Sorted Array_1685.py
```python
class Solution:
  def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:
    prefix = list(itertools.accumulate(nums))
    suffix = list(itertools.accumulate(nums[::-1]))[::-1]
    return [num * (i + 1) - prefix[i] + suffix[i] - num * (len(nums) - i)
            for i, num in enumerate(nums)]

```

## 1790. Check if One String Swap Can Make Strings Equal_1790.py
```python
class Solution:
  # Similar to 859. Buddy Strings
  def areAlmostEqual(self, s1: str, s2: str) -> bool:
    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))
                   if a != b]
    return not diffIndices or (len(diffIndices) == 2 and
                               s1[diffIndices[0]] == s2[diffIndices[1]] and
                               s1[diffIndices[1]] == s2[diffIndices[0]])

```

## 3099. Harshad Number_3099.py
```python
class Solution:
  def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:
    digitSum = self._getDigitSum(x)
    return digitSum if x % digitSum == 0 else -1

  def _getDigitSum(self, num: int) -> int:
    return sum(int(digit) for digit in str(num))

```

## 1845. Seat Reservation Manager_1845.py
```python
class SeatManager:
  def __init__(self, n: int):
    self.minHeap = [i + 1 for i in range(n)]

  def reserve(self) -> int:
    return heapq.heappop(self.minHeap)

  def unreserve(self, seatNumber: int) -> None:
    heapq.heappush(self.minHeap, seatNumber)

```

## 1389. Create Target Array in the Given Order_1389.py
```python
class Solution:
  def createTargetArray(self, nums, index):
    ans = []
    for num, i in zip(nums, index):
      ans.insert(i, num)
    return ans

```

## 746. Min Cost Climbing Stairs_746.py
```python
class Solution:
  def minCostClimbingStairs(self, cost: List[int]) -> int:
    cost.append(0)

    for i in range(2, len(cost)):
      cost[i] += min(cost[i - 1], cost[i - 2])

    return cost[-1]

```

## 1758. Minimum Changes To Make Alternating Binary String_1758.py
```python
class Solution:
  def minOperations(self, s: str) -> int:
    # the cost to make s "1010"
    cost10 = sum(int(c) == i % 2 for i, c in enumerate(s))
    # the cost to make s "0101"
    cost01 = len(s) - cost10
    return min(cost10, cost01)

```

## 55. Jump Game_55.py
```python
class Solution:
  def canJump(self, nums: List[int]) -> bool:
    i = 0
    reach = 0

    while i < len(nums) and i <= reach:
      reach = max(reach, i + nums[i])
      i += 1

    return i == len(nums)

```

## 1033. Moving Stones Until Consecutive_1033.py
```python
class Solution:
  def numMovesStones(self, a: int, b: int, c: int) -> List[int]:
    nums = sorted([a, b, c])

    if nums[2] - nums[0] == 2:
      return [0, 0]
    return [1 if min(nums[1] - nums[0], nums[2] - nums[1]) <= 2 else 2,
            nums[2] - nums[0] - 2]

```

## 998. Maximum Binary Tree II_998.py
```python
class Solution:
  def insertIntoMaxTree(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
    if not root:
      return TreeNode(val)
    if root.val < val:
      return TreeNode(val, root, None)
    root.right = self.insertIntoMaxTree(root.right, val)
    return root

```

## 268. Missing Number_268.py
```python
class Solution:
  def missingNumber(self, nums: List[int]) -> int:
    ans = len(nums)

    for i, num in enumerate(nums):
      ans ^= i ^ num

    return ans

```

## 1317. Convert Integer to the Sum of Two No-Zero Integers_1317.py
```python
class Solution:
  def getNoZeroIntegers(self, n: int) -> List[int]:
    for A in range(n):
      B = n - A
      if '0' not in str(A) and '0' not in str(B):
        return A, B

```

## 2600. K Items With the Maximum Sum_2600.py
```python
class Solution:
  def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:
    if k <= numOnes:
      return k
    if k <= numOnes + numZeros:
      return numOnes
    return numOnes - (k - numOnes - numZeros)

```

## 1762. Buildings With an Ocean View_1762.py
```python
class Solution:
  def findBuildings(self, heights: List[int]) -> List[int]:
    stack = []

    for i, height in enumerate(heights):
      while stack and heights[stack[-1]] <= height:
        stack.pop()
      stack.append(i)

    return stack

```

## 1833. Maximum Ice Cream Bars_1833.py
```python
class Solution:
  def maxIceCream(self, costs: List[int], coins: int) -> int:
    for i, cost in enumerate(sorted(costs)):
      if coins >= cost:
        coins -= cost
      else:
        return i

    return len(costs)

```

## 49. Group Anagrams_49.py
```python
class Solution:
  def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
    dict = collections.defaultdict(list)

    for str in strs:
      key = ''.join(sorted(str))
      dict[key].append(str)

    return dict.values()

```

## 976. Largest Perimeter Triangle_976.py
```python
class Solution:
  def largestPerimeter(self, nums: List[int]) -> int:
    nums = sorted(nums)

    for i in range(len(nums) - 1, 1, -1):
      if nums[i - 2] + nums[i - 1] > nums[i]:
        return nums[i - 2] + nums[i - 1] + nums[i]

    return 0

```

## 322. Coin Change_322.py
```python
class Solution:
  def coinChange(self, coins: List[int], amount: int) -> int:
    # dp[i] := the minimum number Of coins to make up i
    dp = [0] + [amount + 1] * amount

    for coin in coins:
      for i in range(coin, amount + 1):
        dp[i] = min(dp[i], dp[i - coin] + 1)

    return -1 if dp[amount] == amount + 1 else dp[amount]

```

## 112. Path Sum_112.py
```python
class Solution:
  def hasPathSum(self, root: TreeNode, summ: int) -> bool:
    if not root:
      return False
    if root.val == summ and not root.left and not root.right:
      return True
    return self.hasPathSum(root.left, summ - root.val) or \
        self.hasPathSum(root.right, summ - root.val)

```

## 945. Minimum Increment to Make Array Unique_945.py
```python
class Solution:
  def minIncrementForUnique(self, nums: List[int]) -> int:
    ans = 0
    minAvailable = 0

    for num in sorted(nums):
      ans += max(minAvailable - num, 0)
      minAvailable = max(minAvailable, num) + 1

    return ans

```

## 1016. Binary String With Substrings Representing 1 To N_1016.py
```python
class Solution:
  def queryString(self, s: str, n: int) -> bool:
    if n > 1511:
      return False

    for i in range(n, n // 2, -1):
      if format(i, 'b') not in s:
        return False

    return True

```

## 89. Gray Code_89.py
```python
class Solution:
  def grayCode(self, n: int) -> List[int]:
    ans = [0]

    for i in range(n):
      for j in reversed(range(len(ans))):
        ans.append(ans[j] | 1 << i)

    return ans

```

## 191. Number of 1 Bits_191.py
```python
class Solution:
  def hammingWeight(self, n: int) -> int:
    ans = 0

    for i in range(32):
      if (n >> i) & 1:
        ans += 1

    return ans

```

## 1952. Three Divisors_1952.py
```python
class Solution:
  def isThree(self, n: int) -> bool:
    if n == 1:
      return False
    # The numbers with exactly three divisors are perfect squares of a prime
    # number.
    root = math.isqrt(n)
    return root**2 == n and \
        all(root % i != 0
            for i in range(2, math.isqrt(root) + 1))

```

## 1980. Find Unique Binary String_1980.py
```python
class Solution:
  def findDifferentBinaryString(self, nums: List[str]) -> str:
    bitSize = len(nums[0])
    maxNum = 1 << bitSize
    numsSet = {int(num, 2) for num in nums}

    for num in range(maxNum):
      if num not in numsSet:
        return f'{num:0>{bitSize}b}'

```

## 2103. Rings and Rods_2103.py
```python
class Solution:
  def countPoints(self, rings: str) -> int:
    colors = [0] * 10

    for c, num in zip(rings[::2], rings[1::2]):
      color = 1 if c == 'R' else 2 if c == 'G' else 4
      colors[int(num)] |= color

    return sum(color == 7 for color in colors)

```

## 2602. Minimum Operations to Make All Array Elements Equal_2602.py
```python
class Solution:
  def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:
    n = len(nums)
    nums.sort()
    prefix = [0] + list(itertools.accumulate(nums))
    splits = [(query, bisect.bisect_right(nums, query)) for query in queries]
    return [(query * i - prefix[i]) +
            (prefix[-1] - prefix[i] - query * (n - i))
            for query, i in splits]

```

## 2937. Make Three Strings Equal_2937.py
```python
class Solution:
  def findMinimumOperations(self, s1: str, s2: str, s3: str) -> int:
    minLength = min(map(len, [s1, s2, s3]))
    i = 0
    while i < minLength and s1[i] == s2[i] and s2[i] == s3[i]:
      i += 1
    return -1 if i == 0 else len(s1) + len(s2) + len(s3) - i * 3

```

## 2190. Most Frequent Number Following Key In an Array_2190.py
```python
class Solution:
  def mostFrequent(self, nums: List[int], key: int) -> int:
    count = collections.Counter()

    for a, b in zip(nums, nums[1:]):
      if a == key:
        count[b] += 1

    return max(count, key=lambda k: count[k])

```

## 2194. Cells in a Range on an Excel Sheet_2194.py
```python
class Solution:
  def cellsInRange(self, s: str) -> List[str]:
    ans = []
    startCol, startRow, _, endCol, endRow = s

    for j in range(ord(startCol), ord(endCol) + 1):
      for i in range(int(startRow), int(endRow) + 1):
        ans.append(chr(j) + str(i))

    return ans

```

## 1121. Divide Array Into Increasing Sequences_1121.py
```python
class Solution:
  def canDivideIntoSubsequences(self, nums: List[int], k: int) -> bool:
    # Find the number with the maxFreq, we need at least maxFreq * k elements
    # e.g. nums = [1, 2, 2, 3, 4], we have maxFreq = 2 (two 2s), so we have to
    # Split nums into two subsequences say k = 3, the minimum length of nums is 2 x
    # 3 = 6, which is impossible if len(nums) = 5
    return len(nums) >= k * max(Counter(nums).values())

```

## 1446. Consecutive Characters_1446.py
```python
class Solution:
  def maxPower(self, s: str) -> int:
    ans = 1
    count = 1

    for i in range(1, len(s)):
      count = count + 1 if s[i] == s[i - 1] else 1
      ans = max(ans, count)

    return ans

```

## 901. Online Stock Span_901.py
```python
class StockSpanner:
  def __init__(self):
    self.stack = []  # (price, span)

  def next(self, price: int) -> int:
    span = 1
    while self.stack and self.stack[-1][0] <= price:
      span += self.stack.pop()[1]
    self.stack.append((price, span))
    return span

```

## 70. Climbing Stairs_70.py
```python
class Solution:
  def climbStairs(self, n: int) -> int:
    # dp[i] := the number of ways to climb to the i-th stair
    dp = [1, 1] + [0] * (n - 1)

    for i in range(2, n + 1):
      dp[i] = dp[i - 1] + dp[i - 2]

    return dp[n]

```

## 2251. Number of Flowers in Full Bloom_2251.py
```python
class Solution:
  def fullBloomFlowers(self, flowers: List[List[int]], persons: List[int]) -> List[int]:
    starts = sorted(s for s, _ in flowers)
    ends = sorted(e for _, e in flowers)
    return [bisect.bisect_right(starts, person) -
            bisect.bisect_left(ends, person)
            for person in persons]

```

## 422. Valid Word Square_422.py
```python
class Solution:
  def validWordSquare(self, words: List[str]) -> bool:
    for i, word in enumerate(words):
      for j, c in enumerate(word):
        if len(words) <= j or len(words[j]) <= i:  # out-of-bounds
          return False
        if c != words[j][i]:
          return False
    return True

```

## 878. Nth Magical Number_878.py
```python
class Solution:
  def nthMagicalNumber(self, n: int, a: int, b: int) -> int:
    lcm = a * b // math.gcd(a, b)
    l = bisect.bisect_left(range(min(a, b), min(a, b) * n), n,
                           key=lambda m: m // a + m // b - m // lcm) + min(a, b)
    return l % (10**9 + 7)

```

## 1325. Delete Leaves With a Given Value_1325.py
```python
class Solution:
  def removeLeafNodes(self, root: Optional[TreeNode], target: int) -> Optional[TreeNode]:
    if not root:
      return None
    root.left = self.removeLeafNodes(root.left, target)
    root.right = self.removeLeafNodes(root.right, target)
    return None if self._isLeaf(root) and root.val == target else root

  def _isLeaf(self, root: Optional[TreeNode]) -> bool:
    return not root.left and not root.right

```

## 303. Range Sum Query - Immutable_303.py
```python
class NumArray:
  def __init__(self, nums: List[int]):
    self.prefix = [0] + list(itertools.accumulate(nums))

  def sumRange(self, left: int, right: int) -> int:
    return self.prefix[right + 1] - self.prefix[left]

```

## 1374. Generate a String With Characters That Have Odd Counts_1374.py
```python
class Solution:
  def generateTheString(self, n: int) -> str:
    s = 'a' * n
    if n % 2 == 0:
      s = s[:-1] + 'b'
    return s

```

## 1230. Toss Strange Coins_1230-2.py
```python
class Solution:
  def probabilityOfHeads(self, prob: List[float], target: int) -> float:
    # dp[j] := the probability of tossing the coins so far with j heads
    dp = [1.0] + [0] * len(prob)

    for p in prob:
      for j in range(target, -1, -1):
        dp[j] = (dp[j - 1] * p if j > 0 else 0) + dp[j] * (1 - p)

    return dp[target]

```

## 2946. Matrix Similarity After Cyclic Shifts_2946.py
```python
class Solution:
  def areSimilar(self, mat: List[List[int]], k: int) -> bool:
    n = len(mat[0])
    for row in mat:
      for j in range(n):
        if row[j] != row[(j + k) % n]:
          return False
    return True

```

## 2221. Find Triangular Sum of an Array_2221.py
```python
class Solution:
  def triangularSum(self, nums: List[int]) -> int:
    for sz in range(len(nums), 0, -1):
      for i in range(sz - 1):
        nums[i] = (nums[i] + nums[i + 1]) % 10
    return nums[0]

```

## 206. Reverse Linked List_206.py
```python
class Solution:
  def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
    if not head or not head.next:
      return head

    newHead = self.reverseList(head.next)
    head.next.next = head
    head.next = None
    return newHead

```

## 294. Flip Game II_294.py
```python
class Solution:
  @functools.lru_cache(None)
  def canWin(self, currentState: str) -> bool:
    # If any of currentState[i:i + 2] == "++" and your friend can't win after
    # changing currentState[i:i + 2] to "--" (or "-"), then you can win.
    return any(True
               for i, (a, b) in enumerate(zip(currentState, currentState[1:]))
               if a == '+' and b == '+' and
               not self.canWin(currentState[:i] + '-' + currentState[i + 2:]))

```

## 1957. Delete Characters to Make Fancy String_1957.py
```python
class Solution:
  def makeFancyString(self, s: str) -> str:
    ans = []
    for c in s:
      if len(ans) < 2 or ans[-1] != c or ans[-2] != c:
        ans.append(c)
    return ''.join(ans)

```

## 1564. Put Boxes Into the Warehouse I_1564-2.py
```python
class Solution:
  def maxBoxesInWarehouse(self, boxes: List[int], warehouse: List[int]) -> int:
    i = 0  # warehouse's index

    for box in sorted(boxes, reverse=True):
      if i < len(warehouse) and warehouse[i] >= box:
        i += 1

    return i

```

## 1. Two Sum_1.py
```python
class Solution:
  def twoSum(self, nums: List[int], target: int) -> List[int]:
    numToIndex = {}

    for i, num in enumerate(nums):
      if target - num in numToIndex:
        return numToIndex[target - num], i
      numToIndex[num] = i

```

## 1295. Find Numbers with Even Number of Digits_1295.py
```python
class Solution:
  def findNumbers(self, nums: List[int]) -> int:
    ans = 0

    for num in nums:
      if 9 < num < 100 or 999 < num < 10000 or num == 100000:
        ans += 1

    return ans

```

## 3142. Check if Grid Satisfies Conditions_3142.py
```python
class Solution:
  def satisfiesConditions(self, grid: List[List[int]]) -> bool:
    m = len(grid)
    n = len(grid[0])
    return all(grid[i][j] == grid[i + 1][j]
               for i in range(m - 1)
               for j in range(n)) and \
        all(grid[i][j] != grid[i][j + 1]
            for i in range(m)
            for j in range(n - 1))

```

## 1668. Maximum Repeating Substring_1668.py
```python
class Solution:
  def maxRepeating(self, sequence: str, word: str) -> int:
    ans = 1
    while word * ans in sequence:
      ans += 1
    return ans - 1

```

## 1754. Largest Merge Of Two Strings_1754.py
```python
class Solution:
  def largestMerge(self, word1: str, word2: str) -> str:
    if not word1:
      return word2
    if not word2:
      return word1
    if word1 > word2:
      return word1[0] + self.largestMerge(word1[1:], word2)
    return word2[0] + self.largestMerge(word1, word2[1:])

```

## 790. Domino and Tromino Tiling_790.py
```python
class Solution:
  def numTilings(self, n: int) -> int:
    kMod = 1_000_000_007
    dp = [0, 1, 2, 5] + [0] * 997

    for i in range(4, n + 1):
      dp[i] = 2 * dp[i - 1] + dp[i - 3]

    return dp[n] % kMod

```

## 2689. Extract Kth Character From The Rope Tree_2689.py
```python
class Solution:
  def getKthCharacter(self, root: Optional[object], k: int) -> str:
    """:type root: Optional[RopeTreeNode]"""
    if root.len == 0:
      return root.val[k - 1]
    leftLen = 0 if root.left is None \
        else max(root.left.len, len(root.left.val))
    if leftLen >= k:
      return self.getKthCharacter(root.left, k)
    return self.getKthCharacter(root.right, k - leftLen)

```

## 252. Meeting Rooms_252.py
```python
class Solution:
  def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
    intervals.sort()

    for i in range(1, len(intervals)):
      if intervals[i - 1][1] > intervals[i][0]:
        return False

    return True

```

## 2582. Pass the Pillow_2582.py
```python
class Solution:
  def passThePillow(self, n: int, time: int) -> int:
    # Repeat every (n - 1) * 2 seconds.
    time %= (n - 1) * 2
    if time < n:  # Go forward from 1.
      return 1 + time
    return n - (time - (n - 1))  # Go backward from n.

```

## 3184. Count Pairs That Form a Complete Day I_3184.py
```python
class Solution:
  def countCompleteDayPairs(self, hours: List[int]) -> int:
    ans = 0
    count = [0] * 24

    for hour in hours:
      ans += count[(24 - hour % 24) % 24]
      count[hour % 24] += 1

    return ans

```

## 28. Implement strStr()_28.py
```python
class Solution:
  def strStr(self, haystack: str, needle: str) -> int:
    m = len(haystack)
    n = len(needle)

    for i in range(m - n + 1):
      if haystack[i:i + n] == needle:
        return i

    return -1

```

## 1387. Sort Integers by The Power Value_1387.py
```python
class Solution:
  def getKth(self, lo: int, hi: int, k: int) -> int:
    return sorted([(self._getPow(i), i) for i in range(lo, hi + 1)])[k - 1][1]

  def _getPow(self, n: int) -> int:
    if n == 1:
      return 0
    if n % 2 == 0:
      return 1 + self._getPow(n // 2)
    return 1 + self._getPow(n * 3 + 1)

```

## 1009. Complement of Base 10 Integer_1009.py
```python
class Solution:
  def bitwiseComplement(self, n: int) -> int:
    mask = 1
    while mask < n:
      mask = (mask << 1) + 1
    return mask ^ n

```

## 1007. Minimum Domino Rotations For Equal Row_1007.py
```python
class Solution:
  def minDominoRotations(self, tops: List[int], bottoms: List[int]) -> int:
    for num in range(1, 7):
      if all(num in pair for pair in zip(tops, bottoms)):
        return len(tops) - max(tops.count(num), bottoms.count(num))
    return -1

```

## 3216. Lexicographically Smallest String After a Swap_3216.py
```python
class Solution:
  def getSmallestString(self, s: str) -> str:
    chars = list(s)
    for i, (a, b) in enumerate(itertools.pairwise(chars)):
      if ord(a) % 2 == ord(b) % 2 and a > b:
        chars[i], chars[i + 1] = chars[i + 1], chars[i]
        return ''.join(chars)
    return s

```

## 1886. Determine Whether Matrix Can Be Obtained By Rotation_1886.py
```python
class Solution:
  def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:
    for _ in range(4):
      if mat == target:
        return True
      mat = [list(x) for x in zip(*mat[::-1])]
    return False

```

## 53. Maximum Subarray_53-2.py
```python
class Solution:
  def maxSubArray(self, nums: List[int]) -> int:
    ans = -math.inf
    summ = 0

    for num in nums:
      summ = max(num, summ + num)
      ans = max(ans, summ)

    return ans

```

## 2883. Drop Missing Data_2883.py
```python
import pandas as pd


def dropMissingData(students: pd.DataFrame) -> pd.DataFrame:
  students.dropna(subset=['name'], inplace=True)
  return students

```

## 2889. Reshape Data: Pivot_2889.py
```python
import pandas as pd


def pivotTable(weather: pd.DataFrame) -> pd.DataFrame:
  return weather.pivot_table(
      index='month',
      columns='city',
      values='temperature',
      aggfunc='max',
  )

```

## 2126. Destroying Asteroids_2126.py
```python
class Solution:
  def asteroidsDestroyed(self, mass: int, asteroids: List[int]) -> bool:
    for asteroid in sorted(asteroids):
      if mass >= asteroid:
        mass += asteroid
      else:
        return False
    return True

```

## 2354. Number of Excellent Pairs_2354.py
```python
class Solution:
  def countExcellentPairs(self, nums: List[int], k: int) -> int:
    count = collections.Counter(map(int.bit_count, set(nums)))
    return sum(count[i] * count[j]
               for i in count
               for j in count
               if i + j >= k)

```

## 2136. Earliest Possible Day of Full Bloom_2136.py
```python
class Solution:
  def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:
    ans = 0
    time = 0

    for p, g in sorted([(p, g) for (p, g) in zip(plantTime, growTime)], key=lambda x: -x[1]):
      time += p
      ans = max(ans, time + g)

    return ans

```

## 2558. Take Gifts From the Richest Pile_2558.py
```python
class Solution:
  def pickGifts(self, gifts: List[int], k: int) -> int:
    maxHeap = [-gift for gift in gifts]
    heapq.heapify(maxHeap)

    for _ in range(k):
      squaredMax = math.isqrt(-heapq.heappop(maxHeap))
      heapq.heappush(maxHeap, -squaredMax)

    return -sum(maxHeap)

```

## 283. Move Zeroes_283.py
```python
class Solution:
  def moveZeroes(self, nums: List[int]) -> None:
    j = 0
    for num in nums:
      if num != 0:
        nums[j] = num
        j += 1

    for i in range(j, len(nums)):
      nums[i] = 0

```

## 1118. Number of Days in a Month_1118.py
```python
class Solution:
  def numberOfDays(self, year: int, month: int) -> int:
    days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    def isLeapYear(year: int) -> bool:
      return year % 4 == 0 and year % 100 != 0 or year % 400 == 0
    return 29 if month == 2 and isLeapYear(year) else days[month]

```

## 1921. Eliminate Maximum Number of Monsters_1921.py
```python
class Solution:
  def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:
    for i, arrivalTime in enumerate(sorted([(d - 1) // s for d, s in zip(dist, speed)])):
      if i > arrivalTime:
        return i
    return len(dist)

```

## 2293. Min Max Game_2293.py
```python
class Solution:
  def minMaxGame(self, nums: List[int]) -> int:
    if len(nums) == 1:
      return nums[0]

    nextNums = []
    for i in range(len(nums) // 2):
      nextNums.append(min(nums[2 * i], nums[2 * i + 1]) if i % 2 == 0 else
                      max(nums[2 * i], nums[2 * i + 1]))
    return self.minMaxGame(nextNums)

```

## 34. Find First and Last Position of Element in Sorted Array_34.py
```python
class Solution:
  def searchRange(self, nums: List[int], target: int) -> List[int]:
    l = bisect_left(nums, target)
    if l == len(nums) or nums[l] != target:
      return -1, -1
    r = bisect_right(nums, target) - 1
    return l, r

```

## 3100. Water Bottles II_3100.py
```python
class Solution:
  def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:
    ans = numBottles

    while numBottles >= numExchange:
      numBottles = numBottles - numExchange + 1
      numExchange += 1
      ans += 1

    return ans

```

## 442. Find All Duplicates in an Array_442.py
```python
class Solution:
  def findDuplicates(self, nums: List[int]) -> List[int]:
    ans = []

    for num in nums:
      nums[abs(num) - 1] *= -1
      if nums[abs(num) - 1] > 0:
        ans.append(abs(num))

    return ans

```

## 822. Card Flipping Game_822.py
```python
class Solution:
  def flipgame(self, fronts: List[int], backs: List[int]) -> int:
    same = {front
            for front, back in zip(fronts, backs)
            if front == back}
    return min([num for num in fronts + backs
                if num not in same] or [0])

```

## 1018. Binary Prefix Divisible By 5_1018.py
```python
class Solution:
  def prefixesDivBy5(self, nums: List[int]) -> List[bool]:
    ans = []
    curr = 0

    for num in nums:
      curr = (curr * 2 + num) % 5
      ans.append(curr % 5 == 0)

    return ans

```

## 989. Add to Array-Form of Integer_989.py
```python
class Solution:
  def addToArrayForm(self, num: List[int], k: int) -> List[int]:
    for i in reversed(range(len(num))):
      k, num[i] = divmod(num[i] + k, 10)

    while k > 0:
      num = [k % 10] + num
      k //= 10

    return num

```

## 1572. Matrix Diagonal Sum_1572.py
```python
class Solution:
  def diagonalSum(self, mat: List[List[int]]) -> int:
    n = len(mat)
    ans = 0

    for i in range(n):
      ans += mat[i][i]
      ans += mat[n - 1 - i][i]

    return ans if n % 2 == 0 else ans - mat[n // 2][n // 2]

```

## 2070. Most Beautiful Item for Each Query_2070.py
```python
class Solution:
  def maximumBeauty(self, items: List[List[int]], queries: List[int]) -> List[int]:
    prices, beauties = zip(*sorted(items))
    maxBeautySoFar = [0] * (len(beauties) + 1)

    for i, beauty in enumerate(beauties):
      maxBeautySoFar[i + 1] = max(maxBeautySoFar[i], beauty)

    return [maxBeautySoFar[bisect_right(prices, query)] for query in queries]

```

## 137. Single Number II_137.py
```python
class Solution:
  def singleNumber(self, nums: List[int]) -> int:
    ones = 0
    twos = 0

    for num in nums:
      ones ^= num & ~twos
      twos ^= num & ~ones

    return ones

```

## 1837. Sum of Digits in Base K_1837.py
```python
class Solution:
  def sumBase(self, n: int, k: int) -> int:
    ans = 0

    while n:
      ans += n % k
      n //= k

    return ans

```

## 1848. Minimum Distance to the Target Element_1848.py
```python
class Solution:
  def getMinDistance(self, nums: List[int], target: int, start: int) -> int:
    ans = math.inf

    for i, num in enumerate(nums):
      if num == target:
        ans = min(ans, abs(i - start))

    return ans

```

## 1497. Check If Array Pairs Are Divisible by k_1497.py
```python
class Solution:
  def canArrange(self, arr: List[int], k: int) -> bool:
    count = [0] * k

    for a in arr:
      a %= k
      count[a if a >= 0 else a + k] += 1

    return count[0] % 2 == 0 and \
        all(count[i] == count[k - i] for i in range(1, k // 2 + 1))

```

## 1410. HTML Entity Parser_1410.py
```python
class Solution:
  def entityParser(self, text: str) -> str:
    entityToChar = {'&quot;': '"', '&apos;': '\'',
                    '&gt;': '>', '&lt;': '<', '&frasl;': '/'}

    for entity, c in entityToChar.items():
      text = text.replace(entity, c)

    # Process '&' in last.
    return text.replace('&amp;', '&')

```

## 2594. Minimum Time to Repair Cars_2594.py
```python
class Solution:
  def repairCars(self, ranks: List[int], cars: int) -> int:
    def numCarsFixed(minutes: int) -> int:
      #    r * n^2 = minutes
      # -> n = sqrt(minutes / r)
      return sum(math.isqrt(minutes // rank) for rank in ranks)

    return bisect.bisect_left(
        range(0, min(ranks) * cars**2), cars,
        key=lambda m: numCarsFixed(m))

```

## 2974. Minimum Number Game_2974.py
```python
class Solution:
  def numberGame(self, nums: List[int]) -> List[int]:
    nums.sort()
    return [nums[i + 1] if i % 2 == 0
            else nums[i - 1]
            for i in range(len(nums))]

```

## 1365. How Many Numbers Are Smaller Than the Current Number_1365.py
```python
class Solution:
  def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:
    kMax = 100
    count = collections.Counter(nums)

    for i in range(1, kMax + 1):
      count[i] += count[i - 1]

    return [0 if num == 0 else count[num - 1]
            for num in nums]

```

## 2227. Encrypt and Decrypt Strings_2227-2.py
```python
class Encrypter:
  def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):
    self.keyToValue = {k: v for k, v in zip(keys, values)}
    self.decrypt = collections.Counter(self.encrypt(word)
                                       for word in dictionary).__getitem__

  def encrypt(self, word1: str) -> str:
    return ''.join(self.keyToValue[c] for c in word1)

```

## 693. Binary Number with Alternating Bits_693.py
```python
class Solution:
  def hasAlternatingBits(self, n: int) -> bool:
    #            n = 0b010101
    #       n >> 2 = 0b000101
    # n ^ (n >> 2) = 0b010000 = a
    #        a - 1 = 0b001111
    #  a & (a - 1) = 0
    a = n ^ (n >> 2)
    return (a & (a - 1)) == 0

```

## 1313. Decompress Run-Length Encoded List_1313.py
```python
class Solution:
  def decompressRLElist(self, nums: List[int]) -> List[int]:
    ans = []

    for i in range(0, len(nums), 2):
      ans += [nums[i + 1]] * nums[i]

    return ans

```

## 119. Pascal's Triangle II_119.py
```python
class Solution:
  def getRow(self, rowIndex: int) -> List[int]:
    ans = [1] * (rowIndex + 1)

    for i in range(2, rowIndex + 1):
      for j in range(1, i):
        ans[i - j] += ans[i - j - 1]

    return ans

```

## 280. Wiggle Sort_280.py
```python
class Solution:
  def wiggleSort(self, nums: List[int]) -> None:
    # 1. If i is even, then nums[i] <= nums[i - 1].
    # 2. If i is odd, then nums[i] >= nums[i - 1].
    for i in range(1, len(nums)):
      if i % 2 == 0 and nums[i] > nums[i - 1] or \
              i % 2 == 1 and nums[i] < nums[i - 1]:
        nums[i], nums[i - 1] = nums[i - 1], nums[i]

```

## 573. Squirrel Simulation_573.py
```python
class Solution:
  def minDistance(self, height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:
    def dist(a: List[int], b: List[int]) -> int:
      return abs(a[0] - b[0]) + abs(a[1] - b[1])

    totDist = sum(dist(nut, tree) for nut in nuts) * 2
    maxSave = max(dist(nut, tree) - dist(nut, squirrel) for nut in nuts)
    return totDist - maxSave

```

## 2285. Maximum Total Importance of Roads_2285.py
```python
class Solution:
  def maximumImportance(self, n: int, roads: List[List[int]]) -> int:
    count = [0] * n

    for u, v in roads:
      count[u] += 1
      count[v] += 1

    count.sort()
    return sum((i + 1) * c for i, c in enumerate(count))

```

## 518. Coin Change 2_518.py
```python
class Solution:
  def change(self, amount: int, coins: List[int]) -> int:
    dp = [1] + [0] * amount

    for coin in coins:
      for i in range(coin, amount + 1):
        dp[i] += dp[i - coin]

    return dp[amount]

```

## 1481. Least Number of Unique Integers after K Removals_1481.py
```python
class Solution:
  def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:
    minHeap = list(collections.Counter(arr).values())
    heapq.heapify(minHeap)

    # Greedily remove the k least frequent numbers to have the least number of unique integers.
    while k > 0:
      k -= heapq.heappop(minHeap)

    return len(minHeap) + (1 if k < 0 else 0)

```

## 2568. Minimum Impossible OR_2568.py
```python
class Solution:
  def minImpossibleOR(self, nums: List[int]) -> int:
    ans = 1
    numsSet = set(nums)

    while ans in numsSet:
      ans <<= 1

    return ans

```

## 2150. Find All Lonely Numbers in the Array_2150.py
```python
class Solution:
  def findLonely(self, nums: List[int]) -> List[int]:
    count = collections.Counter(nums)
    return [num for num, freq in count.items()
            if freq == 1 and
            count[num - 1] == 0 and
            count[num + 1] == 0]

```

## 2341. Maximum Number of Pairs in Array_2341.py
```python
class Solution:
  def numberOfPairs(self, nums: List[int]) -> List[int]:
    ans = [0] * 2
    count = collections.Counter(nums)

    for i in range(101):
      ans[0] += count[i] // 2
      ans[1] += count[i] & 1

    return ans

```

## 62. Unique Paths_62-2.py
```python
class Solution:
  def uniquePaths(self, m: int, n: int) -> int:
    dp = [1] * n

    for _ in range(1, m):
      for j in range(1, n):
        dp[j] += dp[j - 1]

    return dp[n - 1]

```

## 406. Queue Reconstruction by Height_406.py
```python
class Solution:
  def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
    ans = []

    people.sort(key=lambda x: (-x[0], x[1]))

    for p in people:
      ans.insert(p[1], p)

    return ans

```

## 1470. Shuffle the Array_1470.py
```python
class Solution:
  def shuffle(self, nums: List[int], n: int) -> List[int]:
    ans = []
    for a, b in zip(nums[:n], nums[n:]):
      ans.append(a)
      ans.append(b)
    return ans

```

## 190. Reverse Bits_190.py
```python
class Solution:
  def reverseBits(self, n: int) -> int:
    ans = 0

    for i in range(32):
      if n >> i & 1:
        ans |= 1 << 31 - i

    return ans

```

## 1218. Longest Arithmetic Subsequence of Given Difference_1218.py
```python
class Solution:
  def longestSubsequence(self, arr: List[int], difference: int) -> int:
    ans = 0
    lengthAt = {}

    for a in arr:
      lengthAt[a] = lengthAt.get(a - difference, 0) + 1
      ans = max(ans, lengthAt[a])

    return ans

```

## 3206. Alternating Groups I_3206.py
```python
class Solution:
  def numberOfAlternatingGroups(self, colors: List[int]) -> int:
    n = len(colors)
    return sum(colors[i] != colors[i - 1] and
               colors[i] != colors[(i + 1) % n]
               for i in range(n))

```

## 814. Binary Tree Pruning_814.py
```python
class Solution:
  def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
    if not root:
      return None
    root.left = self.pruneTree(root.left)
    root.right = self.pruneTree(root.right)
    if not root.left and not root.right and not root.val:
      return None
    return root

```

## 2773. Height of Special Binary Tree_2773.py
```python
class Solution:
  def heightOfTree(self, root: Optional[TreeNode]) -> int:
    if not root:
      return 0
    # a leaf node
    if root.left and root.left.right == root:
      return 0
    return 1 + max(self.heightOfTree(root.left), self.heightOfTree(root.right))

```

## 2032. Two Out of Three_2032.py
```python
class Solution:
  def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:
    count = collections.Counter()
    for nums in nums1, nums2, nums3:
      count.update(set(nums))
    return [i for i, c in count.items() if c >= 2]

```

## 729. My Calendar I_729.py
```python
class MyCalendar:
  def __init__(self):
    self.timeline = []

  def book(self, start: int, end: int) -> bool:
    for s, e in self.timeline:
      if max(start, s) < min(end, e):
        return False
    self.timeline.append((start, end))
    return True

```

## 2490. Circular Sentence_2490.py
```python
class Solution:
  def isCircularSentence(self, sentence: str) -> bool:
    for i, c in enumerate(sentence):
      if c == ' ' and sentence[i - 1] != sentence[i + 1]:
        return False
    return sentence[0] == sentence[-1]

```

## 226. Invert Binary Tree_226.py
```python
class Solution:
  def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
    if not root:
      return None

    left = root.left
    right = root.right
    root.left = self.invertTree(right)
    root.right = self.invertTree(left)
    return root

```

## 2498. Frog Jump II_2498.py
```python
class Solution:
  def maxJump(self, stones: List[int]) -> int:
    # Let's denote the forwarding path as F and the backwarding path as B.
    # 'F1 B2 B1 F2' is no better than 'F1 B2 F2 B1' since the distance between
    # F1 and F2 increase, resulting a larger `ans`.
    if len(stones) == 2:
      return stones[1] - stones[0]
    return max(stones[i] - stones[i - 2]
               for i in range(2, len(stones)))

```

## 1876. Substrings of Size Three with Distinct Characters_1876.py
```python
class Solution:
  def countGoodSubstrings(self, s: str) -> int:
    ans = 0

    for a, b, c in zip(s, s[1:], s[2:]):
      if a == b or a == c or b == c:
        continue
      ans += 1

    return ans

```

## 1217. Play with Chips_1217.py
```python
class Solution:
  def minCostToMoveChips(self, position: List[int]) -> int:
    count = [0] * 2
    for p in position:
      count[p % 2] += 1
    return min(count[0], count[1])

```

## 2939. Maximum Xor Product_2939.py
```python
class Solution:
  def maximumXorProduct(self, a: int, b: int, n: int) -> int:
    kMod = 1_000_000_007
    for bit in (2**i for i in range(n)):
      # Pick a bit if it makes min(a, b) larger.
      if a * b < (a ^ bit) * (b ^ bit):
        a ^= bit
        b ^= bit
    return a * b % kMod

```

## 2924. Find Champion II_2924.py
```python
class Solution:
  def findChampion(self, n: int, edges: List[List[int]]) -> int:
    inDegrees = [0] * n

    for _, v in edges:
      inDegrees[v] += 1

    return -1 if inDegrees.count(0) > 1 \
        else inDegrees.index(0)

```

## 21. Merge Two Sorted Lists_21.py
```python
class Solution:
  def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
    if not list1 or not list2:
      return list1 if list1 else list2
    if list1.val > list2.val:
      list1, list2 = list2, list1
    list1.next = self.mergeTwoLists(list1.next, list2)
    return list1

```

## 401. Binary Watch_401-2.py
```python
class Solution:
  def readBinaryWatch(self, turnedOn: int) -> List[str]:
    ans = []

    for h in range(12):
      for m in range(60):
        if h.bit_count() + m.bit_count() == turnedOn:
          ans.append(f'{h}:{m:02d}')

    return ans

```

## 2917. Find the K-or of an Array_2917.py
```python
class Solution:
  def findKOr(self, nums: List[int], k: int) -> int:
    kMaxBit = 30
    return sum(2**i
               for i in range(kMaxBit + 1)
               if sum(num >> i & 1 for num in nums) >= k)

```

## 1232. Check If It Is a Straight Line_1232.py
```python
class Solution:
  def checkStraightLine(self, coordinates: List[List[int]]) -> bool:
    x0, y0, x1, y1 = *coordinates[0], *coordinates[1]
    dx = x1 - x0
    dy = y1 - y0

    return all((x - x0) * dy == (y - y0) * dx for x, y in coordinates)

```

## 3101. Count Alternating Subarrays_3101.py
```python
class Solution:
  def countAlternatingSubarrays(self, nums: List[int]) -> int:
    # dp[i] := the number of alternating subarrays ending in index i
    dp = [1] * len(nums)

    for i in range(1, len(nums)):
      if nums[i] != nums[i - 1]:
        dp[i] += dp[i - 1]

    return sum(dp)

```

## 1266. Minimum Time Visiting All Points_1266.py
```python
class Solution:
  def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:
    ans = 0

    for i in range(1, len(points)):
      ans += max(abs(points[i][0] - points[i - 1][0]),
                 abs(points[i][1] - points[i - 1][1]))

    return ans

```

## 1331. Rank Transform of an Array_1331.py
```python
class Solution:
  def arrayRankTransform(self, arr: List[int]) -> List[int]:
    rank = {}

    for a in sorted(arr):
      if a not in rank:
        rank[a] = len(rank) + 1

    return map(rank.get, arr)

```

## 1894. Find the Student that Will Replace the Chalk_1894.py
```python
class Solution:
  def chalkReplacer(self, chalk: List[int], k: int) -> int:
    k %= sum(chalk)
    if k == 0:
      return 0

    for i, c in enumerate(chalk):
      k -= c
      if k < 0:
        return i

```

## 717. 1-bit and 2-bit Characters_717.py
```python
class Solution:
  def isOneBitCharacter(self, bits: List[int]) -> bool:
    i = 0
    while i < len(bits) - 1:
      i += bits[i] + 1

    return i == len(bits) - 1

```

## 2891. Method Chaining_2891.py
```python
import pandas as pd


def findHeavyAnimals(animals: pd.DataFrame) -> pd.DataFrame:
  return animals[animals['weight'] > 100].sort_values(
      by='weight',
      ascending=False
  )[['name']]

```

## 2965. Find Missing and Repeated Values_2965.py
```python
class Solution:
  def findMissingAndRepeatedValues(self, grid: List[List[int]]) -> List[int]:
    count = [1] + [0] * len(grid)**2  # padding for 1-indexed

    for row in grid:
      for num in row:
        count[num] += 1

    return [count.index(2), count.index(0)]

```

## 122. Best Time to Buy and Sell Stock II_122.py
```python
class Solution:
  def maxProfit(self, prices: List[int]) -> int:
    sell = 0
    hold = -math.inf

    for price in prices:
      sell = max(sell, hold + price)
      hold = max(hold, sell - price)

    return sell

```

## 2869. Minimum Operations to Collect Elements_2869.py
```python
class Solution:
  def minOperations(self, nums: List[int], k: int) -> int:
    seen = set()

    for i, num in enumerate(reversed(nums)):
      if num > k:
        continue
      seen.add(num)
      if len(seen) == k:
        return i + 1

```

## 344. Reverse String_344.py
```python
class Solution:
  def reverseString(self, s: List[str]) -> None:
    l = 0
    r = len(s) - 1

    while l < r:
      s[l], s[r] = s[r], s[l]
      l += 1
      r -= 1

```

## 2191. Sort the Jumbled Numbers_2191.py
```python
class Solution:
  def sortJumbled(self, mapping: List[int], nums: List[int]) -> List[int]:
    def getMapped(num: int) -> int:
      mapped = []
      for c in str(num):
        mapped.append(str(mapping[ord(c) - ord('0')]))
      return int(''.join(mapped))
    A = [(getMapped(num), i, num) for i, num in enumerate(nums)]
    return [num for _, i, num in sorted(A)]

```

## 1131. Maximum of Absolute Value Expression_1131.py
```python
class Solution:
  def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:
    n = len(arr1)
    a = [arr1[i] + arr2[i] + i for i in range(n)]
    b = [arr1[i] + arr2[i] - i for i in range(n)]
    c = [arr1[i] - arr2[i] + i for i in range(n)]
    d = [arr1[i] - arr2[i] - i for i in range(n)]
    return max(map(lambda x: max(x) - min(x), (a, b, c, d)))

```

## 2309. Greatest English Letter in Upper and Lower Case_2309.py
```python
class Solution:
  def greatestLetter(self, s: str) -> str:
    seen = set(s)

    for i in range(25, -1, -1):
      if chr(ord('a') + i) in seen and \
              chr(ord('A') + i) in seen:
        return chr(ord('A') + i)

    return ''

```

## 2344. Minimum Deletions to Make Array Divisible_2344.py
```python
class Solution:
  def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
    gcd = functools.reduce(math.gcd, numsDivide)

    for i, num in enumerate(sorted(nums)):
      if gcd % num == 0:
        return i

    return -1

```

## 2171. Removing Minimum Number of Magic Beans_2171.py
```python
class Solution:
  def minimumRemoval(self, beans: List[int]) -> int:
    n = len(beans)
    summ = sum(beans)
    return min(summ - (n - i) * bean
               for i, bean in enumerate(sorted(beans)))

```

## 1426. Counting Elements_1426.py
```python
class Solution:
  def countElements(self, arr: List[int]) -> int:
    count = collections.Counter(arr)
    return sum(freq
               for a, freq in count.items()
               if count[a + 1] > 0)

```

## 2745. Construct the Longest New String_2745.py
```python
class Solution:
  def longestString(self, x: int, y: int, z: int) -> int:
    # 'AB' can always be easily appended within the string.
    # Alternating 'AA' and 'BB' can be appended, creating a pattern like 'AABB'
    # If x == y, we repeat the pattern 'AABBAABB...AABB'.
    # If x != y, the pattern becomes 'AABBAABB...AABBAA' or 'BBAABBAABB...AABB'
    mn = min(x, y)
    if x == y:
      return (mn * 2 + z) * 2
    return (mn * 2 + 1 + z) * 2

```

## 1299. Replace Elements with Greatest Element on Right Side_1299.py
```python
class Solution:
  def replaceElements(self, arr: List[int]) -> List[int]:
    maxOfRight = -1
    for i in reversed(range(len(arr))):
      arr[i], maxOfRight = maxOfRight, max(maxOfRight, arr[i])
    return arr

```

## 1276. Number of Burgers with No Waste of Ingredients_1276.py
```python
class Solution:
  def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:
    if tomatoSlices % 2 == 1 or tomatoSlices < 2 * cheeseSlices or tomatoSlices > cheeseSlices * 4:
      return []

    jumboBurgers = (tomatoSlices - 2 * cheeseSlices) // 2

    return [jumboBurgers, cheeseSlices - jumboBurgers]

```

## 1086. High Five_1086.py
```python
class Solution:
  def highFive(self, items: List[List[int]]) -> List[List[int]]:
    idToScores = collections.defaultdict(list)

    for id, score in items:
      heapq.heappush(idToScores[id], score)
      if len(idToScores[id]) > 5:
        heapq.heappop(idToScores[id])

    return [[id, sum(scores) // 5] for id, scores in sorted(idToScores.items())]

```

## 1413. Minimum Value to Get Positive Step by Step Sum_1413.py
```python
class Solution:
  def minStartValue(self, nums: List[int]) -> int:
    summ = 0
    minSum = 0

    for num in nums:
      summ += num
      minSum = min(minSum, summ)

    return 1 - minSum

```

## 3189. Minimum Moves to Get a Peaceful Board_3189.py
```python
class Solution:
  def minMoves(self, rooks: List[List[int]]) -> int:
    n = len(rooks)
    sortedByRow = sorted(rooks, key=lambda x: x[0])
    sortedByCol = sorted(rooks, key=lambda x: x[1])
    return sum(abs(i - row) for (i, _), row in zip(sortedByRow, range(n))) \
        + sum(abs(j - col) for (_, j), col in zip(sortedByCol, range(n)))

```

## 2083. Substrings That Begin and End With the Same Letter_2083.py
```python
class Solution:
  def numberOfSubstrings(self, s: str) -> int:
    ans = 0
    count = collections.Counter()

    for c in s:
      ans += count[c] + 1
      count[c] += 1

    return ans

```

## 1201. Ugly Number III_1201.py
```python
class Solution:
  def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:
    ab = a * b // math.gcd(a, b)
    ac = a * c // math.gcd(a, c)
    bc = b * c // math.gcd(b, c)
    abc = a * bc // math.gcd(a, bc)
    return bisect.bisect_left(
        range(2 * 10**9), n,
        key=lambda m: m // a + m // b + m // c - m // ab - m // ac - m // bc + m // abc)

```

## 2679. Sum in a Matrix_2679.py
```python
class Solution:
  def matrixSum(self, nums: List[List[int]]) -> int:
    for row in nums:
      row.sort()

    return sum(max(col) for col in zip(*nums))

```

## 27. Remove Element_27.py
```python
class Solution:
  def removeElement(self, nums: List[int], val: int) -> int:
    i = 0

    for num in nums:
      if num != val:
        nums[i] = num
        i += 1

    return i

```

## 528. Random Pick with Weight_528-2.py
```python
class Solution:
  def __init__(self, w: List[int]):
    self.prefix = list(itertools.accumulate(w))

  def pickIndex(self) -> int:
    return bisect_left(self.prefix, random.random() * self.prefix[-1])

```

## 897. Increasing Order Search Tree_897.py
```python
class Solution:
  def increasingBST(self, root: TreeNode, tail: TreeNode = None) -> TreeNode:
    if not root:
      return tail

    res = self.increasingBST(root.left, root)
    root.left = None
    root.right = self.increasingBST(root.right, tail)
    return res

```

## 137. Single Number II_137-2.py
```python
class Solution:
  def singleNumber(self, nums: List[int]) -> int:
    ones = 0
    twos = 0

    for num in nums:
      ones ^= (num & ~twos)
      twos ^= (num & ~ones)

    return ones

```

## 235. Lowest Common Ancestor of a Binary Search Tree_235.py
```python
class Solution:
  def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
    if root.val > max(p.val, q.val):
      return self.lowestCommonAncestor(root.left, p, q)
    if root.val < min(p.val, q.val):
      return self.lowestCommonAncestor(root.right, p, q)
    return root

```

## 832. Flipping an Image_832.py
```python
class Solution:
  def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:
    n = len(A)

    for i in range(n):
      for j in range((n + 2) // 2):
        A[i][j], A[i][n - j - 2] = A[i][n - j - 1] ^ 2, A[i][j] ^ 1

    return A

```

## 1603. Design Parking System_1603.py
```python
class ParkingSystem:
  def __init__(self, big: int, medium: int, small: int):
    self.count = [big, medium, small]

  def addCar(self, carType: int) -> bool:
    self.count[carType - 1] -= 1
    return self.count[carType - 1] >= 0

```

## 1534. Count Good Triplets_1534.py
```python
class Solution:
  def countGoodTriplets(self, arr: List[int], a: int, b: int, c: int) -> int:
    return sum(abs(arr[i] - arr[j]) <= a and
               abs(arr[j] - arr[k]) <= b and
               abs(arr[i] - arr[k]) <= c
               for i in range(len(arr))
               for j in range(i + 1, len(arr))
               for k in range(j + 1, len(arr)))

```

## 1196. How Many Apples Can You Put into the Basket_1196.py
```python
class Solution:
  def maxNumberOfApples(self, weight: List[int]) -> int:
    summ = 0

    for i, w in enumerate(sorted(weight)):
      summ += w
      if summ > 5000:
        return i

    return len(weight)

```

## 1400. Construct K Palindrome Strings_1400.py
```python
class Solution:
  def canConstruct(self, s: str, k: int) -> bool:
    # If |s| < k, we cannot construct k strings from the s.
    # If the number of letters that have odd counts > k, the minimum number of
    # palindromic strings we can construct is > k.
    return sum(freq & 1
               for freq in collections.Counter(s).values()) <= k <= len(s)

```

## 539. Minimum Time Difference_539.py
```python
class Solution:
  def findMinDifference(self, timePoints: List[str]) -> int:
    ans = 24 * 60
    nums = sorted([int(timePoint[:2]) * 60 + int(timePoint[3:])
                   for timePoint in timePoints])

    for a, b in zip(nums, nums[1:]):
      ans = min(ans, b - a)

    return min(ans, 24 * 60 - nums[-1] + nums[0])

```

## 940. Distinct Subsequences II_940.py
```python
class Solution:
  def distinctSubseqII(self, s: str) -> int:
    kMod = 1_000_000_007
    # endsIn[i] := the number of subsequence that end in ('a' + i)
    endsIn = [0] * 26

    for c in s:
      endsIn[ord(c) - ord('a')] = (sum(endsIn) + 1) % kMod

    return sum(endsIn) % kMod

```

## 2807. Insert Greatest Common Divisors in Linked List_2807.py
```python
class Solution:
  def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:
    curr = head
    while curr.next:
      inserted = ListNode(math.gcd(curr.val, curr.next.val), curr.next)
      curr.next = inserted
      curr = inserted.next
    return head

```

## 933. Number of Recent Calls_933.py
```python
class RecentCounter:
  def __init__(self):
    self.q = collections.deque()

  def ping(self, t: int) -> int:
    self.q.append(t)
    while self.q[0] < t - 3000:
      self.q.popleft()
    return len(self.q)

```

## 2274. Maximum Consecutive Floors Without Special Floors_2274.py
```python
class Solution:
  def maxConsecutive(self, bottom: int, top: int, special: List[int]) -> int:
    ans = 0

    special.sort()

    for a, b in zip(special, special[1:]):
      ans = max(ans, b - a - 1)

    return max(ans, special[0] - bottom, top - special[-1])

```

## 120. Triangle_120.py
```python
class Solution:
  def minimumTotal(self, triangle: List[List[int]]) -> int:
    for i in reversed(range(len(triangle) - 1)):
      for j in range(i + 1):
        triangle[i][j] += min(triangle[i + 1][j],
                              triangle[i + 1][j + 1])

    return triangle[0][0]

```

## 50. Pow(x, n)_50.py
```python
class Solution:
  def myPow(self, x: float, n: int) -> float:
    if n == 0:
      return 1
    if n < 0:
      return 1 / self.myPow(x, -n)
    if n % 2 == 1:
      return x * self.myPow(x, n - 1)
    return self.myPow(x * x, n // 2)

```

## 2956. Find Common Elements Between Two Arrays_2956.py
```python
class Solution:
  def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -> List[int]:
    nums1Set = set(nums1)
    nums2Set = set(nums2)
    return [sum(num in nums2Set for num in nums1),
            sum(num in nums1Set for num in nums2)]

```

## 701. Insert into a Binary Search Tree_701.py
```python
class Solution:
  def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
    if not root:
      return TreeNode(val)
    if root.val > val:
      root.left = self.insertIntoBST(root.left, val)
    else:
      root.right = self.insertIntoBST(root.right, val)
    return root

```

## 3094. Guess the Number Using Bitwise Questions II_3094-2.py
```python
# Definition of commonBits API.
# def commonBits(num: int) -> int:

class Solution:
  def findNumber(self) -> int:
    return functools.reduce(lambda x, i: x | (1 << i)
                            if commonBits(1 << i) > commonBits(1 << i)
                            else x, range(31), 0)

```

## 950. Reveal Cards In Increasing Order_950.py
```python
class Solution:
  def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:
    dq = collections.deque()

    for card in reversed(sorted(deck)):
      dq.rotate()
      dq.appendleft(card)

    return list(dq)

```

## 559. Maximum Depth of N-ary Tree_559.py
```python
class Solution:
  def maxDepth(self, root: 'Node') -> int:
    if not root:
      return 0
    if not root.children:
      return 1
    return 1 + max(self.maxDepth(child) for child in root.children)

```

## 26. Remove Duplicates from Sorted Array_26.py
```python
class Solution:
  def removeDuplicates(self, nums: List[int]) -> int:
    i = 0

    for num in nums:
      if i < 1 or num > nums[i - 1]:
        nums[i] = num
        i += 1

    return i

```

## 2154. Keep Multiplying Found Values by Two_2155.py
```python
class Solution:
  def findFinalValue(self, nums: List[int], original: int) -> int:
    numsSet = set(nums)
    while original in numsSet:
      original *= 2
    return original

```

## 1183. Maximum Number of Ones_1183.py
```python
class Solution:
  def maximumNumberOfOnes(self, width: int, height: int, sideLength: int, maxOnes: int) -> int:
    submatrix = [[0] * sideLength for _ in range(sideLength)]

    for i in range(width):
      for j in range(height):
        submatrix[i % sideLength][j % sideLength] += 1

    return sum(heapq.nlargest(maxOnes, [a for row in submatrix for a in row]))

```

## 1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts_1465.py
```python
class Solution:
  def maxArea(self, h: int, w: int, horizontalCuts: List[int], verticalCuts: List[int]) -> int:
    kMod = 1_000_000_007
    # the maximum gap of each direction
    maxGapX = max(b - a
                  for a, b in itertools.pairwise([0] + sorted(horizontalCuts) + [h]))
    maxGapY = max(b - a
                  for a, b in itertools.pairwise([0] + sorted(verticalCuts) + [w]))
    return maxGapX * maxGapY % kMod

```

## 2085. Count Common Words With One Occurrence_2085.py
```python
class Solution:
  def countWords(self, words1: List[str], words2: List[str]) -> int:
    count = collections.Counter(words1)

    for word in words2:
      if word in count and count[word] < 2:
        count[word] -= 1

    return sum(value == 0 for value in count.values())

```

## 2018. Check if Word Can Be Placed In Crossword_2018.py
```python
class Solution:
  def placeWordInCrossword(self, board: List[List[str]], word: str) -> bool:
    for x in board, zip(*board):
      for row in x:
        for token in ''.join(row).split('#'):
          for letters in word, word[::-1]:
            if len(token) == len(letters):
              if all(c in (' ', letter) for c, letter in zip(token, letters)):
                return True
    return False

```

## 1080. Insufficient Nodes in Root to Leaf Paths_1080.py
```python
class Solution:
  def sufficientSubset(self, root: Optional[TreeNode], limit: int) -> Optional[TreeNode]:
    if not root:
      return None
    if not root.left and not root.right:
      return None if root.val < limit else root
    root.left = self.sufficientSubset(root.left, limit - root.val)
    root.right = self.sufficientSubset(root.right, limit - root.val)
    return None if not root.left and not root.right else root

```

## 1817. Finding the Users Active Minutes_1817.py
```python
class Solution:
  def findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -> List[int]:
    idToTimes = collections.defaultdict(set)

    for id, time in logs:
      idToTimes[id].add(time)

    c = collections.Counter(len(times) for times in idToTimes.values())
    return [c[i] for i in range(1, k + 1)]

```

## 3125. Maximum Number That Makes Result of Bitwise AND Zero_3125.py
```python
class Solution:
  def maxNumber(self, n: int) -> int:
    # assume n = 0b00...11???
    #        x = 0b00...01111
    #  since y = 0b00...10000 is in [x, n]
    #    and x & y = 0
    return (1 << n.bit_length() - 1) - 1

```

## 319. Bulb Switcher_319.py
```python
class Solution:
  def bulbSwitch(self, n: int) -> int:
    # The k-th bulb can only be switched when k % i == 0.
    # So, we can rephrase the problem:
    # To find number of numbers <= n that have odd factors.
    # Obviously, only square numbers have odd factor(s).
    # e.g. n = 10, only 1, 4, and 9 are square numbers that <= 10
    return math.isqrt(n)

```

## 2884. Modify Columns_2884.py
```python
import pandas as pd


def modifySalaryColumn(employees: pd.DataFrame) -> pd.DataFrame:
  employees['salary'] = employees['salary'] * 2
  return employees

```

## 1344. Angle Between Hands of a Clock_1344.py
```python
class Solution:
  def angleClock(self, hour: int, minutes: int) -> float:
    hourAngle = (hour % 12) * 30 + minutes * 0.5
    minuteAngle = minutes * 6
    ans = abs(hourAngle - minuteAngle)

    return min(ans, 360 - ans)

```

## 2262. Total Appeal of A String_2262-2.py
```python
class Solution:
  def appealSum(self, s: str) -> int:
    ans = 0
    lastSeen = {}

    for i, c in enumerate(s):
      ans += (i - lastSeen.get(c, -1)) * (len(s) - i)
      lastSeen[c] = i

    return ans

```

## 1144. Decrease Elements To Make Array Zigzag_1144.py
```python
class Solution:
  def movesToMakeZigzag(self, nums: List[int]) -> int:
    decreasing = [0] * 2

    for i, num in enumerate(nums):
      l = nums[i - 1] if i > 0 else 1001
      r = nums[i + 1] if i + 1 < len(nums) else 1001
      decreasing[i % 2] += max(0, num - min(l, r) + 1)

    return min(decreasing[0], decreasing[1])

```

## 875. Koko Eating Bananas_875.py
```python
class Solution:
  def minEatingSpeed(self, piles: List[int], h: int) -> int:
    def eatHours(m: int) -> bool:
      """Returns True if Koko can eat all piles with speed m."""
      return sum((pile - 1) // m + 1 for pile in piles) <= h
    return bisect.bisect_left(range(1, max(piles)), True,
                              key=lambda m: eatHours(m)) + 1

```

## 896. Monotonic Array_896.py
```python
class Solution:
  def isMonotonic(self, nums: List[int]) -> bool:
    increasing = True
    decreasing = True

    for i in range(1, len(nums)):
      increasing &= nums[i - 1] <= nums[i]
      decreasing &= nums[i - 1] >= nums[i]

    return increasing or decreasing

```

## 1953. Maximum Number of Weeks for Which You Can Work_1953.py
```python
class Solution:
  def numberOfWeeks(self, milestones: List[int]) -> int:
    # The best strategy is to pick 'max, nonMax, max, nonMax, ...'.
    summ = sum(milestones)
    nonMax = summ - max(milestones)
    return min(summ, 2 * nonMax + 1)

```

## 1844. Replace All Digits with Characters_1844.py
```python
class Solution:
  def replaceDigits(self, s: str) -> str:
    chars = list(s)

    for i in range(1, len(chars), 2):
      chars[i] = chr(ord(chars[i - 1]) + ord(chars[i]) - ord('0'))

    return ''.join(chars)

```

## 1014. Best Sightseeing Pair_1014.py
```python
class Solution:
  def maxScoreSightseeingPair(self, values: List[int]) -> int:
    ans = 0
    bestPrev = 0

    for value in values:
      ans = max(ans, value + bestPrev)
      bestPrev = max(bestPrev, value) - 1

    return ans

```

## 2165. Smallest Value of the Rearranged Number_2165.py
```python
class Solution:
  def smallestNumber(self, num: int) -> int:
    s = sorted(str(abs(num)), reverse=num < 0)
    firstNonZeroIndex = next((i for i, c in enumerate(s) if c != '0'), 0)
    s[0], s[firstNonZeroIndex] = s[firstNonZeroIndex], s[0]
    return int(''.join(s)) * (-1 if num < 0 else 1)

```

## 83. Remove Duplicates from Sorted List_83.py
```python
class Solution:
  def deleteDuplicates(self, head: ListNode) -> ListNode:
    curr = head

    while curr:
      while curr.next and curr.val == curr.next.val:
        curr.next = curr.next.next
      curr = curr.next

    return head

```

## 1780. Check if Number is a Sum of Powers of Three_1780.py
```python
class Solution:
  def checkPowersOfThree(self, n: int) -> bool:
    while n > 1:
      n, r = divmod(n, 3)
      if r == 2:
        return False
    return True

```

## 1881. Maximum Value after Insertion_1881.py
```python
class Solution:
  def maxValue(self, n: str, x: int) -> str:
    isNegative = n[0] == '-'

    for i, c in enumerate(n):
      if not isNegative and ord(c) - ord('0') < x or isNegative and ord(c) - ord('0') > x:
        return n[:i] + str(x) + n[i:]

    return n + str(x)

```

## 1137. N-th Tribonacci Number_1137-2.py
```python
class Solution:
  def tribonacci(self, n: int) -> int:
    dp = [0, 1, 1]

    for i in range(3, n + 1):
      dp[i % 3] = sum(dp)

    return dp[n % 3]

```

## 2870. Minimum Number of Operations to Make Array Empty_2870.py
```python
class Solution:
  def minOperations(self, nums: List[int]) -> int:
    count = collections.Counter(nums)
    if 1 in count.values():
      return -1
    return sum((freq + 2) // 3 for freq in count.values())

```

## 372. Super Pow_372.py
```python
class Solution:
  def superPow(self, a: int, b: List[int]) -> int:
    kMod = 1337
    ans = 1

    for i in b:
      ans = pow(ans, 10, kMod) * pow(a, i, kMod)

    return ans % kMod

```

## 780. Reaching Points_780.py
```python
class Solution:
  def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:
    while sx < tx and sy < ty:
      tx, ty = tx % ty, ty % tx

    return sx == tx and sy <= ty and (ty - sy) % tx == 0 or \
        sy == ty and sx <= tx and (tx - sx) % ty == 0

```

## 1995. Count Special Quadruplets_1995.py
```python
class Solution:
  def countQuadruplets(self, nums: List[int]) -> int:
    n = len(nums)
    return sum(nums[a] + nums[b] + nums[c] == nums[d]
               for a in range(n)
               for b in range(a + 1, n)
               for c in range(b + 1, n)
               for d in range(c + 1, n))

```

## 1903. Largest Odd Number in String_1903.py
```python
class Solution:
  def largestOddNumber(self, num: str) -> str:
    for i, n in reversed(list(enumerate(num))):
      if int(n) % 2 == 1:
        return num[:i + 1]
    return ''

```

## 53. Maximum Subarray_53.py
```python
class Solution:
  def maxSubArray(self, nums: List[int]) -> int:
    # dp[i] := the maximum sum subarray ending in i
    dp = [0] * len(nums)

    dp[0] = nums[0]
    for i in range(1, len(nums)):
      dp[i] = max(nums[i], dp[i - 1] + nums[i])

    return max(dp)

```

## 2001. Number of Pairs of Interchangeable Rectangles_2001.py
```python
class Solution:
  def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:
    ratioCount = collections.Counter()

    for width, height in rectangles:
      ratioCount[width / height] += 1

    return sum(count * (count - 1) // 2
               for count in ratioCount.values())

```

## 2485. Find the Pivot Integer_2485.py
```python
class Solution:
  def pivotInteger(self, n: int) -> int:
    # 1 + 2 + ... + x = x + ... + n
    # (1 + x) * x // 2 = (x + n) * (n - x + 1) // 2
    #         x + x^2 = nx - x^2 + x + n^2 - nx + n
    #         2 * x^2 = n^2 + n
    #               x = sqrt((n^2 + n) // 2)
    y = (n * n + n) // 2
    x = math.isqrt(y)
    return x if x * x == y else -1

```

## 3021. Alice and Bob Playing Flower Game_3021.py
```python
class Solution:
  def flowerGame(self, n: int, m: int) -> int:
    # Alice wins if x + y is odd, occurring when:
    #   1. x is even and y is odd, or
    #   2. y is even and x is odd.
    xEven = n // 2
    yEven = m // 2
    xOdd = (n + 1) // 2
    yOdd = (m + 1) // 2
    return xEven * yOdd + yEven * xOdd

```

## 643. Maximum Average Subarray I_643.py
```python
class Solution:
  def findMaxAverage(self, nums: List[int], k: int) -> float:
    summ = sum(nums[:k])
    ans = summ

    for i in range(k, len(nums)):
      summ += nums[i] - nums[i - k]
      ans = max(ans, summ)

    return ans / k

```

## 833. Find And Replace in String_833.py
```python
class Solution:
  def findReplaceString(self, s: str, indexes: List[int],
                        sources: List[str], targets: List[str]) -> str:
    for index, source, target in sorted(zip(indexes, sources, targets), reverse=True):
      if s[index:index + len(source)] == source:
        s = s[:index] + target + s[index + len(source):]
    return s

```

## 409. Longest Palindrome_409.py
```python
class Solution:
  def longestPalindrome(self, s: str) -> int:
    ans = 0
    count = collections.Counter(s)

    for c in count.values():
      ans += c if c % 2 == 0 else c - 1

    hasOddCount = any(c % 2 == 1 for c in count.values())
    return ans + hasOddCount

```

## 949. Largest Time for Given Digits_949.py
```python
class Solution:
  def largestTimeFromDigits(self, arr: List[int]) -> str:
    for time in itertools.permutations(sorted(arr, reverse=True)):
      if time[:2] < (2, 4) and time[2] < 6:
        return '%d%d:%d%d' % time
    return ''

```

## 1447. Simplified Fractions_1447.py
```python
class Solution:
  def simplifiedFractions(self, n: int) -> List[str]:
    ans = []
    for denominator in range(2, n + 1):
      for numerator in range(1, denominator):
        if math.gcd(denominator, numerator) == 1:
          ans.append(str(numerator) + '/' + str(denominator))
    return ans

```

## 48. Rotate Image_48.py
```python
class Solution:
  def rotate(self, matrix: List[List[int]]) -> None:
    matrix.reverse()

    for i in range(len(matrix)):
      for j in range(i + 1, len(matrix)):
        matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]

```

## 1885. Count Pairs in Two Arrays_1885.py
```python
class Solution:
  def countPairs(self, nums1: List[int], nums2: List[int]) -> int:
    ans = 0
    A = sorted([x - y for x, y in zip(nums1, nums2)])

    for i, a in enumerate(A):
      index = bisect_left(A, -a + 1)
      ans += len(A) - max(i + 1, index)

    return ans

```

## 1342. Number of Steps to Reduce a Number to Zero_1342.py
```python
class Solution:
  def numberOfSteps(self, num: int) -> int:
    if num == 0:
      return 0
    subtractSteps = num.bit_count()
    divideSteps = num.bit_length() - 1
    return subtractSteps + divideSteps

```

## 3068. Find the Maximum Sum of Node Values_3068.py
```python
class Solution:
  def maximumValueSum(self, nums: List[int], k: int, edges: List[List[int]]) -> int:
    maxSum = sum(max(num, num ^ k) for num in nums)
    changedCount = sum((num ^ k) > num for num in nums)
    if changedCount % 2 == 0:
      return maxSum
    minChangeDiff = min(abs(num - (num ^ k)) for num in nums)
    return maxSum - minChangeDiff

```

## 2840. Check if Strings Can be Made Equal With Operations II_2840.py
```python
class Solution:
  def checkStrings(self, s1: str, s2: str) -> bool:
    count = [collections.Counter() for _ in range(2)]

    for i, (a, b) in enumerate(zip(s1, s2)):
      count[i % 2][a] += 1
      count[i % 2][b] -= 1

    return all(freq == 0 for freq in count[0].values()) \
        and all(freq == 0 for freq in count[1].values())

```

## 3178. Find the Child Who Has the Ball After K Seconds_3178.py
```python
class Solution:
  def numberOfChild(self, n: int, k: int) -> int:
    # the time for the ball to return to 0
    roundTime = 2 * (n - 1)
    pos = k % roundTime
    return pos if pos < n else roundTime - pos

```

## 1507. Reformat Date_1507.py
```python
class Solution:
  def reformatDate(self, date: str) -> str:
    monthToNumString = {
        'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04',
        'May': '05', 'Jun': '06', 'Jul': '07', 'Aug': '08',
        'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12',
    }
    day, month, year = date.split()
    day = day[:-2] if len(day) == 4 else '0' + day[:-2]
    return f'{year}-{monthToNumString[month]}-{day}'

```

## 775. Global and Local Inversions_775-2.py
```python
class Solution:
  def isIdealPermutation(self, nums: List[int]) -> bool:
    for i, num in enumerate(nums):
      if abs(num - i) > 1:
        return False
    return True

```

## 100. Same Tree_100.py
```python
class Solution:
  def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
    if not p or not q:
      return p == q
    return p.val == q.val and \
        self.isSameTree(p.left, q.left) and \
        self.isSameTree(p.right, q.right)

```

## 62. Unique Paths_62.py
```python
class Solution:
  def uniquePaths(self, m: int, n: int) -> int:
    # dp[i][j] := the number of unique paths from (0, 0) to (i, j)
    dp = [[1] * n for _ in range(m)]

    for i in range(1, m):
      for j in range(1, n):
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1]

    return dp[-1][-1]

```

## 242. Valid Anagram_242.py
```python
class Solution:
  def isAnagram(self, s: str, t: str) -> bool:
    if len(s) != len(t):
      return False

    count = collections.Counter(s)
    count.subtract(collections.Counter(t))
    return all(freq == 0 for freq in count.values())

```

## 888. Fair Candy Swap_888.py
```python
class Solution:
  def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:
    diff = (sum(aliceSizes) - sum(bobSizes)) // 2
    bobSizesSet = set(bobSizes)

    for aliceSize in aliceSizes:
      target = aliceSize - diff
      if target in bobSizesSet:
        return [aliceSize, target]

```

## 537. Complex Number Multiplication_537.py
```python
class Solution:
  def complexNumberMultiply(self, a: str, b: str) -> str:
    def getRealAndImag(s: str) -> tuple:
      return int(s[:s.index('+')]), int(s[s.index('+') + 1:-1])

    A, B = getRealAndImag(a)
    C, D = getRealAndImag(b)

    return str(A * C - B * D) + '+' + str(A * D + B * C) + 'i'

```

## 1362. Closest Divisors_1362.py
```python
class Solution:
  def closestDivisors(self, num: int) -> List[int]:
    for root in reversed(range(math.isqrt(num + 2) + 1)):
      for cand in [num + 1, num + 2]:
        if cand % root == 0:
          return [root, cand // root]

```

## 760. Find Anagram Mappings_760.py
```python
class Solution:
  def anagramMappings(self, nums1: List[int], nums2: List[int]) -> List[int]:
    numToIndices = collections.defaultdict(list)

    for i, num in enumerate(nums2):
      numToIndices[num].append(i)

    return [numToIndices[num].pop() for num in nums1]

```

## 766. Toeplitz Matrix_766.py
```python
class Solution:
  def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
    for i in range(len(matrix) - 1):
      for j in range(len(matrix[0]) - 1):
        if matrix[i][j] != matrix[i + 1][j + 1]:
          return False

    return True

```

## 3024. Type of Triangle II Easy_3024.py
```python
class Solution:
  def triangleType(self, nums: List[int]) -> str:
    nums.sort()
    if nums[0] + nums[1] <= nums[2]:
      return 'none'
    if nums[0] == nums[1] and nums[1] == nums[2]:
      return 'equilateral'
    if nums[0] == nums[1] or nums[1] == nums[2]:
      return 'isosceles'
    return 'scalene'

```

## 1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree_1430.py
```python
class Solution:
  def isValidSequence(self, root: Optional[TreeNode], arr: List[int]) -> bool:
    def isValidSequence(root: Optional[TreeNode], i: int) -> bool:
      if not root:
        return False
      if i == len(arr) - 1:
        return root.val == arr[i] and not root.left and not root.right
      return root.val == arr[i] and (isValidSequence(root.left, i + 1) or isValidSequence(root.right,  i + 1))

    return isValidSequence(root, 0)

```

## 1798. Maximum Number of Consecutive Values You Can Make_1798.py
```python
class Solution:
  def getMaximumConsecutive(self, coins: List[int]) -> int:
    ans = 1  # the next value we want to make

    for coin in sorted(coins):
      if coin > ans:
        return ans
      ans += coin

    return ans

```

## 2374. Node With Highest Edge Score_2374.py
```python
class Solution:
  def edgeScore(self, edges: List[int]) -> int:
    scores = [0] * len(edges)
    for i, edge in enumerate(edges):
      scores[edge] += i
    return scores.index(max(scores))

```

## 1936. Add Minimum Number of Rungs_1936.py
```python
class Solution:
  def addRungs(self, rungs: List[int], dist: int) -> int:
    ans = 0
    prev = 0

    for rung in rungs:
      ans += (rung - prev - 1) // dist
      prev = rung

    return ans

```

## 3155. Maximum Number of Upgradable Servers_3155.py
```python
class Solution:
  def maxUpgrades(self, count: List[int], upgrade: List[int], sell: List[int], money: List[int]) -> List[int]:
    # If there's enough money, upgrade all servers; otherwise, optimize by
    # upgrading x servers. We have x * upgrade <= money + (count - x) * sell.
    # Therefore, x = (money + count * sell) / (sell + upgrade).
    return [min(c, (m + c * s) // (s + u)) for c, u, s, m in zip(count, upgrade, sell, money)]

```

## 2567. Minimum Score by Changing Two Elements_2567.py
```python
class Solution:
  def minimizeSum(self, nums: List[int]) -> int:
    nums.sort()
    # Can always change the number to any other number in `nums`, so `low` becomes 0.
    # Thus, rephrase the problem as finding the minimum `high`.
    highOfChangingTwoMins = nums[-1] - nums[2]
    highOfChangingTwoMaxs = nums[-3] - nums[0]
    highOfChangingMinAndMax = nums[-2] - nums[1]
    return min(highOfChangingTwoMins, highOfChangingTwoMaxs,
               highOfChangingMinAndMax)

```

## 3147. Taking Maximum Energy From the Mystic Dungeon_3147.py
```python
class Solution:
  def maximumEnergy(self, energy: List[int], k: int) -> int:
    # dp[i] := the sum of energy starting at i
    dp = energy.copy()
    for i in range(len(energy) - 1 - k, -1, -1):
      dp[i] += dp[i + k]
    return max(dp)

```

## 1827. Minimum Operations to Make the Array Increasing_1827.py
```python
class Solution:
  def minOperations(self, nums: List[int]) -> int:
    ans = 0
    last = 0

    for num in nums:
      ans += max(0, last - num + 1)
      last = max(num, last + 1)

    return ans

```

## 2717. Semi-Ordered Permutation_2717.py
```python
class Solution:
  def semiOrderedPermutation(self, nums: List[int]) -> int:
    n = len(nums)
    index1 = nums.index(1)
    indexN = nums.index(n)
    return index1 + (n - 1 - indexN) - int(index1 > indexN)

```

## 1557. Minimum Number of Vertices to Reach All Nodes_1557.py
```python
class Solution:
  def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[int]:
    inDegrees = [0] * n

    for _, v in edges:
      inDegrees[v] += 1

    return [i for i, d in enumerate(inDegrees) if d == 0]

```

## 160. Intersection of Two Linked Lists_160.py
```python
class Solution:
  def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
    a = headA
    b = headB

    while a != b:
      a = a.next if a else headB
      b = b.next if b else headA

    return a

```

## 1566. Detect Pattern of Length M Repeated K or More Times_1566.py
```python
class Solution:
  def containsPattern(self, arr: List[int], m: int, k: int) -> bool:
    count = 0
    for i in range(m, len(arr)):
      count = count + 1 if arr[i] == arr[i - m] else 0
      if count == m * k - m:
        return True
    return False

```

## 2570. Merge Two 2D Arrays by Summing Values_2570.py
```python
class Solution:
  def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:
    count = [0] * (1001)
    self._addCount(nums1, count)
    self._addCount(nums2, count)
    return [[i, c] for i, c in enumerate(count) if c > 0]

  def _addCount(self, nums: List[List[int]], count: List[int]) -> None:
    for id_, val in nums:
      count[id_] += val

```

## 2091. Removing Minimum and Maximum From Array_2091.py
```python
class Solution:
  def minimumDeletions(self, nums: List[int]) -> int:
    n = len(nums)
    a = nums.index(min(nums))
    b = nums.index(max(nums))
    if a > b:
      a, b = b, a
    return min(a + 1 + n - b, b + 1, n - a)

```

## 973. K Closest Points to Origin_973.py
```python
class Solution:
  def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
    maxHeap = []

    for x, y in points:
      heapq.heappush(maxHeap, (- x * x - y * y, [x, y]))
      if len(maxHeap) > k:
        heapq.heappop(maxHeap)

    return [pair[1] for pair in maxHeap]

```

## 1832. Check if the Sentence Is Pangram_1832-2.py
```python
class Solution:
  def checkIfPangram(self, sentence: str) -> bool:
    seen = 0

    for c in sentence:
      seen |= 1 << ord(c) - ord('a')

    return seen == (1 << 26) - 1

```

## 1545. Find Kth Bit in Nth Binary String_1545.py
```python
class Solution:
  def findKthBit(self, n: int, k: int) -> str:
    if n == 1:
      return '0'
    midIndex = pow(2, n - 1)  # 1-indexed
    if k == midIndex:
      return '1'
    if k < midIndex:
      return self.findKthBit(n - 1, k)
    return '1' if self.findKthBit(n - 1, midIndex * 2 - k) == '0' else '0'

```

## 789. Escape The Ghosts_789.py
```python
class Solution:
  def escapeGhosts(self, ghosts: List[List[int]], target: List[int]) -> bool:
    ghostSteps = min(abs(x - target[0]) +
                     abs(y - target[1]) for x, y in ghosts)

    return abs(target[0]) + abs(target[1]) < ghostSteps

```

## 387. First Unique Character in a String_387.py
```python
class Solution:
  def firstUniqChar(self, s: str) -> int:
    count = collections.Counter(s)

    for i, c in enumerate(s):
      if count[c] == 1:
        return i

    return -1

```

## 2887. Fill Missing Data_2887.py
```python
import pandas as pd


def fillMissingValues(products: pd.DataFrame) -> pd.DataFrame:
  products['quantity'].fillna(0, inplace=True)
  return products

```

## 2427. Number of Common Factors_2427.py
```python
class Solution:
  def commonFactors(self, a: int, b: int) -> int:
    gcd = math.gcd(a, b)
    return sum(a % i == 0 and b % i == 0
               for i in range(1, gcd + 1))
  
```

## 462. Minimum Moves to Equal Array Elements II_462.py
```python
import statistics


class Solution:
  def minMoves2(self, nums: List[int]) -> int:
    median = int(statistics.median(nums))
    return sum(abs(num - median) for num in nums)

```

## 80. Remove Duplicates from Sorted Array II_80.py
```python
class Solution:
  def removeDuplicates(self, nums: List[int]) -> int:
    i = 0

    for num in nums:
      if i < 2 or num != nums[i - 2]:
        nums[i] = num
        i += 1

    return i

```

## 916. Word Subsets_916.py
```python
class Solution:
  def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:
    count = collections.Counter()

    for b in B:
      count = count | collections.Counter(b)

    return [a for a in A if collections.Counter(a) & count == count]

```

## 3047. Find the Largest Area of Square Inside Two Rectangles_3047.py
```python
class Solution:
  def largestSquareArea(self, bottomLeft: List[List[int]], topRight: List[List[int]]) -> int:
    minSide = 0

    for ((ax1, ay1), (ax2, ay2)), ((bx1, by1), (bx2, by2)) in itertools.combinations(zip(bottomLeft, topRight), 2):
      overlapX = min(ax2, bx2) - max(ax1, bx1)
      overlapY = min(ay2, by2) - max(ay1, by1)
      minSide = max(minSide, min(overlapX, overlapY))

    return minSide**2

```

## 2788. Split Strings by Separator_2788.py
```python
class Solution:
  def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:
    return [splitWord
            for word in words
            for splitWord in word.split(separator)
            if splitWord]

```

## 2640. Find the Score of All Prefixes of an Array_2640.py
```python
class Solution:
  def findPrefixScore(self, nums: List[int]) -> List[int]:
    conver = []
    mx = 0

    for num in nums:
      mx = max(mx, num)
      conver.append(num + mx)

    return itertools.accumulate(conver)

```

## 483. Smallest Good Base_483.py
```python
class Solution:
  def smallestGoodBase(self, n: str) -> str:
    n = int(n)

    for m in range(int(math.log(n, 2)), 1, -1):
      k = int(n**m**-1)
      if (k**(m + 1) - 1) // (k - 1) == n:
        return str(k)

    return str(n - 1)

```

## 214. Shortest Palindrome_214.py
```python
class Solution:
  def shortestPalindrome(self, s: str) -> str:
    t = s[::-1]

    for i in range(len(t)):
      if s.startswith(t[i:]):
        return t[:i] + s

    return t + s

```

## 876. Middle of the Linked List_876.py
```python
class Solution:
  def middleNode(self, head: ListNode) -> ListNode:
    slow = head
    fast = head

    while fast and fast.next:
      slow = slow.next
      fast = fast.next.next

    return slow

```

## 1130. Minimum Cost Tree From Leaf Values_1130-3.py
```python
class Solution:
  def mctFromLeafValues(self, arr: List[int]) -> int:
    ans = 0

    while len(arr) > 1:
      i = arr.index(min(arr))
      ans += min(arr[i - 1:i] + arr[i + 1:i + 2]) * arr.pop(i)

    return ans

```

## 660. Remove 9_660.py
```python
class Solution:
  def newInteger(self, n: int) -> int:
    ans = []
    while n:
      ans.append(str(n % 9))
      n //= 9
    return ''.join(reversed(ans))

```

## 2365. Task Scheduler II_2365.py
```python
class Solution:
  def taskSchedulerII(self, tasks: List[int], space: int) -> int:
    taskToNextAvailable = collections.defaultdict(int)
    ans = 0

    for task in tasks:
      ans = max(ans + 1, taskToNextAvailable[task])
      taskToNextAvailable[task] = ans + space + 1

    return ans

```

## 598. Range Addition II_598.py
```python
class Solution:
  def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:
    minY = m
    minX = n

    for y, x in ops:
      minY = min(minY, y)
      minX = min(minX, x)

    return minX * minY

```

## 1408. String Matching in an Array_1408.py
```python
class Solution:
  def stringMatching(self, words: List[str]) -> List[str]:
    ans = []
    for a in words:
      for b in words:
        if len(a) < len(b) and b.find(a) != -1:
          ans.append(a)
          break
    return ans

```

## 256. Paint House_256.py
```python
class Solution:
  def minCost(self, costs: List[List[int]]) -> List[List[int]]:
    for i in range(1, len(costs)):
      costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])
      costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])
      costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])

    return min(costs[-1])

```

