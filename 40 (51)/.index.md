## 324. Wiggle Sort II_324.py
```python
class Solution:
  def wiggleSort(self, nums: List[int]) -> None:
    n = len(nums)
    median = self._findKthLargest(nums, (n + 1) // 2)

    def A(i: int):
      return (1 + 2 * i) % (n | 1)

    i = 0
    j = 0
    k = n - 1

    while i <= k:
      if nums[A(i)] > median:
        nums[A(i)], nums[A(j)] = nums[A(j)], nums[A(i)]
        i, j = i + 1, j + 1
      elif nums[A(i)] < median:
        nums[A(i)], nums[A(k)] = nums[A(k)], nums[A(i)]
        k -= 1
      else:
        i += 1

  # Same as 215. Kth Largest Element in an Array
  def _findKthLargest(self, nums: List[int], k: int) -> int:
    def quickSelect(l: int, r: int, k: int) -> int:
      randIndex = random.randint(0, r - l) + l
      nums[randIndex], nums[r] = nums[r], nums[randIndex]
      pivot = nums[r]

      nextSwapped = l
      for i in range(l, r):
        if nums[i] >= pivot:
          nums[nextSwapped], nums[i] = nums[i], nums[nextSwapped]
          nextSwapped += 1
      nums[nextSwapped], nums[r] = nums[r], nums[nextSwapped]

      count = nextSwapped - l + 1  # Number of nums >= pivot
      if count == k:
        return nums[nextSwapped]
      if count > k:
        return quickSelect(l, nextSwapped - 1, k)
      return quickSelect(nextSwapped + 1, r, k - count)

    return quickSelect(0, len(nums) - 1, k)

```

## 912. Sort an Array_912.py
```python
class Solution:
  def sortArray(self, nums: List[int]) -> List[int]:
    def mergeSort(A: List[int], l: int, r: int) -> None:
      if l >= r:
        return

      def merge(A: List[int], l: int, m: int, r: int) -> None:
        sorted = [0] * (r - l + 1)
        k = 0  # sorted's index
        i = l  # left's index
        j = m + 1  # right's index

        while i <= m and j <= r:
          if A[i] < A[j]:
            sorted[k] = A[i]
            k += 1
            i += 1
          else:
            sorted[k] = A[j]
            k += 1
            j += 1

        # Put the possible remaining left part into the sorted array.
        while i <= m:
          sorted[k] = A[i]
          k += 1
          i += 1

        # Put the possible remaining right part into the sorted array.
        while j <= r:
          sorted[k] = A[j]
          k += 1
          j += 1

        A[l:l + len(sorted)] = sorted

      m = (l + r) // 2
      mergeSort(A, l, m)
      mergeSort(A, m + 1, r)
      merge(A, l, m, r)

    mergeSort(nums, 0, len(nums) - 1)
    return nums

```

## 2503. Maximum Number of Points From Grid Queries_2503.py
```python
class IndexedQuery:
  def __init__(self, queryIndex: int, query: int):
    self.queryIndex = queryIndex
    self.query = query

  def __iter__(self):
    yield self.queryIndex
    yield self.query


class Solution:
  def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])
    ans = [0] * len(queries)
    minHeap = [(grid[0][0], 0, 0)]  # (grid[i][j], i, j)
    seen = {(0, 0)}
    accumulate = 0

    for queryIndex, query in sorted([IndexedQuery(i, query)
                                     for i, query in enumerate(queries)],
                                    key=lambda iq: iq.query):
      while minHeap:
        val, i, j = heapq.heappop(minHeap)
        if val >= query:
          # The smallest neighbor is still larger than `query`, so no need to
          # keep exploring. Re-push (i, j, grid[i][j]) back to the `minHeap`.
          heapq.heappush(minHeap, (val, i, j))
          break
        accumulate += 1
        for dx, dy in dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == m or y < 0 or y == n:
            continue
          if (x, y) in seen:
            continue
          heapq.heappush(minHeap, (grid[x][y], x, y))
          seen.add((x, y))
      ans[queryIndex] = accumulate

    return ans

```

## 1948. Delete Duplicate Folders in System_1948.py
```python
class TrieNode:
  def __init__(self):
    self.children: Dict[str, TrieNode] = collections.defaultdict(TrieNode)
    self.deleted = False


class Solution:
  def deleteDuplicateFolder(self, paths: List[List[str]]) -> List[List[str]]:
    ans = []
    root = TrieNode()
    subtreeToNodes: Dict[str, List[TrieNode]] = collections.defaultdict(list)

    # Construct the Trie
    for path in sorted(paths):
      node = root
      for s in path:
        node = node.children[s]

    # For each subtree, fill in the {subtree encoding: [root]} hash table
    def buildSubtreeToRoots(node: TrieNode) -> str:
      subtree = '(' + ''.join(s + buildSubtreeToRoots(node.children[s])
                              for s in node.children) + ')'
      if subtree != '()':
        subtreeToNodes[subtree].append(node)
      return subtree

    buildSubtreeToRoots(root)

    # Mark nodes that should be deleted
    for nodes in subtreeToNodes.values():
      if len(nodes) > 1:
        for node in nodes:
          node.deleted = True

    # Construct the answer array for nodes that haven't been deleted
    def constructPath(node: TrieNode, path: List[str]) -> None:
      for s, child in node.children.items():
        if not child.deleted:
          constructPath(child, path + [s])
      if path:
        ans.append(path)

    constructPath(root, [])
    return ans

```

## 2392. Build a Matrix With Conditions_2392.py
```python
class Solution:
  def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:
    rowOrder = self._topologicalSort(rowConditions, k)
    if not rowOrder:
      return []

    colOrder = self._topologicalSort(colConditions, k)
    if not colOrder:
      return []

    ans = [[0] * k for _ in range(k)]
    nodeToRowIndex = [0] * (k + 1)

    for i, node in enumerate(rowOrder):
      nodeToRowIndex[node] = i

    for j, node in enumerate(colOrder):
      i = nodeToRowIndex[node]
      ans[i][j] = node

    return ans

  def _topologicalSort(self, conditions: List[List[int]], n: int) -> List[int]:
    order = []
    graph = [[] for _ in range(n + 1)]
    inDegrees = [0] * (n + 1)

    # Build the graph.
    for u, v in conditions:
      graph[u].append(v)
      inDegrees[v] += 1

    # Perform topological sorting.
    q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])

    while q:
      u = q.popleft()
      order.append(u)
      for v in graph[u]:
        inDegrees[v] -= 1
        if inDegrees[v] == 0:
          q.append(v)

    return order if len(order) == n else []

```

## 1409. Queries on a Permutation With Key_1409.py
```python
class FenwickTree:
  def __init__(self, n: int):
    self.sums = [0] * (n + 1)

  def add(self, i: int, delta: int) -> None:
    while i < len(self.sums):
      self.sums[i] += delta
      i += FenwickTree.lowbit(i)

  def get(self, i: int) -> int:
    summ = 0
    while i > 0:
      summ += self.sums[i]
      i -= FenwickTree.lowbit(i)
    return summ

  @staticmethod
  def lowbit(i: int) -> int:
    return i & -i


class Solution:
  def processQueries(self, queries: List[int], m: int) -> List[int]:
    ans = []
    # Map [-m, m] to [0, 2 * m].
    tree = FenwickTree(2 * m + 1)
    numToIndex = {num: num + m for num in range(1, m + 1)}

    for num in range(1, m + 1):
      tree.add(num + m, 1)

    nextEmptyIndex = m  # Map 0 to m.

    for query in queries:
      index = numToIndex[query]
      ans.append(tree.get(index - 1))
      # Move `query` from `index` to `nextEmptyIndex`.
      tree.add(index, -1)
      tree.add(nextEmptyIndex, 1)
      numToIndex[query] = nextEmptyIndex
      nextEmptyIndex -= 1

    return ans

```

## 431. Encode N-ary Tree to Binary Tree_431.py
```python
class Codec:
  # Encodes an n-ary tree to a binary tree.
  def encode(self, root: 'Node') -> Optional[TreeNode]:
    if not root:
      return None

    rootTreeNode = TreeNode(root.val)
    q = collections.deque([(root, rootTreeNode)])

    while q:
      parentNode, parentTreeNode = q.popleft()
      prevTreeNode = None
      headTreeNode = None
      for child in parentNode.children:
        currTreeNode = TreeNode(child.val)
        if prevTreeNode:
          prevTreeNode.right = currTreeNode
        else:
          headTreeNode = currTreeNode
        prevTreeNode = currTreeNode
        q.append((child, currTreeNode))
      parentTreeNode.left = headTreeNode

    return rootTreeNode

  # Decodes your binary tree to an n-ary tree.
  def decode(self, root: Optional[TreeNode]) -> 'Node':
    if not root:
      return None

    rootNode = Node(root.val, [])
    q = collections.deque([(rootNode, root)])

    while q:
      parentNode, parentTreeNode = q.popleft()
      sibling = parentTreeNode.left
      while sibling:
        currNode = Node(sibling.val, [])
        parentNode.children.append(currNode)
        q.append((currNode, sibling))
        sibling = sibling.right

    return rootNode

```

## 3023. Find Pattern in Infinite Stream I_3023.py
```python
# Definition for an infinite stream.
# class InfiniteStream:
#   def next(self) -> int:
#     pass

class Solution:
  def findPattern(self, stream: Optional['InfiniteStream'], pattern: List[int]) -> int:
    lps = self._getLPS(pattern)
    i = 0  # stream's index
    j = 0  # pattern's index
    bit = 0  # the bit in the stream
    readNext = False
    while True:
      if not readNext:
        bit = stream.next()
        readNext = True
      if bit == pattern[j]:
        i += 1
        readNext = False
        j += 1
        if j == len(pattern):
          return i - j
      # Mismatch after j matches.
      elif j > 0:
        # Don't match lps[0..lps[j - 1]] since they will match anyway.
        j = lps[j - 1]
      else:
        i += 1
        readNext = False

  def _getLPS(self, pattern: List[int]) -> List[int]:
    """
    Returns the lps array, where lps[i] is the length of the longest prefix of
    pattern[0..i] which is also a suffix of this substring.
    """
    lps = [0] * len(pattern)
    j = 0
    for i in range(1, len(pattern)):
      while j > 0 and pattern[j] != pattern[i]:
        j = lps[j - 1]
      if pattern[i] == pattern[j]:
        j += 1
        lps[i] = j
    return lps

```

## 1214. Two Sum BSTs_1214.py
```python
class BSTIterator:
  def __init__(self, root: Optional[TreeNode], leftToRight: bool):
    self.stack = []
    self.leftToRight = leftToRight
    self._pushUntilNone(root)

  def hasNext(self) -> bool:
    return len(self.stack) > 0

  def next(self) -> int:
    node = self.stack.pop()
    if self.leftToRight:
      self._pushUntilNone(node.right)
    else:
      self._pushUntilNone(node.left)
    return node.val

  def _pushUntilNone(self, root: Optional[TreeNode]):
    while root:
      self.stack.append(root)
      root = root.left if self.leftToRight else root.right


class Solution:
  def twoSumBSTs(self, root1: Optional[TreeNode], root2: Optional[TreeNode], target: int) -> bool:
    bst1 = BSTIterator(root1, True)
    bst2 = BSTIterator(root2, False)

    l = bst1.next()
    r = bst2.next()
    while True:
      summ = l + r
      if summ == target:
        return True
      if summ < target:
        if not bst1.hasNext():
          return False
        l = bst1.next()
      else:
        if not bst2.hasNext():
          return False
        r = bst2.next()

```

## 1202. Smallest String With Swaps_1202.py
```python
class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
    ans = ''
    uf = UnionFind(len(s))
    map = collections.defaultdict(list)

    for a, b in pairs:
      uf.unionByRank(a, b)

    for i, c in enumerate(s):
      map[uf.find(i)].append(c)

    for key in map.keys():
      map[key].sort(reverse=True)

    for i in range(len(s)):
      ans += map[uf.find(i)].pop()

    return ans

```

## 656. Coin Path_656.py
```python
class Solution:
  def cheapestJump(self, coins: List[int], maxJump: int) -> List[int]:
    if coins[-1] == -1:
      return []

    n = len(coins)
    # dp[i] := the minimum cost to jump from i to n - 1
    dp = [math.inf] * n
    next = [-1] * n

    def cheapestJump(i: int) -> int:
      if i == len(coins) - 1:
        dp[i] = coins[i]
        return dp[i]
      if dp[i] < math.inf:
        return dp[i]
      if coins[i] == -1:
        return math.inf

      for j in range(i + 1, min(i + maxJump + 1, n)):
        res = cheapestJump(j)
        if res == math.inf:
          continue
        cost = coins[i] + res
        if cost < dp[i]:
          dp[i] = cost
          next[i] = j

      return dp[i]

    cheapestJump(0)
    if dp[0] == math.inf:
      return []
    return self._constructPath(next, 0)

  def _constructPath(self, next: List[int], i: int) -> List[int]:
    ans = []
    while i != -1:
      ans.append(i + 1)  # 1-indexed
      i = next[i]
    return ans

```

## 1634. Add Two Polynomials Represented as Linked Lists_1634.py
```python
# Definition for polynomial singly-linked list.
# class PolyNode:
#   def __init__(self, x=0, y=0, next=None):
#     self.coefficient = x
#     self.power = y
#     self.next = next

class Solution:
  def addPoly(self, poly1: 'PolyNode', poly2: 'PolyNode') -> 'PolyNode':
    dummy = PolyNode()
    curr = dummy
    p = poly1  # poly1's pointer
    q = poly2  # poly2's pointer

    while p and q:
      if p.power > q.power:
        curr.next = PolyNode(p.coefficient, p.power)
        curr = curr.next
        p = p.next
      elif p.power < q.power:
        curr.next = PolyNode(q.coefficient, q.power)
        curr = curr.next
        q = q.next
      else:  # p.power == q.power
        sumCoefficient = p.coefficient + q.coefficient
        if sumCoefficient != 0:
          curr.next = PolyNode(sumCoefficient, p.power)
          curr = curr.next
        p = p.next
        q = q.next

    while p:
      curr.next = PolyNode(p.coefficient, p.power)
      curr = curr.next
      p = p.next

    while q:
      curr.next = PolyNode(q.coefficient, q.power)
      curr = curr.next
      q = q.next

    return dummy.next

```

## 2074. Reverse Nodes in Even Length Groups_2074.py
```python
class Solution:
  def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:
    # prev -> (head -> ... -> tail) -> next -> ...
    dummy = ListNode(0, head)
    prev = dummy
    tail = head
    next = head.next
    groupLength = 1

    def getTailAndLength(head: Optional[ListNode], groupLength: int) -> Tuple[Optional[ListNode], int]:
      length = 1
      tail = head
      while length < groupLength and tail.next:
        tail = tail.next
        length += 1
      return tail, length

    def reverse(head: Optional[ListNode]) -> Optional[ListNode]:
      prev = None
      while head:
        next = head.next
        head.next = prev
        prev = head
        head = next
      return prev

    while True:
      if groupLength % 2 == 1:
        prev.next = head
        prev = tail
      else:
        tail.next = None
        prev.next = reverse(head)
        # Prev -> (tail -> ... -> head) -> next -> ...
        head.next = next
        prev = head
      if not next:
        break
      head = next
      tail, length = getTailAndLength(head, groupLength + 1)
      next = tail.next
      groupLength = length

    return dummy.next

```

## 936. Stamping The Sequence_936.py
```python
class Solution:
  def movesToStamp(self, stamp: str, target: str) -> List[int]:
    def stampify(s: int) -> int:
      """
      Stamps target[i..i + |stamp|) and returns the number of newly stamped
      characters.
      e.g. stampify("abc", "ababc", 2) returns 3 because target becomes "ab***".
      """
      stampified = len(stamp)

      for i, st in enumerate(stamp):
        if target[s + i] == '*':  # It's already been stamped.
          stampified -= 1
        elif target[s + i] != st:  # We can't stamp on the index i.
          return 0

      for i in range(s, s + len(stamp)):
        target[i] = '*'

      return stampified

    ans = []
    target = list(target)
    # stamped[i] := True if we already stamped target by stamping on index i
    stamped = [False] * len(target)
    stampedCount = 0  # Our goal is to make stampedCount = |target|.

    while stampedCount < len(target):
      isStamped = False
      # Try to stamp target[i..i + |stamp|) for each index.
      for i in range(len(target) - len(stamp) + 1):
        if stamped[i]:
          continue
        stampified = stampify(i)
        if stampified == 0:
          continue
        stampedCount += stampified
        isStamped = True
        stamped[i] = True
        ans.append(i)
      # After trying to stamp on each index, we can't find a valid stamp.
      if not isStamped:
        return []

    return ans[::-1]

```

## 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix_1284.py
```python
class Solution:
  def minFlips(self, mat: List[List[int]]) -> int:
    m = len(mat)
    n = len(mat[0])
    hash = self._getHash(mat, m, n)
    if hash == 0:
      return 0

    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    step = 0
    q = collections.deque([hash])
    seen = {hash}

    while q:
      step += 1
      for _ in range(len(q)):
        curr = q.popleft()
        for i in range(m):
          for j in range(n):
            next = curr ^ 1 << (i * n + j)
            # Flie the four neighbors.
            for dx, dy in dirs:
              x = i + dx
              y = j + dy
              if x < 0 or x == m or y < 0 or y == n:
                continue
              next ^= 1 << (x * n + y)
            if next == 0:
              return step
            if next in seen:
              continue
            q.append(next)
            seen.add(next)

    return -1

  def _getHash(self, mat: List[List[int]], m: int, n: int) -> int:
    hash = 0
    for i in range(m):
      for j in range(n):
        if mat[i][j]:
          hash |= 1 << (i * n + j)
    return hash

```

## 2003. Smallest Missing Genetic Value in Each Subtree_2003.py
```python
class Solution:
  def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:
    n = len(parents)
    ans = [1] * n
    tree = [[] for _ in range(n)]
    seen = set()
    minMiss = 1

    for i in range(1, n):
      tree[parents[i]].append(i)

    def getNode(nums: List[int]) -> int:
      for i, num in enumerate(nums):
        if num == 1:
          return i
      return -1

    nodeThatsOne = getNode(nums)
    if nodeThatsOne == -1:
      return ans

    u = nodeThatsOne
    prev = -1  # the u that just handled

    def dfs(u: int) -> None:
      seen.add(nums[u])
      for v in tree[u]:
        dfs(v)

    # Upward from `nodeThatsOne` to the root `u`.
    while u != -1:
      for v in tree[u]:
        if v == prev:
          continue
        dfs(v)
      seen.add(nums[u])
      while minMiss in seen:
        minMiss += 1
      ans[u] = minMiss
      prev = u
      u = parents[u]

    return ans

```

## 267. Palindrome Permutation II_267.py
```python
class Solution:
  def generatePalindromes(self, s: str) -> List[str]:
    count = collections.Counter(s)

    # Count odd ones.
    odd = sum(value & 1 for value in count.values())

    # Can't form any palindrome.
    if odd > 1:
      return []

    ans = []
    candidates = []
    mid = ''

    # Get the mid and the candidates characters.
    for key, value in count.items():
      if value % 2 == 1:
        mid += key
      for _ in range(value // 2):
        candidates.append(key)

    def dfs(used: List[bool], path: List[chr]) -> None:
      """Generates all the unique palindromes from the candidates."""
      if len(path) == len(candidates):
        ans.append(''.join(path) + mid + ''.join(reversed(path)))
        return

      for i, candidate in enumerate(candidates):
        if used[i]:
          continue
        if i > 0 and candidate == candidates[i - 1] and not used[i - 1]:
          continue
        used[i] = True
        path.append(candidate)
        dfs(used, path)
        path.pop()
        used[i] = False

    # Backtrack to generate the ans strings.
    dfs([False] * len(candidates), [])
    return ans

```

## 2071. Maximum Number of Tasks You Can Assign_2071.py
```python
from sortedcontainers import SortedList


class Solution:
  def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:
    tasks.sort()
    workers.sort()

    def canComplete(k: int, pillsLeft: int) -> bool:
      """Returns True if we can finish k tasks."""
      # k strongest workers
      sortedWorkers = SortedList(workers[-k:])

      # Out of the k smallest tasks, start from the biggest one.
      for i in reversed(range(k)):
        # Find the first worker that has strength >= tasks[i].
        index = sortedWorkers.bisect_left(tasks[i])
        if index < len(sortedWorkers):
          sortedWorkers.pop(index)
        elif pillsLeft > 0:
          # Find the first worker that has strength >= tasks[i] - strength.
          index = sortedWorkers.bisect_left(tasks[i] - strength)
          if index < len(sortedWorkers):
            sortedWorkers.pop(index)
            pillsLeft -= 1
          else:
            return False
        else:
          return False

      return True

    ans = 0
    l = 0
    r = min(len(tasks), len(workers))

    while l <= r:
      m = (l + r) // 2
      if canComplete(m, pills):
        ans = m
        l = m + 1
      else:
        r = m - 1

    return ans

```

## 927. Three Equal Parts_927.py
```python
class Solution:
  def threeEqualParts(self, arr: List[int]) -> List[int]:
    ones = sum(a == 1 for a in arr)

    if ones == 0:
      return [0, len(arr) - 1]
    if ones % 3 != 0:
      return [-1, -1]

    k = ones // 3
    i = 0

    for i in range(len(arr)):
      if arr[i] == 1:
        first = i
        break

    gapOnes = k

    for j in range(i + 1, len(arr)):
      if arr[j] == 1:
        gapOnes -= 1
        if gapOnes == 0:
          second = j
          break

    gapOnes = k

    for i in range(j + 1, len(arr)):
      if arr[i] == 1:
        gapOnes -= 1
        if gapOnes == 0:
          third = i
          break

    while third < len(arr) and arr[first] == arr[second] == arr[third]:
      first += 1
      second += 1
      third += 1

    if third == len(arr):
      return [first - 1, second]
    return [-1, -1]

```

## 3086. Minimum Moves to Pick K Ones_3086.py
```python
class Solution:
  def minimumMoves(self, nums: List[int], k: int, maxChanges: int) -> int:
    # Dylan has two actions for collecting '1's in a sequence:
    # Action 1: Put a '1' next to him and pick it up.
    #           The cost is 2.
    # Action 2: Swap a '1' towards him and collect it.
    #           The cost equals the distance to the '1'.
    #
    # To minimize the swapping cost, Dylan can use a sliding window strategy,
    # selecting the optimal position (middle '1' in the window) for efficient
    # collection. The window's size is crucial:

    # The minimum window size: min(0, k - maxChanges), ensuring the window
    # isn't too small.
    # The maximum window size: min(k, minOnesByTwo + 3, the number of ones),
    # preventing overly ambitious swaps.
    #
    # Note that if needing to move a '1' beyond `minOnesByTwo + 3`, it's
    # cheaper to use Action 1.

    # At most three indices, (dylanIndex - 1, dylanIndex, dylanIndex + 1), have
    # a distance <= 1 from dylanIndex, implying that we'll be taking at most
    # `maxOnesByTwo + 3` using Action 2. Any more Action 2 is not optimal and
    # should be replaced with Action 1.
    kNumOfIndicesWithinOneDistance = 3
    ans = math.inf
    oneIndices = [i for i, num in enumerate(nums) if num == 1]
    prefix = list(itertools.accumulate(oneIndices, initial=0))

    minOnesByTwo = max(0, k - maxChanges)
    maxOnesByTwo = min(
        k, minOnesByTwo + kNumOfIndicesWithinOneDistance, len(oneIndices))

    for onesByTwo in range(minOnesByTwo, maxOnesByTwo + 1):
      for l in range(len(prefix) - onesByTwo):
        r = l + onesByTwo  # Collect 1s in oneIndices[l - 1..r - 1].
        cost1 = (k - onesByTwo) * 2
        cost2 = (prefix[r] - prefix[(l + r) // 2]) - \
            (prefix[(l + r + 1) // 2] - prefix[l])
        ans = min(ans, cost1 + cost2)

    return ans

```

## 2867. Count Valid Paths in a Tree_2867.py
```python
class Solution:
  def countPaths(self, n: int, edges: List[List[int]]) -> int:
    ans = 0
    isPrime = self._sieveEratosthenes(n + 1)
    graph = [[] for _ in range(n + 1)]

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    def dfs(u: int, prev: int) -> Tuple[int, int]:
      nonlocal ans
      countZeroPrimePath = int(not isPrime[u])
      countOnePrimePath = int(isPrime[u])

      for v in graph[u]:
        if v == prev:
          continue
        countZeroPrimeChildPath, countOnePrimeChildPath = dfs(v, u)
        ans += countZeroPrimePath * countOnePrimeChildPath + \
            countOnePrimePath * countZeroPrimeChildPath
        if isPrime[u]:
          countOnePrimePath += countZeroPrimeChildPath
        else:
          countZeroPrimePath += countZeroPrimeChildPath
          countOnePrimePath += countOnePrimeChildPath

      return countZeroPrimePath, countOnePrimePath

    dfs(1, -1)
    return ans

  def _sieveEratosthenes(self, n: int) -> List[bool]:
    isPrime = [True] * n
    isPrime[0] = False
    isPrime[1] = False
    for i in range(2, int(n**0.5) + 1):
      if isPrime[i]:
        for j in range(i * i, n, i):
          isPrime[j] = False
    return isPrime

```

## 348. Design Tic-Tac-Toe_348.py
```python
class TicTacToe:
  def __init__(self, n: int):
    self.n = n
    # Record count('X') - count('O').
    self.rows = [0] * n
    self.cols = [0] * n
    self.diag = 0
    self.antiDiag = 0

  """ Player {player} makes a move at ({row}, {col}).

      @param row    The row of the board.
      @param col    The column of the board.
      @param player The player, can be either 1 or 2.
      @return The current winning condition, can be either:
              0: No one wins.
              1: Player 1 wins.
              2: Player 2 wins.
  """

  def move(self, row: int, col: int, player: int) -> int:
    toAdd = 1 if player == 1 else -1
    target = self.n if player == 1 else -self.n

    if row == col:
      self.diag += toAdd
      if self.diag == target:
        return player

    if row + col == self.n - 1:
      self.antiDiag += toAdd
      if self.antiDiag == target:
        return player

    self.rows[row] += toAdd
    if self.rows[row] == target:
      return player

    self.cols[col] += toAdd
    if self.cols[col] == target:
      return player

    return 0

```

## 308. Range Sum Query 2D - Mutable_308.py
```python
class FenwickTree:
  def __init__(self, m: int, n: int):
    self.sums = [[0] * (n + 1) for _ in range(m + 1)]

  def add(self, row: int, col: int, delta: int) -> None:
    i = row
    while i < len(self.sums):
      j = col
      while j < len(self.sums[0]):
        self.sums[i][j] += delta
        j += FenwickTree.lowbit(j)
      i += FenwickTree.lowbit(i)

  def get(self, row: int, col: int) -> int:
    summ = 0
    i = row
    while i > 0:
      j = col
      while j > 0:
        summ += self.sums[i][j]
        j -= FenwickTree.lowbit(j)
      i -= FenwickTree.lowbit(i)
    return summ

  @staticmethod
  def lowbit(i: int) -> int:
    return i & -i


class NumMatrix:
  def __init__(self, matrix: List[List[int]]):
    self.matrix = matrix
    self.tree = FenwickTree(len(matrix), len(matrix[0]))

    for i in range(len(matrix)):
      for j, val in enumerate(matrix[i]):
        self.tree.add(i + 1, j + 1, val)

  def update(self, row: int, col: int, val: int) -> None:
    self.tree.add(row + 1, col + 1, val - self.matrix[row][col])
    self.matrix[row][col] = val

  def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
    return self.tree.get(row2 + 1, col2 + 1) - self.tree.get(row1, col2 + 1) - \
        self.tree.get(row2 + 1, col1) + self.tree.get(row1, col1)

```

## 2152. Minimum Number of Lines to Cover Points_2152.py
```python
class Solution:
  def minimumLines(self, points: List[List[int]]) -> int:
    n = len(points)
    allCovered = (1 << n) - 1
    maxLines = n // 2 + (n & 1)

    def getSlope(p: List[int], q: List[int]) -> Tuple[int, int]:
      dx = p[0] - q[0]
      dy = p[1] - q[1]
      if dx == 0:
        return (0, p[0])
      if dy == 0:
        return (p[1], 0)
      d = gcd(dx, dy)
      x = dx // d
      y = dy // d
      return (x, y) if x > 0 else (-x, -y)

    @functools.lru_cache(None)
    def dfs(covered: int) -> int:
      if covered == allCovered:
        return 0

      ans = maxLines

      for i in range(n):
        if covered >> i & 1:
          continue
        for j in range(n):
          if i == j:
            continue
          # Connect the points[i] with the points[j].
          newCovered = covered | 1 << i | 1 << j
          slope = getSlope(points[i], points[j])
          # Mark the points covered by this line.
          for k in range(n):
            if getSlope(points[i], points[k]) == slope:
              newCovered |= 1 << k
          ans = min(ans, 1 + dfs(newCovered))

      return ans

    return dfs(0)

```

## 2056. Number of Valid Move Combinations On Chessboard_2056.py
```python
class Solution:
  def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:
    n = len(pieces)
    moves = {"rook": [(1, 0), (-1, 0), (0, 1), (0, -1)],
             "bishop": [(1, 1), (1, -1), (-1, 1), (-1, -1)],
             "queen": [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]}
    hashedBoards = set()

    def getHash(board: List[List[int]]) -> Tuple:
      return tuple([tuple(pos) for pos in board])

    def dfs(board: List[List[int]], pieceMoves: List[Tuple[int, int]], activeMask: int) -> None:
      """Performs a depth-first search to explore all possible board states."""
      if activeMask == 0:
        return
      hashedBoards.add(getHash(board))

      for nextActiveMask in range(1, 1 << n):
        if activeMask & nextActiveMask != nextActiveMask:
          continue

        # Copy the board.
        nextBoard = [pos.copy() for pos in board]

        # Move the pieces that are active in this turn.
        for i in range(n):
          if nextActiveMask >> i & 1:
            nextBoard[i][0] += pieceMoves[i][0]
            nextBoard[i][1] += pieceMoves[i][1]

        # No two or more pieces occupy the same square.
        if len(set(getHash(nextBoard))) < n:
          continue

        # Every piece needs to be in the boundary.
        if all(1 <= x <= 8 and 1 <= y <= 8 for x, y in nextBoard):
          dfs(nextBoard, pieceMoves, nextActiveMask)

    for pieceMoves in itertools.product(*(moves[piece] for piece in pieces)):
      dfs(positions, pieceMoves, (1 << n) - 1)

    return len(hashedBoards)

```

## 1568. Minimum Number of Days to Disconnect Island_1568.py
```python
class Solution:
  def minDays(self, grid: List[List[int]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])

    def dfs(grid: List[List[int]], i: int, j: int, seen: Set[Tuple[int, int]]):
      seen.add((i, j))
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        if grid[x][y] == 0 or (x, y) in seen:
          continue
        dfs(grid, x, y, seen)

    def disconnected(grid: List[List[int]]) -> bool:
      islandsCount = 0
      seen = set()
      for i in range(m):
        for j in range(n):
          if grid[i][j] == 0 or (i, j) in seen:
            continue
          if islandsCount > 1:
            return True
          islandsCount += 1
          dfs(grid, i, j, seen)
      return islandsCount != 1

    if disconnected(grid):
      return 0

    # Try to remove 1 land.
    for i in range(m):
      for j in range(n):
        if grid[i][j] == 1:
          grid[i][j] = 0
          if disconnected(grid):
            return 1
          grid[i][j] = 1

    # Remove 2 lands.
    return 2

```

## 2322. Minimum Score After Removals on a Tree_2322.py
```python
class Solution:
  def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:
    n = len(nums)
    xors = functools.reduce(operator.xor, nums)
    subXors = nums[:]
    tree = [[] for _ in range(n)]
    children = [{i} for i in range(n)]

    for u, v in edges:
      tree[u].append(v)
      tree[v].append(u)

    def dfs(u: int, parent: int) -> Tuple[int, Set[int]]:
      for v in tree[u]:
        if v == parent:
          continue
        vXor, vChildren = dfs(v, u)
        subXors[u] ^= vXor
        children[u] |= vChildren
      return subXors[u], children[u]

    dfs(0, -1)

    ans = math.inf
    for i in range(len(edges)):
      a, b = edges[i]
      if b in children[a]:
        a, b = b, a
      for j in range(i):
        c, d = edges[j]
        if d in children[c]:
          c, d = d, c

        if c in children[a] and a != c:
          cands = [subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]]
        elif a in children[c] and a != c:
          cands = [subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]]
        else:
          cands = [subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]]
        ans = min(ans, max(cands) - min(cands))

    return ans

```

## 952. Largest Component Size by Common Factor_952.py
```python
class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def largestComponentSize(self, nums: List[int]) -> int:
    ans = 0
    uf = UnionFind(max(nums) + 1)
    count = collections.Counter()

    for num in nums:
      for x in range(2, math.isqrt(num) + 1):
        if num % x == 0:
          uf.unionByRank(num, x)
          uf.unionByRank(num, num // x)

    for num in nums:
      numRoot = uf.find(num)
      count[numRoot] += 1
      ans = max(ans, count[numRoot])

    return ans

```

## 1977. Number of Ways to Separate Numbers_1977.py
```python
class Solution:
  def numberOfCombinations(self, num: str) -> int:
    if num[0] == '0':
      return 0

    kMod = 1_000_000_007
    n = len(num)
    # dp[i][k] := the number of possible lists of integers ending in num[i]
    # with the length of the last number being 1..k
    dp = [[0] * (n + 1) for _ in range(n)]
    # lcs[i][j] := the number of the same digits in num[i..n) and num[j..n)
    lcs = [[0] * (n + 1) for _ in range(n + 1)]

    for i in range(n - 1, -1, -1):
      for j in range(i + 1, n):
        if num[i] == num[j]:
          lcs[i][j] = lcs[i + 1][j + 1] + 1

    for i in range(n):
      for k in range(1, i + 2):
        dp[i][k] += dp[i][k - 1]
        dp[i][k] %= kMod
        # The last number is num[s..i].
        s = i - k + 1
        if num[s] == '0':
          # the number of possible lists of integers ending in num[i] with the
          # length of the last number being k
          continue
        if s == 0:  # the whole string
          dp[i][k] += 1
          continue
        if s < k:
          # The length k is not enough, so add the number of possible lists of
          # integers in num[0..s - 1].
          dp[i][k] += dp[s - 1][s]
          continue
        l = lcs[s - k][s]
        if l >= k or num[s - k + l] <= num[s + l]:
          # Have enough length k and num[s - k..s - 1] <= num[j..i].
          dp[i][k] += dp[s - 1][k]
        else:
          # Have enough length k but num[s - k..s - 1] > num[j..i].
          dp[i][k] += dp[s - 1][k - 1]

    return dp[n - 1][n] % kMod

```

## 3109. Find the Index of Permutation_3109.py
```python
class FenwickTree:
  def __init__(self, n: int):
    self.sums = [0] * (n + 1)

  def add(self, i: int, delta: int) -> None:
    while i < len(self.sums):
      self.sums[i] += delta
      i += FenwickTree.lowbit(i)

  def get(self, i: int) -> int:
    summ = 0
    while i > 0:
      summ += self.sums[i]
      i -= FenwickTree.lowbit(i)
    return summ

  @staticmethod
  def lowbit(i: int) -> int:
    return i & -i


class Solution:
  def getPermutationIndex(self, perm: List[int]) -> int:
    kMod = 1_000_000_007
    n = len(perm)
    ans = 0
    tree = FenwickTree(n)
    fact = [1] * (n + 1)  # fact[i] := i!

    for i in range(2, n + 1):
      fact[i] = (fact[i - 1] * i) % kMod

    for i, num in enumerate(perm):
      # the number of unused numbers less than `num`
      unusedNums = num - 1 - tree.get(num - 1)
      suffixLength = fact[n - 1 - i]
      ans += unusedNums * suffixLength
      ans %= kMod
      tree.add(num, 1)

    return ans

```

## 1135. Connecting Cities With Minimum Cost_1135.py
```python
class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def minimumCost(self, n: int, connections: List[List[int]]) -> int:
    ans = 0
    uf = UnionFind(n + 1)

    # Sort by cost.
    connections.sort(key=lambda x: x[2])

    for u, v, cost in connections:
      if uf.find(u) == uf.find(v):
        continue
      uf.unionByRank(u, v)
      ans += cost

    root = uf.find(1)
    if any(uf.find(i) != root for i in range(1, n + 1)):
      return -1

    return ans

```

## 352. Data Stream as Disjoint Intervals_352.py
```python
from sortedcontainers import SortedDict


class SummaryRanges:
  def __init__(self):
    self.intervals = SortedDict()  # {start: (start, end)}

  def addNum(self, val: int) -> None:
    if val in self.intervals:
      return

    lo = self._lowerKey(val)
    hi = self._higherKey(val)

    # {lo, map[lo][1]} + val + {hi, map[hi][1]} = {lo, map[hi][1]}
    if lo >= 0 and hi >= 0 and self.intervals[lo][1] + 1 == val and val + 1 == hi:
      self.intervals[lo][1] = self.intervals[hi][1]
      del self.intervals[hi]
      # {lo, map[lo][1]} + val = {lo, val}
      # Prevent adding duplicate entry by using '>=' instead of '=='.
    elif lo >= 0 and self.intervals[lo][1] + 1 >= val:
      self.intervals[lo][1] = max(self.intervals[lo][1], val)
    elif hi >= 0 and val + 1 == hi:
      # val + {hi, map[hi][1]} = {val, map[hi][1]}
      self.intervals[val] = [val, self.intervals[hi][1]]
      del self.intervals[hi]
    else:
      self.intervals[val] = [val, val]

  def getIntervals(self) -> List[List[int]]:
    return list(self.intervals.values())

  def _lowerKey(self, key: int):
    """Returns the maximum key in `self.intervals` < `key`."""
    i = self.intervals.bisect_left(key)
    if i == 0:
      return -1
    return self.intervals.peekitem(i - 1)[0]

  def _higherKey(self, key: int):
    """Returns the minimum key in `self.intervals` < `key`."""
    i = self.intervals.bisect_right(key)
    if i == len(self.intervals):
      return -1
    return self.intervals.peekitem(i)[0]

```

## 1735. Count Ways to Make Array With Product_1735.py
```python
class Solution:
  def waysToFillArray(self, queries: List[List[int]]) -> List[int]:
    kMod = 1_000_000_007
    kMax = 10_000
    minPrimeFactors = self._sieveEratosthenes(kMax + 1)

    @functools.lru_cache(None)
    def fact(i: int) -> int:
      return 1 if i <= 1 else i * fact(i - 1) % kMod

    @functools.lru_cache(None)
    def inv(i: int) -> int:
      return pow(i, kMod - 2, kMod)

    @functools.lru_cache(None)
    def nCk(n: int, k: int) -> int:
      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % kMod

    ans = []

    for n, k in queries:
      res = 1
      for freq in self._getPrimeFactorsCount(k, minPrimeFactors).values():
        res = res * nCk(n - 1 + freq, freq) % kMod
      ans.append(res)

    return ans

  def _sieveEratosthenes(self, n: int) -> List[int]:
    """Gets the minimum prime factor of i, where 1 < i <= n."""
    minPrimeFactors = [i for i in range(n + 1)]
    for i in range(2, int(n**0.5) + 1):
      if minPrimeFactors[i] == i:  # `i` is prime.
        for j in range(i * i, n, i):
          minPrimeFactors[j] = min(minPrimeFactors[j], i)
    return minPrimeFactors

  def _getPrimeFactorsCount(self, num: int, minPrimeFactors: List[int]) -> Dict[int, int]:
    count = collections.Counter()
    while num > 1:
      divisor = minPrimeFactors[num]
      while num % divisor == 0:
        num //= divisor
        count[divisor] += 1
    return count

```

## 2179. Count Good Triplets in an Array_2179.py
```python
class FenwickTree:
  def __init__(self, n: int):
    self.sums = [0] * (n + 1)

  def add(self, i: int, delta: int) -> None:
    while i < len(self.sums):
      self.sums[i] += delta
      i += FenwickTree.lowbit(i)

  def get(self, i: int) -> int:
    summ = 0
    while i > 0:
      summ += self.sums[i]
      i -= FenwickTree.lowbit(i)
    return summ

  @staticmethod
  def lowbit(i: int) -> int:
    return i & -i


class Solution:
  def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:
    n = len(nums1)
    numToIndex = {num: i for i, num in enumerate(nums1)}
    # Remap each number in `nums2` to the according index in `nums1` as `A`.
    # Rephrase the problem as finding the number of increasing tripets in `A`.
    A = [numToIndex[num] for num in nums2]
    # leftSmaller[i] := the number of A[j] < A[i], where 0 <= j < i
    leftSmaller = [0] * n
    # rightLarger[i] := the number of A[j] > A[i], where i < j < n
    rightLarger = [0] * n
    tree1 = FenwickTree(n)  # Calculates `leftSmaller`.
    tree2 = FenwickTree(n)  # Calculates `rightLarger`.

    for i, a in enumerate(A):
      leftSmaller[i] = tree1.get(a)
      tree1.add(a + 1, 1)

    for i, a in reversed(list(enumerate(A))):
      rightLarger[i] = tree2.get(n) - tree2.get(a)
      tree2.add(a + 1, 1)

    return sum(a * b for a, b in zip(leftSmaller, rightLarger))

```

## 3213. Construct String with Minimum Cost_3213.py
```python
class TrieNode:
  def __init__(self):
    self.children: Dict[str, TrieNode] = {}
    self.cost = math.inf


class Trie:
  def __init__(self):
    self.root = TrieNode()

  def insert(self, word: str, cost: int) -> None:
    """Inserts a word with a cost."""
    node: TrieNode = self.root
    for c in word:
      node = node.children.setdefault(c, TrieNode())
    node.cost = min(node.cost, cost)

  @functools.lru_cache(None)
  def search(self, word: str, i: int) -> int:
    """Returns the minimum cost to construct s[i:]."""
    if i == len(word):
      return 0
    cost = math.inf
    node = self.root
    for i in range(i, len(word)):
      if word[i] not in node.children:
        break
      node = node.children[word[i]]
      if node.cost != math.inf:
        childCost = self.search(word, i + 1)
        if childCost != math.inf:
          cost = min(cost, node.cost + childCost)
    return cost


class Solution:
  def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:
    trie = Trie()

    for word, cost in zip(words, costs):
      trie.insert(word, cost)

    ans = trie.search(target, 0)
    return -1 if ans == math.inf else ans

```

## 3102. Minimize Manhattan Distances_3102.py
```python
class Solution:
  def minimumDistance(self, points: List[List[int]]) -> int:
    i, j = self._maxManhattanDistance(points, -1)
    xi, yi = self._maxManhattanDistance(points, i)
    xj, yj = self._maxManhattanDistance(points, j)
    return min(self._manhattan(points, xi, yi),
               self._manhattan(points, xj, yj))

  def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:
    minSum = math.inf
    maxSum = -math.inf
    minDiff = math.inf
    maxDiff = -math.inf
    minSumIndex = -1
    maxSumIndex = -1
    minDiffIndex = -1
    maxDiffIndex = -1

    for i, (x, y) in enumerate(points):
      if i == excludedIndex:
        continue
      summ = x + y
      diff = x - y
      if summ < minSum:
        minSum = summ
        minSumIndex = i
      if summ > maxSum:
        maxSum = summ
        maxSumIndex = i
      if diff < minDiff:
        minDiff = diff
        minDiffIndex = i
      if diff > maxDiff:
        maxDiff = diff
        maxDiffIndex = i

    return [minSumIndex, maxSumIndex] if maxSum - minSum >= maxDiff - minDiff \
        else [minDiffIndex, maxDiffIndex]

  def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:
    return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])

```

## 2227. Encrypt and Decrypt Strings_2227.py
```python
class TrieNode:
  def __init__(self):
    self.children: Dict[str, TrieNode] = collections.defaultdict(TrieNode)
    self.isWord = False


class Encrypter:
  def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):
    self.keyToValue = {k: v for k, v in zip(keys, values)}
    self.valueToKeys = collections.defaultdict(list)
    self.root = TrieNode()
    for k, v in zip(keys, values):
      self.valueToKeys[v].append(k)
    for word in dictionary:
      self._insert(word)

  def encrypt(self, word1: str) -> str:
    return ''.join(self.keyToValue[c] for c in word1)

  def decrypt(self, word2: str) -> int:
    return self._find(word2, 0, self.root)

  def _insert(self, word: str) -> None:
    node = self.root
    for c in word:
      node = node.children.setdefault(c, TrieNode())
    node.isWord = True

  def _find(self, word: str, i: int, node: TrieNode) -> int:
    value = word[i:i + 2]
    if value not in self.valueToKeys:
      return 0

    ans = 0
    if i + 2 == len(word):
      for key in self.valueToKeys[value]:
        ans += node.children[key].isWord
      return ans

    for key in self.valueToKeys[value]:
      if key not in node.children:
        continue
      ans += self._find(word, i + 2, node.children[key])

    return ans

```

## 2234. Maximum Total Beauty of the Gardens_2234.py
```python
class Solution:
  def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:
    n = len(flowers)

    # If a garden is already complete, clamp it to the target.
    flowers = [min(flower, target) for flower in flowers]
    flowers.sort()

    # All gardens are complete, so nothing we can do.
    if flowers[0] == target:
      return n * full

    # Having many new flowers maximizes the beauty value.
    if newFlowers >= n * target - sum(flowers):
      return max(n * full, (n - 1) * full + (target - 1) * partial)

    ans = 0
    leftFlowers = newFlowers
    # cost[i] := the cost to make flowers[0..i] the same
    cost = [0] * n

    for i in range(1, n):
      # Plant (flowers[i] - flowers[i - 1]) flowers for flowers[0..i - 1].
      cost[i] = cost[i - 1] + i * (flowers[i] - flowers[i - 1])

    i = n - 1  # flowers' index (flowers[i + 1..n) are complete)
    while flowers[i] == target:
      i -= 1

    while leftFlowers >= 0:
      # To maximize the minimum number of incomplete flowers, we find the first
      # index j that we can't make flowers[0..j] equal to flowers[j], then we
      # know we can make flowers[0..j - 1] equal to flowers[j - 1]. In the
      # meantime, evenly increase each of them to seek a bigger minimum value.
      j = min(i + 1, bisect_right(cost, leftFlowers))
      minIncomplete = flowers[j - 1] + (leftFlowers - cost[j - 1]) // j
      ans = max(ans, (n - 1 - i) * full + minIncomplete * partial)
      leftFlowers -= max(0, target - flowers[i])
      i -= 1

    return ans

```

## 1101. The Earliest Moment When Everyone Become Friends_1101.py
```python
class UnionFind:
  def __init__(self, n: int):
    self.count = n
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self._find(u)
    j = self._find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1
    self.count -= 1

  def getCount(self) -> int:
    return self.count

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def earliestAcq(self, logs: List[List[int]], n: int) -> int:
    uf = UnionFind(n)

    logs.sort(key=lambda x: x[0])

    # Sort `logs` by timestamp.
    for timestamp, x, y in logs:
      uf.unionByRank(x, y)
      if uf.getCount() == 1:
        return timestamp

    return -1

```

## 2646. Minimize the Total Price of the Trips_2646.py
```python
class Solution:
  def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int],
                        trips: List[List[int]]) -> int:
    graph = [[] for _ in range(n)]

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    # count[i] := the number of times i is traversed
    count = [0] * n

    def dfsCount(u: int, prev: int, end: int, path: List[int]) -> None:
      path.append(u)
      if u == end:
        for i in path:
          count[i] += 1
        return
      for v in graph[u]:
        if v != prev:
          dfsCount(v, u, end,  path)
      path.pop()

    for start, end in trips:
      dfsCount(start, -1, end, [])

    @functools.lru_cache(None)
    def dfs(u: int, prev: int, parentHalved: bool) -> int:
      """
      Returns the minimum price sum for the i-th node, where its parent is
      halved parent or not halved not.
      """
      sumWithFullNode = price[u] * count[u] + sum(dfs(v, u, False)
                                                  for v in graph[u]
                                                  if v != prev)
      if parentHalved:  # Can't halve this node if its parent was halved.
        return sumWithFullNode
      sumWithHalvedNode = (price[u] // 2) * count[u] + sum(dfs(v, u, True)
                                                           for v in graph[u]
                                                           if v != prev)
      return min(sumWithFullNode, sumWithHalvedNode)

    return dfs(0, -1, False)

```

## 527. Word Abbreviation_527-2.py
```python
class IndexedWord:
  def __init__(self, word: str, index: int):
    self.word = word
    self.index = index


class Solution:
  def wordsAbbreviation(self, words: List[str]) -> List[str]:
    n = len(words)
    ans = [''] * n

    def getAbbrev(s: str, prefixIndex: int) -> str:
      n = len(s)
      num = n - (prefixIndex + 1) - 1
      numLength = 1 if num < 10 else (2 if num < 100 else 3)
      abbrevLength = (prefixIndex + 1) + numLength + 1
      if abbrevLength >= n:
        return s
      return s[:prefixIndex + 1] + str(num) + s[-1]

    abbrevToIndexedWords = collections.defaultdict(list)

    for i, word in enumerate(words):
      abbrev = getAbbrev(word, 0)
      abbrevToIndexedWords[abbrev].append(IndexedWord(word, i))

    def longestCommonPrefix(s1: str, s2: str) -> int:
      i = 0
      while i < len(s1) and i < len(s2) and s1[i] == s2[i]:
        i += 1
      return i

    for indexedWords in abbrevToIndexedWords.values():
      indexedWords.sort(key=lambda x: x.word)
      lcp = [0] * len(indexedWords)
      for i, (a, b) in enumerate(zip(indexedWords, indexedWords[1:])):
        k = longestCommonPrefix(a.word, b.word)
        lcp[i] = max(lcp[i], k)
        lcp[i + 1] = k
      for iw, l in zip(indexedWords, lcp):
        ans[iw.index] = getAbbrev(iw.word, l)

    return ans

```

## 2921. Maximum Profitable Triplets With Increasing Prices II_2921.py
```python
class FenwickTree:
  def __init__(self, n: int):
    self.vals = [0] * (n + 1)

  def maximize(self, i: int, val: int) -> None:
    while i < len(self.vals):
      self.vals[i] = max(self.vals[i], val)
      i += FenwickTree.lowbit(i)

  def get(self, i: int) -> int:
    res = 0
    while i > 0:
      res = max(res, self.vals[i])
      i -= FenwickTree.lowbit(i)
    return res

  @staticmethod
  def lowbit(i: int) -> int:
    return i & -i


class Solution:
  # Same as 2907. Maximum Profitable Triplets With Increasing Prices I
  def maxProfit(self, prices: List[int], profits: List[int]) -> int:
    ans = -1
    maxPrice = max(prices)
    maxProfitTree1 = FenwickTree(maxPrice)
    maxProfitTree2 = FenwickTree(maxPrice)

    for price, profit in zip(prices, profits):
      # max(proftis[i])
      maxProfit1 = maxProfitTree1.get(price - 1)
      # max(proftis[i]) + max(profits[j])
      maxProfit2 = maxProfitTree2.get(price - 1)
      maxProfitTree1.maximize(price, profit)
      if maxProfit1 > 0:
        maxProfitTree2.maximize(price, profit + maxProfit1)
      if maxProfit2 > 0:
        ans = max(ans, profit + maxProfit2)

    return ans

```

## 676. Implement Magic Dictionary_676-2.py
```python
class TrieNode:
  def __init__(self):
    self.children: Dict[str, TrieNode] = collections.defaultdict(TrieNode)
    self.isWord = False


class MagicDictionary:
  def __init__(self):
    self.root = TrieNode()

  def buildDict(self, dictionary: List[str]) -> None:
    for word in dictionary:
      self._insert(word)

  def search(self, searchWord: str) -> bool:
    node: TrieNode = self.root
    for i, c in enumerate(searchWord):
      for letter in string.ascii_lowercase:
        if letter == c:
          continue
        child = node.children[letter]
        if not child:
          continue
        # Replace the searchWord[i] with `letter`, then check if
        # searchWord[i + 1..n) matches `child`.
        if self._find(child, searchWord, i + 1):
          return True
      if not node.children[c]:
        return False
      node = node.children[c]
    return False

  def _insert(self, word: str) -> None:
    node: TrieNode = self.root
    for c in word:
      node = node.children.setdefault(c, TrieNode())
    node.isWord = True

  def _find(self, node: TrieNode, word: str, i: int) -> bool:
    for c in word[i:]:
      if c not in node.children:
        return False
      node = node.children[c]
    return node.isWord

```

## 2781. Length of the Longest Valid Substring_2781-2.py
```python
class TrieNode:
  def __init__(self):
    self.children: Dict[str, TrieNode] = {}
    self.isWord = False


class Trie:
  def __init__(self):
    self.root = TrieNode()

  def insert(self, word: str) -> None:
    node: TrieNode = self.root
    for c in word:
      node = node.children.setdefault(c, TrieNode())
    node.isWord = True

  def search(self, word: str, l: int, r: int) -> bool:
    node: TrieNode = self.root
    for i in range(l, r):
      if word[i] not in node.children:
        return False
      node = node.children[word[i]]
    return node.isWord


class Solution:
  def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
    ans = 0
    trie = Trie()

    for s in forbidden:
      trie.insert(s)

    # r is the rightmost index to make word[l..r] a valid substring.
    r = len(word) - 1
    for l in range(len(word) - 1, -1, -1):
      for end in range(l, min(l + 10, r + 1)):
        if trie.search(word, l, end + 1):
          r = end - 1
          break
      ans = max(ans, r - l + 1)

    return ans

```

## 1842. Next Palindrome Using Same Digits_1842.py
```python
class Solution:
  def nextPalindrome(self, num: str) -> str:
    def nextPermutation(nums: List[int]) -> bool:
      n = len(nums)

      # From the back to the front, find the first num < nums[i + 1].
      i = n - 2
      while i >= 0:
        if nums[i] < nums[i + 1]:
          break
        i -= 1

      if i < 0:
        return False

      # From the back to the front, find the first num > nums[i] and swap it
      # with nums[i].
      for j in range(n - 1, i, -1):
        if nums[j] > nums[i]:
          nums[i], nums[j] = nums[j], nums[i]
          break

      def reverse(nums, l, r):
        while l < r:
          nums[l], nums[r] = nums[r], nums[l]
          l += 1
          r -= 1

      # Reverse nums[i + 1..n - 1].
      reverse(nums, i + 1, len(nums) - 1)
      return True

    n = len(num)
    A = [ord(num[i]) - ord('0') for i in range(len(num) // 2)]

    if not nextPermutation(A):
      return ''

    s = ''.join([chr(ord('0') + a) for a in A])
    if n % 2 == 1:
      return s + num[n // 2] + s[::-1]
    return s + s[::-1]

```

## 2076. Process Restricted Friend Requests_2076.py
```python
class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:
    ans = []
    uf = UnionFind(n)

    for u, v in requests:
      pu = uf.find(u)
      pv = uf.find(v)
      isValid = True
      if pu != pv:
        for x, y in restrictions:
          px = uf.find(x)
          py = uf.find(y)
          if (pu, pv) in [(px, py), (py, px)]:
            isValid = False
            break
      ans.append(isValid)
      if isValid:
        uf.unionByRank(pu, pv)

    return ans

```

## 906. Super Palindromes_906.py
```python
class Solution:
  def superpalindromesInRange(self, left: str, right: str) -> int:
    def nextPalindrome(num: int) -> int:
      s = str(num)
      n = len(s)

      half = s[0:(n + 1) // 2]
      reversedHalf = half[:n // 2][::-1]
      candidate = int(half + reversedHalf)
      if candidate >= num:
        return candidate

      half = str(int(half) + 1)
      reversedHalf = half[:n // 2][::-1]
      return int(half + reversedHalf)

    def isPalindrome(num: int) -> bool:
      s = str(num)
      l = 0
      r = len(s) - 1

      while l < r:
        if s[l] != s[r]:
          return False
        l += 1
        r -= 1

      return True

    ans = 0
    l = int(left)
    r = int(right)
    i = math.isqrt(l)

    while i * i <= r:
      palindrome = nextPalindrome(i)
      squared = palindrome**2
      if squared <= r and isPalindrome(squared):
        ans += 1
      i = palindrome + 1

    return ans

```

## 736. Parse Lisp Expression_736.py
```python
class Solution:
  def evaluate(self, expression: str) -> int:
    def evaluate(e: str, prevScope: dict) -> int:
      if e[0].isdigit() or e[0] == '-':
        return int(e)
      if e in prevScope:
        return prevScope[e]

      scope = prevScope.copy()
      nextExpression = e[e.index(' ') + 1:-1]
      tokens = parse(nextExpression)

      if e[1] == 'm':  # 'mult'
        return evaluate(tokens[0], scope) * evaluate(tokens[1], scope)
      if e[1] == 'a':  # 'add'
        return evaluate(tokens[0], scope) + evaluate(tokens[1], scope)

      # 'let'
      for i in range(0, len(tokens) - 2, 2):
        scope[tokens[i]] = evaluate(tokens[i + 1], scope)

      return evaluate(tokens[-1], scope)

    def parse(e: str):
      tokens = []
      s = ''
      opened = 0

      for c in e:
        if c == '(':
          opened += 1
        elif c == ')':
          opened -= 1
        if opened == 0 and c == ' ':
          tokens.append(s)
          s = ''
        else:
          s += c

      if len(s) > 0:
        tokens.append(s)
      return tokens

    return evaluate(expression, {})

```

## 3108. Minimum Cost Walk in Weighted Graph_3108.py
```python
class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n
    # 2^17 - 1 is the minimum number in the form 2^x - 1 > 10^5.
    self.weight = [(1 << 17) - 1] * n

  def unionByRank(self, u: int, v: int, w: int) -> None:
    i = self._find(u)
    j = self._find(v)
    newWeight = self.weight[i] & self.weight[j] & w
    self.weight[i] = newWeight
    self.weight[j] = newWeight
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def getMinCost(self, u: int, v: int) -> int:
    if u == v:
      return 0
    i = self._find(u)
    j = self._find(v)
    return self.weight[i] if i == j else -1

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:
    uf = UnionFind(n)

    for u, v, w in edges:
      uf.unionByRank(u, v, w)

    return [uf.getMinCost(u, v) for u, v in query]

```

## 99. Recover Binary Search Tree_99-3.py
```python
class Solution:
  def recoverTree(self, root: Optional[TreeNode]) -> None:
    pred = None
    x = None  # the first wrong node
    y = None  # the second wrong node

    def findPredecessor(root: Optional[TreeNode]) -> Optional[TreeNode]:
      pred = root.left
      while pred.right and pred.right != root:
        pred = pred.right
      return pred

    while root:
      if root.left:
        morrisPred = findPredecessor(root)
        if morrisPred.right:
          # The node has already been connected before.
          # Start the main logic.
          if pred and root.val < pred.val:
            y = root
            if not x:
              x = pred
          pred = root
          # End of the main logic
          morrisPred.right = None  # Break the connection.
          root = root.right
        else:
          morrisPred.right = root  # Connect it.
          root = root.left
      else:
        # Start the main logic.
        if pred and root.val < pred.val:
          y = root
          if not x:
            x = pred
        pred = root
        # End of the main logic.
        root = root.right

    def swap(x: Optional[TreeNode], y: Optional[TreeNode]) -> None:
      temp = x.val
      x.val = y.val
      y.val = temp

    swap(x, y)

```

## 3037. Find Pattern in Infinite Stream II_3037.py
```python
# Definition for an infinite stream.
# class InfiniteStream:
#   def next(self) -> int:
#     pass

class Solution:
  # Same as 3023. Find Pattern in Infinite Stream I
  def findPattern(self, stream: Optional['InfiniteStream'], pattern: List[int]) -> int:
    lps = self._getLPS(pattern)
    i = 0  # stream's index
    j = 0  # pattern's index
    bit = 0  # the bit in the stream
    readNext = False
    while True:
      if not readNext:
        bit = stream.next()
        readNext = True
      if bit == pattern[j]:
        i += 1
        readNext = False
        j += 1
        if j == len(pattern):
          return i - j
      # Mismatch after j matches.
      elif j > 0:
        # Don't match lps[0..lps[j - 1]] since they will match anyway.
        j = lps[j - 1]
      else:
        i += 1
        readNext = False

  def _getLPS(self, pattern: List[int]) -> List[int]:
    """
    Returns the lps array, where lps[i] is the length of the longest prefix of
    pattern[0..i] which is also a suffix of this substring.
    """
    lps = [0] * len(pattern)
    j = 0
    for i in range(1, len(pattern)):
      while j > 0 and pattern[j] != pattern[i]:
        j = lps[j - 1]
      if pattern[i] == pattern[j]:
        j += 1
        lps[i] = j
    return lps

```

