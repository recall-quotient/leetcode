## 2352. Equal Row and Column Pairs_2352.py

```python
class Solution:
  def equalPairs(self, grid: List[List[int]]) -> int:
    n = len(grid)
    ans = 0

    for i in range(n):
      for j in range(n):
        k = 0
        while k < n:
          if grid[i][k] != grid[k][j]:
            break
          k += 1
        if k == n:  # R[i] == C[j]
          ans += 1

    return ans

```

## 1818. Minimum Absolute Sum Difference_1818.py

```python
class Solution:
  def minAbsoluteSumDiff(self, nums1: List[int], nums2: List[int]) -> int:
    ans = math.inf
    diffs = [abs(a - b) for a, b in zip(nums1, nums2)]
    sumDiff = sum(diffs)

    nums1.sort()

    for num, diff in zip(nums2, diffs):
      i = bisect.bisect_left(nums1, num)
      if i > 0:
        ans = min(ans, sumDiff - diff + abs(num - nums1[i - 1]))
      if i < len(nums1):
        ans = min(ans, sumDiff - diff + abs(num - nums1[i]))

    return ans % int(1e9 + 7)

```

## 1551. Minimum Operations to Make Array Equal_1551.py

```python
class Solution:
  def minOperations(self, n: int) -> int:
    def arr(self, i: int) -> int:
      """Returns the i-th element of `arr`, where 1 <= i <= n."""
      return (i - 1) * 2 + 1

    #     median := median of arr
    #   diffs[i] := median - arr[i] where i <= i <= n // 2
    #        ans := sum(diffs)
    # e.g.
    # n = 5, arr = [1, 3, 5, 7, 9], diffs = [4, 2]
    #        ans = (4 + 2) * 2 // 2 = 6
    # n = 6, arr = [1, 3, 5, 7, 9, 11], diffs = [5, 3, 1]
    #        ans = (5 + 1) * 3 // 2 = 9
    halfSize = n // 2
    median = (arr(n) + arr(1)) // 2
    firstDiff = median - arr(1)
    lastDiff = median - arr(halfSize)
    return (firstDiff + lastDiff) * halfSize // 2

```

## 895. Maximum Frequency Stack_895.py

```python
class FreqStack:
  def __init__(self):
    self.maxFreq = 0
    self.count = collections.Counter()
    self.countToStack = collections.defaultdict(list)

  def push(self, val: int) -> None:
    self.count[val] += 1
    self.countToStack[self.count[val]].append(val)
    self.maxFreq = max(self.maxFreq, self.count[val])

  def pop(self) -> int:
    val = self.countToStack[self.maxFreq].pop()
    self.count[val] -= 1
    if not self.countToStack[self.maxFreq]:
      self.maxFreq -= 1
    return val

```

## 284. Peeking Iterator_284.py

```python
class PeekingIterator:
  def __init__(self, iterator: Iterator):
    self.iterator = iterator
    self.buffer = self.iterator.next() if self.iterator.hasNext() else None

  def peek(self) -> int:
    """
    Returns the next element in the iteration without advancing the iterator.
    """
    return self.buffer

  def next(self) -> int:
    next = self.buffer
    self.buffer = self.iterator.next() if self.iterator.hasNext() else None
    return next

  def hasNext(self) -> bool:
    return self.buffer is not None

```

## 2654. Minimum Number of Operations to Make All Array Elements Equal to 1_2654.py

```python
class Solution:
  def minOperations(self, nums: List[int]) -> int:
    n = len(nums)
    ones = nums.count(1)
    if ones > 0:
      return n - ones

    # the minimum operations to make the shortest subarray with a gcd == 1
    minOps = math.inf

    for i, g in enumerate(nums):
      for j in range(i + 1, n):
        g = math.gcd(g, nums[j])
        if g == 1:   # gcd(nums[i..j]:== 1
          minOps = min(minOps, j - i)
          break

    # After making the shortest subarray with `minOps`, need additional n - 1
    # operations to make the other numbers to 1.
    return -1 if minOps == math.inf else minOps + n - 1

```

## 2008. Maximum Earnings From Taxi_2008-2.py

```python
class Solution:
  def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -> int:
    endToStartAndEarns = [[] for _ in range(n + 1)]
    # dp[i] := the maximum dollars you can earn starting at i
    dp = [0] * (n + 1)

    for start, end, tip in rides:
      earn = end - start + tip
      endToStartAndEarns[end].append((start, earn))

    for i in range(1, n + 1):
      dp[i] = dp[i - 1]
      for start, earn in endToStartAndEarns[i]:
        dp[i] = max(dp[i], dp[start] + earn)

    return dp[n]

```

## 1237. Find Positive Integer Solution for a Given Equation_1237.py

```python
class Solution:
  def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:
    ans = []
    x = 1
    y = 1000

    while x <= 1000 and y >= 1:
      f = customfunction.f(x, y)
      if f < z:
        x += 1
      elif f > z:
        y -= 1
      else:
        ans.append([x, y])
        x += 1
        y -= 1

    return ans

```

## 2176. Count Equal and Divisible Pairs in an Array_2176.py

```python
class Solution:
  def countPairs(self, nums: List[int], k: int) -> int:
    ans = 0
    numToIndices = collections.defaultdict(list)

    for i, num in enumerate(nums):
      numToIndices[num].append(i)

    for indices in numToIndices.values():
      gcds = collections.Counter()
      for i in indices:
        gcd_i = math.gcd(i, k)
        for gcd_j, count in gcds.items():
          if gcd_i * gcd_j % k == 0:
            ans += count
        gcds[gcd_i] += 1

    return ans

```

## 2696. Minimum String Length After Removing Substrings_2696.py

```python
class Solution:
  def minLength(self, s: str) -> int:
    stack = []

    def match(c: str) -> bool:
      return stack and stack[-1] == c

    for c in s:
      if c == 'B' and match('A'):
        stack.pop()
      elif c == 'D' and match('C'):
        stack.pop()
      else:
        stack.append(c)

    return len(stack)

```

## 1275. Find Winner on a Tic Tac Toe Game_1275.py

```python
class Solution:
  def tictactoe(self, moves: List[List[int]]) -> str:
    row = [[0] * 3 for _ in range(2)]
    col = [[0] * 3 for _ in range(2)]
    diag1 = [0] * 2
    diag2 = [0] * 2
    i = 0

    for r, c in moves:
      row[i][r] += 1
      col[i][c] += 1
      diag1[i] += r == c
      diag2[i] += r + c == 2
      if 3 in (row[i][r], col[i][c], diag1[i], diag2[i]):
        return 'A' if i == 0 else 'B'
      i ^= 1

    return 'Draw' if len(moves) == 9 else 'Pending'

```

## 1462. Course Schedule IV_1462-2.py

```python
class Solution:
  def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
    ans = []
    # isPrerequisite[i][j] := True if course i is a prerequisite of course j.
    isPrerequisite = [[False] * numCourses for _ in range(numCourses)]

    for u, v in prerequisites:
      isPrerequisite[u][v] = True

    for k in range(numCourses):
      for i in range(numCourses):
        for j in range(numCourses):
          isPrerequisite[i][j] = isPrerequisite[i][j] or \
              (isPrerequisite[i][k] and isPrerequisite[k][j])

    return [isPrerequisite[u][v] for u, v in queries]

```

## 298. Binary Tree Longest Consecutive Sequence_298.py

```python
class Solution:
  def longestConsecutive(self, root: Optional[TreeNode]) -> int:
    if not root:
      return 0

    def dfs(root: Optional[TreeNode], target: int, length: int, maxLength: int) -> int:
      if not root:
        return maxLength
      if root.val == target:
        length += 1
        maxLength = max(maxLength, length)
      else:
        length = 1
      return max(dfs(root.left, root.val + 1, length, maxLength),
                 dfs(root.right, root.val + 1, length, maxLength))

    return dfs(root, root.val, 0, 0)

```

## 791. Custom Sort String_791.py

```python
class Solution:
  def customSortString(self, order: str, s: str) -> str:
    ans = ""
    count = [0] * 26

    for c in s:
      count[ord(c) - ord('a')] += 1

    for c in order:
      while count[ord(c) - ord('a')] > 0:
        ans += c
        count[ord(c) - ord('a')] -= 1

    for c in string.ascii_lowercase:
      for _ in range(count[ord(c) - ord('a')]):
        ans += c

    return ans

```

## 129. Sum Root to Leaf Numbers_129.py

```python
class Solution:
  def sumNumbers(self, root: Optional[TreeNode]) -> int:
    ans = 0

    def dfs(root: Optional[TreeNode], path: int) -> None:
      nonlocal ans
      if not root:
        return
      if not root.left and not root.right:
        ans += path * 10 + root.val
        return

      dfs(root.left, path * 10 + root.val)
      dfs(root.right, path * 10 + root.val)

    dfs(root, 0)
    return ans

```

## 2059. Minimum Operations to Convert Number_2059.py

```python
class Solution:
  def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:
    ans = 0
    q = collections.deque([start])
    seen = {start}

    while q:
      ans += 1
      for _ in range(len(q)):
        x = q.popleft()
        for num in nums:
          for res in (x + num, x - num, x ^ num):
            if res == goal:
              return ans
            if res < 0 or res > 1000 or res in seen:
              continue
            seen.add(res)
            q.append(res)

    return -1

```

## 2196. Create Binary Tree From Descriptions_2196.py

```python
class Solution:
  def createBinaryTree(self, descriptions: List[List[int]]) -> Optional[TreeNode]:
    children = set()
    valToNode = {}

    for p, c, isLeft in descriptions:
      parent = valToNode.setdefault(p, TreeNode(p))
      child = valToNode.setdefault(c, TreeNode(c))
      if isLeft:
        parent.left = child
      else:
        parent.right = child
      children.add(c)

    root = (set(valToNode) - set(children)).pop()
    return valToNode[root]

```

## 2542. Maximum Subsequence Score_2542.py

```python
class Solution:
  # Same as 1383. Maximum Performance of a Team
  def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:
    ans = 0
    summ = 0
    # (nums2[i], nums1[i]) sorted by nums2[i] in descending order
    A = sorted([(num2, num1)
               for num1, num2 in zip(nums1, nums2)], reverse=True)
    minHeap = []

    for num2, num1 in A:
      heapq.heappush(minHeap, num1)
      summ += num1
      if len(minHeap) > k:
        summ -= heapq.heappop(minHeap)
      if len(minHeap) == k:
        ans = max(ans, summ * num2)

    return ans

```

## 904. Fruit Into Baskets_904.py

```python
class Solution:
  def totalFruit(self, fruits: List[int]) -> int:
    ans = 0
    count = collections.defaultdict(int)

    l = 0
    for r, fruit in enumerate(fruits):
      count[fruit] += 1
      while len(count) > 2:
        count[fruits[l]] -= 1
        if count[fruits[l]] == 0:
          del count[fruits[l]]
        l += 1
      ans = max(ans, r - l + 1)

    return ans

```

## 384. Shuffle an Array_384.py

```python
class Solution:
  def __init__(self, nums: List[int]):
    self.nums = nums

  def reset(self) -> List[int]:
    """
    Resets the array to its original configuration and return it.
    """
    return self.nums

  def shuffle(self) -> List[int]:
    """
    Returns a random shuffling of the array.
    """
    A = self.nums.copy()
    for i in range(len(A) - 1, 0, -1):
      j = random.randint(0, i)
      A[i], A[j] = A[j], A[i]
    return A

```

## 805. Split Array With Same Average_805.py

```python
class Solution:
  def splitArraySameAverage(self, nums: List[int]) -> bool:
    n = len(nums)
    summ = sum(nums)
    if not any(i * summ % n == 0 for i in range(1, n // 2 + 1)):
      return False

    sums = [set() for _ in range(n // 2 + 1)]
    sums[0].add(0)

    for num in nums:
      for i in range(n // 2, 0, -1):
        for val in sums[i - 1]:
          sums[i].add(num + val)

    for i in range(1, n // 2 + 1):
      if i * summ % n == 0 and i * summ // n in sums[i]:
        return True

    return False

```

## 2925. Maximum Score After Applying Operations on a Tree_2925.py

```python
class Solution:
  def maximumScoreAfterOperations(self, edges: List[List[int]], values: List[int]) -> int:
    tree = [[] for _ in values]

    for u, v in edges:
      tree[u].append(v)
      tree[v].append(u)

    def dfs(u: int, prev: int) -> None:
      if u > 0 and len(tree[u]) == 1:
        return values[u]
      childrenSum = sum(dfs(v, u)
                        for v in tree[u]
                        if v != prev)
      return min(childrenSum, values[u])

    return sum(values) - dfs(0, -1)

```

## 2444. Count Subarrays With Fixed Bounds_2444.py

```python
class Solution:
  def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:
    ans = 0
    j = -1
    prevMinKIndex = -1
    prevMaxKIndex = -1

    for i, num in enumerate(nums):
      if num < minK or num > maxK:
        j = i
      if num == minK:
        prevMinKIndex = i
      if num == maxK:
        prevMaxKIndex = i
      # Any index k in [j + 1, min(prevMinKIndex, prevMaxKIndex)] can be the
      # start of the subarray s.t. nums[k..i] satisfies the conditions.
      ans += max(0, min(prevMinKIndex, prevMaxKIndex) - j)

    return ans

```

## 3070. Count Submatrices with Top-Left Element and Sum Less Than k_3070.py

```python
class Solution:
  def countSubmatrices(self, grid: List[List[int]], k: int) -> int:
    m = len(grid)
    n = len(grid[0])
    ans = 0
    # prefix[i][j] := the sum of matrix[0..i)[0..j)
    prefix = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m):
      for j in range(n):
        prefix[i + 1][j + 1] = \
            grid[i][j] + prefix[i][j + 1] + \
            prefix[i + 1][j] - prefix[i][j]
        if prefix[i + 1][j + 1] <= k:
          ans += 1

    return ans

```

## 1823. Find the Winner of the Circular Game_1823-2.py

```python
class Solution:
  def findTheWinner(self, n: int, k: int) -> int:
    # e.g. n = 4, k = 2.
    # By using 0-indexed notation, we have the following circle:
    #
    # 0 -> 1 -> 2 -> 3 -> 0
    #      x
    #           0 -> 1 -> 2 -> 0
    #
    # After the first round, 1 is removed.
    # So, 2 becomes 0, 3 becomes 1, and 0 becomes 2.
    # Let's denote that oldIndex = f(n, k) and newIndex = f(n - 1, k).
    # By observation, we know f(n, k) = (f(n - 1, k) + k) % n.
    def f(n: int, k: int) -> int:
      if n == 1:
        return 0
      return (f(n - 1, k) + k) % n

    # Converts back to 1-indexed.
    return f(n, k) + 1

```

## 117. Populating Next Right Pointers in Each Node II_117.py

```python
class Solution:
  def connect(self, root: 'Node') -> 'Node':
    node = root  # the node that is above the current needling

    while node:
      dummy = Node(0)  # a dummy node before needling
      # Needle the children of the node.
      needle = dummy
      while node:
        if node.left:  # Needle the left child.
          needle.next = node.left
          needle = needle.next
        if node.right:  # Needle the right child.
          needle.next = node.right
          needle = needle.next
        node = node.next
      node = dummy.next  # Move the node to the next level.

    return root

```

## 3176. Find the Maximum Length of a Good Subsequence I_3176.py

```python
class Solution:
  def maximumLength(self, nums: List[int], k: int) -> int:
    # dp[count][num] := the maximum length of a good subsequence with at most
    # `count` indices where seq[i] != seq[i + 1] and it ends in `num`.
    dp = [collections.Counter() for _ in range(k + 1)]
    # maxLen[count] := the maximum length of a good subsequence with `count`
    # indices where seq[i] != seq[i + 1]
    maxLen = [0] * (k + 1)

    for num in nums:
      for count in range(k, -1, -1):
        # Append `num` to the subsequence.
        dp[count][num] += 1
        if count > 0:
          dp[count][num] = max(dp[count][num], maxLen[count - 1] + 1)
        maxLen[count] = max(maxLen[count], dp[count][num])

    return maxLen[k]

```

## 243. Shortest Word Distance_243.py

```python
class Solution:
  def shortestDistance(self, wordsDict: List[str], word1: str, word2: str) -> int:
    ans = len(wordsDict)
    index1 = -1  # wordsDict[index1] == word1
    index2 = -1  # wordsDict[index2] == word2

    for i, word in enumerate(wordsDict):
      if word == word1:
        index1 = i
        if index2 != -1:
          ans = min(ans, index1 - index2)
      if word == word2:
        index2 = i
        if index1 != -1:
          ans = min(ans, index2 - index1)

    return ans

```

## 1646. Get Maximum in Generated Array_1646.py

```python
class Solution:
  def getMaximumGenerated(self, n: int) -> int:
    if n == 0:
      return 0
    if n == 1:
      return 1

    nums = [0] * (n + 1)
    nums[1] = 1

    i = 1
    while 2 * i + 1 <= n:
      nums[2 * i] = nums[i]
      nums[2 * i + 1] = nums[i] + nums[i + 1]
      i += 1

    return max(nums)

```

## 3098. Find the Sum of Subsequence Powers_3098-2.py

```python
class Solution:
  def sumOfPowers(self, nums: List[int], k: int) -> int:
    kMod = 1_000_000_007
    n = len(nums)

    nums.sort()

    @functools.lru_cache(None)
    def dp(i: int, k: int, lastPickIndex: int, minDiff: int) -> int:
      if k == 0:
        return minDiff
      if i == n:
        return 0
      newMinDiff = minDiff if lastPickIndex == - 1 \
          else min(minDiff, nums[i] - nums[lastPickIndex])
      pick = dp(i + 1, k - 1, i, newMinDiff)
      skip = dp(i + 1, k, lastPickIndex, minDiff)
      return (pick + skip) % kMod

    return dp(0, k, -1, math.inf)

```

## 565. Array Nesting_565.py

```python
class Solution:
  def arrayNesting(self, nums: List[int]) -> int:
    ans = 0

    for num in nums:
      if num == -1:
        continue
      index = num
      count = 0
      while nums[index] != -1:
        cache = index
        index = nums[index]
        nums[cache] = -1
        count += 1
      ans = max(ans, count)

    return ans

```

## 2460. Apply Operations to an Array_2460.py

```python
class Solution:
  def applyOperations(self, nums: List[int]) -> List[int]:
    ans = [0] * len(nums)

    for i in range(len(nums) - 1):
      if nums[i] == nums[i + 1]:
        nums[i] *= 2
        nums[i + 1] = 0

    i = 0
    for num in nums:
      if num > 0:
        ans[i] = num
        i += 1

    return ans

```

## 1869. Longer Contiguous Segments of Ones than Zeros_1869.py

```python
class Solution:
  def checkZeroOnes(self, s: str) -> bool:
    longestOnes = 0
    longestZeros = 0
    currentOnes = 0
    currentZeros = 0

    for c in s:
      if c == '0':
        currentOnes = 0
        currentZeros += 1
        longestZeros = max(longestZeros, currentZeros)
      else:
        currentZeros = 0
        currentOnes += 1
        longestOnes = max(longestOnes, currentOnes)

    return longestOnes > longestZeros

```

## 1733. Minimum Number of People to Teach_1733.py

```python
class Solution:
  def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -> int:
    languageSets = [set(languages) for languages in languages]
    needTeach = set()
    languageCount = collections.Counter()

    # Find friends that can't communicate.
    for u, v in friendships:
      if not languageSets[u - 1] & languageSets[v - 1]:
        needTeach.add(u - 1)
        needTeach.add(v - 1)

    # Find the most popular language.
    for u in needTeach:
      for language in languageSets[u]:
        languageCount[language] += 1

    # Teach the most popular language to people don't understand.
    return len(needTeach) - max(languageCount.values(), default=0)

```

## 2024. Maximize the Confusion of an Exam_2024.py

```python
class Solution:
  def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:
    ans = 0
    maxCount = 0
    count = collections.Counter()

    l = 0
    for r, c in enumerate(answerKey):
      count[c == 'T'] += 1
      maxCount = max(maxCount, count[c == 'T'])
      while maxCount + k < r - l + 1:
        count[answerKey[l] == 'T'] -= 1
        l += 1
      ans = max(ans, r - l + 1)

    return ans

```

## 1190. Reverse Substrings Between Each Pair of Parentheses_1190.py

```python
class Solution:
  def reverseParentheses(self, s: str) -> str:
    stack = []
    ans = []

    for c in s:
      if c == '(':
        stack.append(len(ans))
      elif c == ')':
        # Reverse the corresponding substring between ().
        j = stack.pop()
        ans[j:] = ans[j:][::-1]
      else:
        ans.append(c)

    return ''.join(ans)

```

## 2326. Spiral Matrix IV_2326.py

```python
class Solution:
  def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    ans = [[-1] * n for _ in range(m)]
    x = 0  # the current x position
    y = 0  # the current y position
    d = 0

    curr = head
    while curr:
      ans[x][y] = curr.val
      if x + dirs[d] < 0 or x + dirs[d] == m or y + dirs[d + 1] < 0 or \
              y + dirs[d + 1] == n or ans[x + dirs[d]][y + dirs[d + 1]] != -1:
        d = (d + 1) % 4
      x += dirs[d]
      y += dirs[d + 1]
      curr = curr.next

    return ans

```

## 2105. Watering Plants II_2105.py

```python
class Solution:
  def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:
    ans = 0
    i = 0
    j = len(plants) - 1
    canA = capacityA
    canB = capacityB

    while i < j:
      ans += (canA < plants[i]) + (canB < plants[j])
      if canA < plants[i]:
        canA = capacityA
      if canB < plants[j]:
        canB = capacityB
      canA -= plants[i]
      canB -= plants[j]
      i += 1
      j -= 1

    return ans + (i == j and max(canA, canB) < plants[i])

```

## 271. Encode and Decode Strings_271.py

```python
class Codec:
  def encode(self, strs: List[str]) -> str:
    """Encodes a list of strings to a single string."""
    return ''.join(str(len(s)) + '/' + s for s in strs)

  def decode(self, s: str) -> List[str]:
    """Decodes a single string to a list of strings."""
    decoded = []

    i = 0
    while i < len(s):
      slash = s.find('/', i)
      length = int(s[i:slash])
      i = slash + length + 1
      decoded.append(s[slash + 1:i])

    return decoded

```

## 2844. Minimum Operations to Make a Special Number_2844.py

```python
class Solution:
  def minimumOperations(self, num: str) -> int:
    n = len(num)
    seenFive = False
    seenZero = False

    for i in range(n - 1, -1, -1):
      if seenZero and num[i] == '0':  # '00'
        return n - i - 2
      if seenZero and num[i] == '5':  # '50'
        return n - i - 2
      if seenFive and num[i] == '2':  # '25'
        return n - i - 2
      if seenFive and num[i] == '7':  # '75'
        return n - i - 2
      seenZero = seenZero or num[i] == '0'
      seenFive = seenFive or num[i] == '5'

    return n - 1 if seenZero else n

```

## 1022. Sum of Root To Leaf Binary Numbers_1022.py

```python
class Solution:
  def sumRootToLeaf(self, root: Optional[TreeNode]) -> int:
    ans = 0

    def dfs(root: Optional[TreeNode], val: int) -> None:
      nonlocal ans
      if not root:
        return
      val = val * 2 + root.val
      if not root.left and not root.right:
        ans += val
      dfs(root.left, val)
      dfs(root.right, val)

    dfs(root, 0)
    return ans

```

## 341. Flatten Nested List Iterator_341-2.py

```python
class NestedIterator:
  def __init__(self, nestedList: List[NestedInteger]):
    self.stack: List[NestedInteger] = []
    self.addInteger(nestedList)

  def next(self) -> int:
    return self.stack.pop().getInteger()

  def hasNext(self) -> bool:
    while self.stack and not self.stack[-1].isInteger():
      self.addInteger(self.stack.pop().getList())
    return self.stack

  # addInteger([1, [4, [6]]]) . stack = [[4, [6]], 1]
  # addInteger([4, [6]]) . stack = [[6], 4]
  # addInteger([6]) . stack = [6]
  def addInteger(self, nestedList: List[NestedInteger]) -> None:
    for n in reversed(nestedList):
      self.stack.append(n)

```

## 2435. Paths in Matrix Whose Sum Is Divisible by K_2435.py

```python
class Solution:
  def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
    kMod = 1_000_000_007
    m = len(grid)
    n = len(grid[0])

    @functools.lru_cache(None)
    def dp(i: int, j: int, summ: int) -> int:
      """
      Returns the number of paths to (i, j), where the sum / k == `summ`.
      """
      if i == m or j == n:
        return 0
      if i == m - 1 and j == n - 1:
        return 1 if (summ + grid[i][j]) % k == 0 else 0
      newSum = (summ + grid[i][j]) % k
      return (dp(i + 1, j, newSum) + dp(i, j + 1, newSum)) % kMod

    return dp(0, 0, 0)

```

## 330. Patching Array_330.py

```python
class Solution:
  def minPatches(self, nums: List[int], n: int) -> int:
    ans = 0
    i = 0  # nums' index
    miss = 1  # the minimum sum in [1, n] we might miss

    while miss <= n:
      if i < len(nums) and nums[i] <= miss:
        miss += nums[i]
        i += 1
      else:
        # Greedily add `miss` itself to increase the range from
        # [1, miss) to [1, 2 * miss).
        miss += miss
        ans += 1

    return ans

```

## 977. Squares of a Sorted Array_977.py

```python
class Solution:
  def sortedSquares(self, nums: List[int]) -> List[int]:
    n = len(nums)
    l = 0
    r = n - 1
    ans = [0] * n

    while n:
      n -= 1
      if abs(nums[l]) > abs(nums[r]):
        ans[n] = nums[l] * nums[l]
        l += 1
      else:
        ans[n] = nums[r] * nums[r]
        r -= 1

    return ans

```

## 2237. Count Positions on Street With Required Brightness_2237.py

```python
class Solution:
  def meetRequirement(self, n: int, lights: List[List[int]], requirement: List[int]) -> int:
    ans = 0
    currBrightness = 0
    change = [0] * (n + 1)

    for position, rg in lights:
      change[max(0, position - rg)] += 1
      change[min(n, position + rg + 1)] -= 1

    for i in range(n):
      currBrightness += change[i]
      if currBrightness >= requirement[i]:
        ans += 1

    return ans

```

## 1621. Number of Sets of K Non-Overlapping Line Segments_1621.py

```python
class Solution:
  def numberOfSets(self, n: int, k: int) -> int:
    kMod = 1_000_000_007

    @functools.lru_cache(None)
    def dp(i: int, k: int, drawing: bool) -> int:
      if k == 0:  # Find a way to draw k segments.
        return 1
      if i == n:  # Reach the end.
        return 0
      if drawing:
        # 1. Keep drawing at i and move to i + 1.
        # 2. Stop at i so decrease k. We can start from i for the next segment.
        return (dp(i + 1, k, True) + dp(i, k - 1, False)) % kMod
      # 1. Skip i and move to i + 1.
      # 2. Start at i and move to i + 1.
      return (dp(i + 1, k, False) + dp(i + 1, k, True)) % kMod

    return dp(0, k, False)

```

## 2217. Find Palindrome With Fixed Length_2217.py

```python
class Solution:
  def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:
    start = pow(10, (intLength + 1) // 2 - 1)
    end = pow(10, (intLength + 1) // 2)
    mul = pow(10, intLength // 2)

    def reverse(num: int) -> int:
      res = 0
      while num:
        res = res * 10 + num % 10
        num //= 10
      return res

    def getKthPalindrome(query: int) -> int:
      prefix = start + query - 1
      return prefix * mul + reverse(prefix if intLength % 2 == 0 else prefix//10)

    return [-1 if start + query > end else getKthPalindrome(query)
            for query in queries]

```

## 538. Convert BST to Greater Tree_538.py

```python
class Solution:
  def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
    prefix = 0

    def reversedInorder(root: Optional[TreeNode]) -> None:
      nonlocal prefix
      if not root:
        return

      reversedInorder(root.right)
      prefix += root.val
      root.val = prefix
      reversedInorder(root.left)

    reversedInorder(root)
    return root

```

## 125. Valid Palindrome_125.py

```python
class Solution:
  def isPalindrome(self, s: str) -> bool:
    l = 0
    r = len(s) - 1

    while l < r:
      while l < r and not s[l].isalnum():
        l += 1
      while l < r and not s[r].isalnum():
        r -= 1
      if s[l].lower() != s[r].lower():
        return False
      l += 1
      r -= 1

    return True

```

## 410. Split Array Largest Sum_410-2.py

```python
class Solution:
  def splitArray(self, nums: List[int], k: int) -> int:
    n = len(nums)
    # dp[i][k] := the minimum of the maximum sum to split the first i numbers
    # into k groups
    dp = [[math.inf] * (k + 1) for _ in range(n + 1)]
    prefix = [0] + list(itertools.accumulate(nums))

    for i in range(1, n + 1):
      dp[i][1] = prefix[i]

    for l in range(2, k + 1):
      for i in range(l, n + 1):
        for j in range(l - 1, i):
          dp[i][l] = min(dp[i][l], max(dp[j][l - 1], prefix[i] - prefix[j]))

    return dp[n][k]

```

## 110. Balanced Binary Tree_110-2.py

```python
class Solution:
  def isBalanced(self, root: Optional[TreeNode]) -> bool:
    ans = True

    def maxDepth(root: Optional[TreeNode]) -> int:
      """Returns the height of root and sets ans to false if root unbalanced."""
      nonlocal ans
      if not root or not ans:
        return 0
      left = maxDepth(root.left)
      right = maxDepth(root.right)
      if abs(left - right) > 1:
        ans = False
      return max(left, right) + 1

    maxDepth(root)
    return ans

```

## 2306. Naming a Company_2306.py

```python
class Solution:
  def distinctNames(self, ideas: List[str]) -> int:
    ans = 0
    # suffixes[i] := the set of strings omitting the first letter, where the
    # first letter is ('a' + i)
    suffixes = [set() for _ in range(26)]

    for idea in ideas:
      suffixes[ord(idea[0]) - ord('a')].add(idea[1:])

    for i in range(25):
      for j in range(i + 1, 26):
        count = len(suffixes[i] & suffixes[j])
        ans += 2 * (len(suffixes[i]) - count) * (len(suffixes[j]) - count)

    return ans

```

## 3073. Maximum Increasing Triplet Value_3073.py

```python
from sortedcontainers import SortedSet


class Solution:
  def maximumTripletValue(self, nums: List[int]) -> int:
    ans = 0
    rightMax = [0] * len(nums)  # rightMax[i] := max(nums[i + 1..n))
    leftSortedSet = SortedSet([nums[0]])

    for i in range(len(nums) - 2, -1, -1):
      rightMax[i] = max(nums[i + 1], rightMax[i + 1])

    for j in range(1, len(nums) - 1):
      i = bisect.bisect_left(leftSortedSet, nums[j])
      if i > 0 and rightMax[j] > nums[j]:
        ans = max(ans, leftSortedSet[i - 1] - nums[j] + rightMax[j])
      leftSortedSet.add(nums[j])

    return ans

```

## 957. Prison Cells After N Days_957.py

```python
class Solution:
  def prisonAfterNDays(self, cells: List[int], n: int) -> List[int]:
    nextDayCells = [0] * len(cells)
    day = 0

    while n > 0:
      n -= 1
      for i in range(1, len(cells) - 1):
        nextDayCells[i] = 1 if cells[i - 1] == cells[i + 1] else 0
      if day == 0:
        firstDayCells = nextDayCells.copy()
      elif nextDayCells == firstDayCells:
        n %= day
      cells = nextDayCells.copy()
      day += 1

    return cells

```

## 1472. Design Browser History_1472-2.py

```python
class BrowserHistory:
  def __init__(self, homepage: str):
    self.history = []
    self.visit(homepage)

  def visit(self, url: str) -> None:
    self.history.append(url)
    self.future = []

  def back(self, steps: int) -> str:
    while len(self.history) > 1 and steps > 0:
      self.future.append(self.history.pop())
      steps -= 1
    return self.history[-1]

  def forward(self, steps: int) -> str:
    while self.future and steps > 0:
      self.history.append(self.future.pop())
      steps -= 1
    return self.history[-1]

```

## 345. Reverse Vowels of a String_345.py

```python
class Solution:
  def reverseVowels(self, s: str) -> str:
    chars = list(s)
    kVowels = 'aeiouAEIOU'
    l = 0
    r = len(s) - 1

    while l < r:
      while l < r and chars[l] not in kVowels:
        l += 1
      while l < r and chars[r] not in kVowels:
        r -= 1
      chars[l], chars[r] = chars[r], chars[l]
      l += 1
      r -= 1

    return ''.join(chars)

```

## 2944. Minimum Number of Coins for Fruits_2944-3.py

```python
class Solution:
  def minimumCoins(self, prices: List[int]) -> int:
    n = len(prices)
    ans = math.inf
    # Stores (dp[i], i), where dp[i] := the minimum number of coins to acquire
    # fruits[i:] (0-indexed) in ascending order.
    minQ = collections.deque([(0, n)])

    for i in range(n - 1, -1, -1):
      while minQ and minQ[0][1] > (i + 1) * 2:
        minQ.popleft()
      ans = prices[i] + minQ[0][0]
      while minQ and minQ[-1][0] >= ans:
        minQ.pop()
      minQ.append((ans, i))

    return ans

```

## 647. Palindromic Substrings_647.py

```python
class Solution:
  def countSubstrings(self, s: str) -> int:
    def extendPalindromes(l: int, r: int) -> int:
      count = 0

      while l >= 0 and r < len(s) and s[l] == s[r]:
        count += 1
        l -= 1
        r += 1

      return count

    ans = 0

    for i in range(len(s)):
      ans += extendPalindromes(i, i)
      ans += extendPalindromes(i, i + 1)

    return ans

```

## 2448. Minimum Cost to Make Array Equal_2448.py

```python
class Solution:
  def minCost(self, nums: List[int], cost: List[int]) -> int:
    ans = 0
    l = min(nums)
    r = max(nums)

    def getCost(target: int) -> int:
      return sum(abs(num - target) * c for num, c in zip(nums, cost))

    while l < r:
      m = (l + r) // 2
      cost1 = getCost(m)
      cost2 = getCost(m + 1)
      ans = min(cost1, cost2)
      if cost1 < cost2:
        r = m
      else:
        l = m + 1

    return ans

```

## 986. Interval List Intersections_986.py

```python
class Solution:
  def intervalIntersection(self, firstList: List[List[int]], secondList: List[List[int]]) -> List[List[int]]:
    ans = []
    i = 0
    j = 0

    while i < len(firstList) and j < len(secondList):
      # lo := the start of the intersection
      # hi := the end of the intersection
      lo = max(firstList[i][0], secondList[j][0])
      hi = min(firstList[i][1], secondList[j][1])
      if lo <= hi:
        ans.append([lo, hi])
      if firstList[i][1] < secondList[j][1]:
        i += 1
      else:
        j += 1

    return ans

```

## 479. Largest Palindrome Product_479.py

```python
class Solution:
  def largestPalindrome(self, n: int) -> int:
    if n == 1:
      return 9

    kMod = 1337
    upper = pow(10, n) - 1
    lower = pow(10, n - 1) - 1

    for i in range(upper, lower, -1):
      cand = int(str(i) + str(i)[::-1])
      j = upper
      while j * j >= cand:
        if cand % j == 0:
          return cand % kMod
        j -= 1

```

## 2086. Minimum Number of Buckets Required to Collect Rainwater from Houses_2086.py

```python
class Solution:
  def minimumBuckets(self, street: str) -> int:
    A = list(street)

    for i, c in enumerate(A):
      if c == 'H':
        if i > 0 and A[i - 1] == 'B':
          continue
        if i + 1 < len(A) and A[i + 1] == '.':
          # Always prefer place a bucket in (i + 1) because it enhances the
          # possibility to collect the upcoming houses.
          A[i + 1] = 'B'
        elif i > 0 and A[i - 1] == '.':
          A[i - 1] = 'B'
        else:
          return -1

    return A.count('B')

```

## 2772. Apply Operations to Make All Array Elements Equal to Zero_2772.py

```python
class Solution:
  def checkArray(self, nums: List[int], k: int) -> bool:
    if k == 1:
      return True

    needDecrease = 0
    # Store nums[i - k + 1..i] with decreasing nums[i - k + 1].
    dq = collections.deque()

    for i, num in enumerate(nums):
      if i >= k:
        needDecrease -= dq.popleft()
      if nums[i] < needDecrease:
        return False
      decreasedNum = nums[i] - needDecrease
      dq.append(decreasedNum)
      needDecrease += decreasedNum

    return dq[-1] == 0

```

## 894. All Possible Full Binary Trees_894.py

```python
class Solution:
  @functools.lru_cache(None)
  def allPossibleFBT(self, n: int) -> List[Optional[TreeNode]]:
    if n % 2 == 0:
      return []
    if n == 1:
      return [TreeNode(0)]

    ans = []

    for leftCount in range(n):
      rightCount = n - 1 - leftCount
      for left in self.allPossibleFBT(leftCount):
        for right in self.allPossibleFBT(rightCount):
          ans.append(TreeNode(0))
          ans[-1].left = left
          ans[-1].right = right

    return ans

```

## 2312. Selling Pieces of Wood_2312.py

```python
class Solution:
  def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:
    # dp[i][j] := the maximum money of cutting i x j piece of wood
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for h, w, price in prices:
      dp[h][w] = price

    for i in range(1, m + 1):
      for j in range(1, n + 1):
        for h in range(1, i // 2 + 1):
          dp[i][j] = max(dp[i][j], dp[h][j] + dp[i - h][j])
        for w in range(1, j // 2 + 1):
          dp[i][j] = max(dp[i][j], dp[i][w] + dp[i][j - w])

    return dp[m][n]

```

## 2815. Max Pair Sum in an Array_2815.py

```python
class Solution:
  def maxSum(self, nums: List[int]) -> int:
    ans = 0
    # maxNum[i] := the maximum num we met so far with the maximum digit i
    maxNum = [0] * 10

    def getMaxDigit(num: int) -> int:
      maxDigit = 0
      while num > 0:
        maxDigit = max(maxDigit, num % 10)
        num //= 10
      return maxDigit

    for num in nums:
      d = getMaxDigit(num)
      if maxNum[d] > 0:
        ans = max(ans, num + maxNum[d])
      maxNum[d] = max(maxNum[d], num)

    return -1 if ans == 0 else ans

```

## 926. Flip String to Monotone Increasing_926.py

```python
class Solution:
  def minFlipsMonoIncr(self, s: str) -> int:
    # the number of characters to be flilpped to make the substring so far
    # monotone increasing
    dp = 0
    count1 = 0

    for c in s:
      if c == '0':
        # 1. Flip '0'.
        # 2. Keep '0' and flip all the previous 1s.
        dp = min(dp + 1, count1)
      else:
        count1 += 1

    return dp

```

## 1471. The k Strongest Values in an Array_1471.py

```python
class Solution:
  def getStrongest(self, arr: List[int], k: int) -> List[int]:
    arr.sort()

    ans = []
    median = arr[(len(arr) - 1) // 2]
    l = 0
    r = len(arr) - 1

    for _ in range(k):
      if median - arr[l] > arr[r] - median:
        ans.append(arr[l])
        l -= 1
      else:
        ans.append(arr[r])
        r += 1

    return ans

```

## 718. Maximum Length of Repeated Subarray_718.py

```python
class Solution:
  def findLength(self, nums1: List[int], nums2: List[int]) -> int:
    m = len(nums1)
    n = len(nums2)
    ans = 0
    # dp[i][j] := the maximum length of a subarray that appears in both
    # nums1[i..m) and nums2[j..n)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in reversed(range(m)):
      for j in reversed(range(n)):
        if nums1[i] == nums2[j]:
          dp[i][j] = dp[i + 1][j + 1] + 1
          ans = max(ans, dp[i][j])

    return ans

```

## 816. Ambiguous Coordinates_816.py

```python
class Solution:
  def ambiguousCoordinates(self, s: str) -> List[str]:
    def splits(s: str) -> List[str]:
      if not s or len(s) > 1 and s[0] == s[-1] == '0':
        return []
      if s[-1] == '0':
        return [s]
      if s[0] == '0':
        return [s[0] + '.' + s[1:]]
      return [s] + [s[:i] + '.' + s[i:] for i in range(1, len(s))]

    ans = []
    s = s[1:-1]

    for i in range(1, len(s)):
      for x in splits(s[:i]):
        for y in splits(s[i:]):
          ans.append('(%s, %s)' % (x, y))

    return ans

```

## 29. Divide Two Integers_29.py

```python
class Solution:
  def divide(self, dividend: int, divisor: int) -> int:
    # -2^{31} / -1 = 2^31 will overflow, so return 2^31 - 1.
    if dividend == -2**31 and divisor == -1:
      return 2**31 - 1

    sign = -1 if (dividend > 0) ^ (divisor > 0) else 1
    ans = 0
    dvd = abs(dividend)
    dvs = abs(divisor)

    while dvd >= dvs:
      k = 1
      while k * 2 * dvs <= dvd:
        k <<= 1
      dvd -= k * dvs
      ans += k

    return sign * ans

```

## 1682. Longest Palindromic Subsequence II_1682.py

```python
class Solution:
  def longestPalindromeSubseq(self, s: str) -> int:
    n = len(s)

    @functools.lru_cache(None)
    def dp(i: int, j: int, k: int) -> int:
      """
      Returns the length of LPS(s[i..j]), where the previous letter is
      ('a' + k).
      """
      if i >= j:
        return 0
      if s[i] == s[j] and s[i] != chr(ord('a') + k):
        return dp(i + 1, j - 1, ord(s[i]) - ord('a')) + 2
      return max(dp(i + 1, j, k), dp(i, j - 1, k))

    return dp(0, n - 1, 26)

```

## 403. Frog Jump_403.py

```python
class Solution:
  def canCross(self, stones: List[int]) -> bool:
    n = len(stones)
    # dp[i][j] := True if a frog can make a size j jump to stones[i]
    dp = [[False] * (n + 1) for _ in range(n)]
    dp[0][0] = True

    for i in range(1, n):
      for j in range(i):
        k = stones[i] - stones[j]
        if k > n:
          continue
        for x in (k - 1, k, k + 1):
          if 0 <= x <= n:
            dp[i][k] |= dp[j][x]

    return any(dp[-1])

```

## 202. Happy Number_202.py

```python
class Solution:
  def isHappy(self, n: int) -> bool:
    def squaredSum(n: int) -> bool:
      summ = 0
      while n:
        summ += pow(n % 10, 2)
        n //= 10
      return summ

    slow = squaredSum(n)
    fast = squaredSum(squaredSum(n))

    while slow != fast:
      slow = squaredSum(slow)
      fast = squaredSum(squaredSum(fast))

    return slow == 1

```

## 2447. Number of Subarrays With GCD Equal to K_2447.py

```python
class Solution:
  def subarrayGCD(self, nums: List[int], k: int) -> int:
    ans = 0
    gcds = collections.Counter()

    for num in nums:
      if num % k == 0:
        nextGcds = collections.defaultdict(int)
        nextGcds[num] += 1
        for prevGcd, count in gcds.items():
          nextGcds[math.gcd(prevGcd, num)] += count
        ans += nextGcds.get(k, 0)
        gcds = nextGcds
      else:
        # The GCD streak stops, so fresh start from the next number.
        gcds.clear()

    return ans

```

## 1915. Number of Wonderful Substrings_1915.py

```python
class Solution:
  def wonderfulSubstrings(self, word: str) -> int:
    ans = 0
    prefix = 0  # the binary prefix
    count = [0] * 1024  # the binary prefix count
    count[0] = 1  # the empty string ""

    for c in word:
      prefix ^= 1 << ord(c) - ord('a')
      # All the letters occur even number of times.
      ans += count[prefix]
      # `c` occurs odd number of times.
      ans += sum(count[prefix ^ 1 << i] for i in range(10))
      count[prefix] += 1

    return ans

```

## 1595. Minimum Cost to Connect Two Groups of Points_1595.py

```python
class Solution:
  def connectTwoGroups(self, cost: List[List[int]]) -> int:
    # minCosts[j] := the minimum cost of connecting group2's point j
    minCosts = [min(col) for col in zip(*cost)]

    @functools.lru_cache(None)
    def dp(i: int, mask: int) -> int:
      """
      Returns the minimum cost to connect group1's points[i..n) with group2's
      points, where `mask` is the bitmask of the connected points in group2.
      """
      if i == len(cost):
        # All the points in group 1 are connected, so greedily assign the
        # minimum cost for the unconnected points of group2.
        return sum(minCost for j, minCost in enumerate(minCosts)
                   if (mask >> j & 1) == 0)
      return min(cost[i][j] + dp(i + 1, mask | 1 << j)
                 for j in range(len(cost[0])))

    return dp(0, 0)

```

## 1267. Count Servers that Communicate_1267.py

```python
class Solution:
  def countServers(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    ans = 0
    rows = [0] * m
    cols = [0] * n

    for i in range(m):
      for j in range(n):
        if grid[i][j] == 1:
          rows[i] += 1
          cols[j] += 1

    for i in range(m):
      for j in range(n):
        if grid[i][j] == 1 and (rows[i] > 1 or cols[j] > 1):
          ans += 1

    return ans

```

## 221. Maximal Square_221-2.py

```python
class Solution:
  def maximalSquare(self, matrix: List[List[chr]]) -> int:
    m = len(matrix)
    n = len(matrix[0])
    dp = [0] * n
    maxLength = 0
    prev = 0  # dp[i - 1][j - 1]

    for i in range(m):
      for j in range(n):
        cache = dp[j]
        if i == 0 or j == 0 or matrix[i][j] == '0':
          dp[j] = 1 if matrix[i][j] == '1' else 0
        else:
          dp[j] = min([prev, dp[j], dp[j - 1]]) + 1
        maxLength = max(maxLength, dp[j])
        prev = cache

    return maxLength * maxLength

```

## 508. Most Frequent Subtree Sum_508.py

```python
class Solution:
  def findFrequentTreeSum(self, root: Optional[TreeNode]) -> List[int]:
    if not root:
      return []

    count = collections.Counter()

    def dfs(root: Optional[TreeNode]) -> int:
      if not root:
        return 0

      summ = root.val + dfs(root.left) + dfs(root.right)
      count[summ] += 1
      return summ

    dfs(root)
    maxFreq = max(count.values())
    return [summ for summ in count if count[summ] == maxFreq]

```

## 494. Target Sum_494-2.py

```python
class Solution:
  def findTargetSumWays(self, nums: List[int], target: int) -> int:
    summ = sum(nums)
    if summ < abs(target) or (summ + target) % 2 == 1:
      return 0

    def knapsack(nums: List[int], target: int) -> int:
      # dp[i] := the number of ways to sum to i by nums so far
      dp = [0] * (target + 1)
      dp[0] = 1

      for num in nums:
        for i in range(target, num - 1, -1):
          dp[i] += dp[i - num]

      return dp[target]

    return knapsack(nums, (summ + target) // 2)

```

## 2386. Find the K-Sum of an Array_2386.py

```python
class Solution:
  def kSum(self, nums: List[int], k: int) -> int:
    maxSum = sum(num for num in nums if num > 0)
    absNums = sorted(abs(num) for num in nums)
    # (the next maximum sum, the next index i)
    maxHeap = [(-(maxSum - absNums[0]), 0)]
    nextMaxSum = maxSum

    for _ in range(k - 1):
      nextMaxSum, i = heapq.heappop(maxHeap)
      nextMaxSum *= -1
      if i + 1 < len(absNums):
        heapq.heappush(maxHeap, (-(nextMaxSum - absNums[i + 1]), i + 1))
        heapq.heappush(
            maxHeap, (-(nextMaxSum - absNums[i + 1] + absNums[i]), i + 1))

    return nextMaxSum

```

## 3218. Minimum Cost for Cutting Cake I_3218.py

```python
class Solution:
  def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:
    ans = 0
    sumH = sum(horizontalCut)
    sumV = sum(verticalCut)

    horizontalCut.sort()
    verticalCut.sort()

    while horizontalCut and verticalCut:
      if horizontalCut[-1] > verticalCut[-1]:
        ans += horizontalCut[-1] + sumV
        sumH -= horizontalCut.pop()
      else:
        ans += verticalCut[-1] + sumH
        sumV -= verticalCut.pop()

    return ans + sumH + sumV

```

## 3025. Find the Number of Ways to Place People I_3025.py

```python
class Solution:
  def numberOfPairs(self, points: List[List[int]]) -> int:
    ans = 0

    points.sort(key=lambda x: (x[0], -x[1]))

    for i, (_, yi) in enumerate(points):
      maxY = -math.inf
      for j in range(i + 1, len(points)):
        _, yj = points[j]
        # Chisato is in the upper-left corner at (xi, yi), and Takina is in the
        # lower-right corner at (xj, yj). Also, if yj > maxY, it means that
        # nobody other than Chisato and Takina is inside or on the fence.
        if yi >= yj > maxY:
          ans += 1
          maxY = yj

    return ans

```

## 1702. Maximum Binary String After Change_1702.py

```python
class Solution:
  def maximumBinaryString(self, binary: str) -> str:
    #     e.g. binary = '100110'
    # Do Operation 2 -> '100011'
    # Do Operation 1 -> '111011'
    # So, the index of the only '0' is prefixOnes + zeros - 1.
    zeros = binary.count('0')
    prefixOnes = binary.find('0')

    # Make the entire string as 1s.
    ans = ['1'] * len(binary)

    # Make the only '0' if necessary.
    if prefixOnes != -1:
      ans[prefixOnes + zeros - 1] = '0'
    return ''.join(ans)

```

## 2131. Longest Palindrome by Concatenating Two Letter Words_2131.py

```python
class Solution:
  def longestPalindrome(self, words: List[str]) -> int:
    ans = 0
    count = [[0] * 26 for _ in range(26)]

    for a, b in words:
      i = ord(a) - ord('a')
      j = ord(b) - ord('a')
      if count[j][i]:
        ans += 4
        count[j][i] -= 1
      else:
        count[i][j] += 1

    for i in range(26):
      if count[i][i]:
        return ans + 2

    return ans

```

## 2718. Sum of Matrix After Queries_2718.py

```python
class Solution:
  def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:
    ans = 0
    # seen[0] := row, seen[1] := col
    seen = [[False] * n for _ in range(2)]
    # notSet[0] = row, notSet[1] := col
    notSet = [n] * 2

    # Late queries dominate.
    for type, index, val in reversed(queries):
      if not seen[type][index]:
        ans += val * notSet[type ^ 1]
        seen[type][index] = True
        notSet[type] -= 1

    return ans

```

## 110. Balanced Binary Tree_110-3.py

```python
class Solution:
  def isBalanced(self, root: Optional[TreeNode]) -> bool:
    def maxDepth(root: Optional[TreeNode]) -> int:
      """Returns the height of root if root is balanced; otherwise, returns -1."""
      if not root:
        return 0

      left = maxDepth(root.left)
      if left == -1:
        return -1
      right = maxDepth(root.right)
      if right == -1:
        return -1
      if abs(left - right) > 1:
        return -1

      return 1 + max(maxDepth(root.left), maxDepth(root.right))

    return maxDepth(root) != -1

```

## 1836. Remove Duplicates From an Unsorted Linked List_1836.py

```python
class Solution:
  def deleteDuplicatesUnsorted(self, head: ListNode) -> ListNode:
    dummy = ListNode(0, head)
    count = collections.Counter()

    curr = head
    while curr:
      count[curr.val] += 1
      curr = curr.next

    curr = dummy

    while curr:
      while curr.next and curr.next.val in count and count[curr.next.val] > 1:
        curr.next = curr.next.next
      curr = curr.next

    return dummy.next

```

## 1947. Maximum Compatibility Score Sum_1947.py

```python
class Solution:
  def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:
    ans = 0

    def dfs(i: int, scoreSum: int, used: List[bool]) -> None:
      nonlocal ans
      if i == len(students):
        ans = max(ans, scoreSum)
        return

      for j, mentor in enumerate(mentors):
        if used[j]:
          continue
        used[j] = True  # The `mentors[j]` is used.
        dfs(i + 1, scoreSum + sum(s == m
                                  for s, m in zip(students[i], mentor)), used)
        used[j] = False

    dfs(0, 0, [False] * len(students))
    return ans

```

## 2383. Minimum Hours of Training to Win a Competition_2383.py

```python
class Solution:
  def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:
    return self._getRequiredEnergy(initialEnergy, energy) + \
        self._getRequiredExperience(initialExperience, experience)

  def _getRequiredEnergy(self, initialEnergy: int, energy: List[int]) -> int:
    return max(0, sum(energy) + 1 - initialEnergy)

  def _getRequiredExperience(self, currentExperience: int, experience: List[int]) -> int:
    requiredExperience = 0
    for e in experience:
      if e >= currentExperience:
        requiredExperience += e + 1 - currentExperience
        currentExperience += e + 1 - currentExperience
      currentExperience += e
    return requiredExperience

```

## 2200. Find All K-Distant Indices in an Array_2200.py

```python
class Solution:
  def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:
    n = len(nums)
    ans = []

    j = 0
    for i in range(n):
      # the first index j s.t. nums[j] == key and j >= i - k
      while j < n and (nums[j] != key or j < i - k):
        j += 1
      if j == n:
        break
      if abs(i - j) <= k:
        ans.append(i)

    return ans

```

## 2055. Plates Between Candles_2055.py

```python
class Solution:
  def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
    ans = []
    indices = [i for i, c in enumerate(s) if c == '|']  # indices of '|'

    for left, right in queries:
      l = bisect.bisect_left(indices, left)
      r = bisect.bisect_right(indices, right) - 1
      if l < r:
        lengthBetweenCandles = indices[r] - indices[l] + 1
        numCandles = r - l + 1
        ans.append(lengthBetweenCandles - numCandles)
      else:
        ans.append(0)

    return ans

```

## 2533. Number of Good Binary Strings_2533.py

```python
class Solution:
  def goodBinaryStrings(self, minLength: int, maxLength: int, oneGroup: int, zeroGroup: int) -> int:
    kMod = 1_000_000_007
    # dp[i] := the number of good binary strings with length i
    dp = [1] + [0] * maxLength

    for i in range(maxLength + 1):
      # There are good binary strings with length i, so we can append
      # consecutive 0s or 1s after it.
      if dp[i] > 0:
        appendZeros = i + zeroGroup
        if appendZeros <= maxLength:
          dp[appendZeros] += dp[i]
          dp[appendZeros] %= kMod
        appendOnes = i + oneGroup
        if appendOnes <= maxLength:
          dp[appendOnes] += dp[i]
          dp[appendOnes] %= kMod

    return sum(dp[minLength:]) % kMod

```

## 1200. Minimum Absolute Difference_1200.py

```python
class Solution:
  def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:
    ans = []
    mn = math.inf

    arr.sort()

    for a, b in itertools.pairwise(arr):
      diff = b - a
      if diff < mn:
        mn = diff
        ans = []
      if diff == mn:
        ans.append([a, b])

    return ans

```

## 401. Binary Watch_401.py

```python
class Solution:
  def readBinaryWatch(self, turnedOn: int) -> List[str]:
    ans = []
    hours = [1, 2, 4, 8]
    minutes = [1, 2, 4, 8, 16, 32]

    def dfs(turnedOn: int, s: int, h: int, m: int) -> None:
      if turnedOn == 0:
        time = str(h) + ":" + (str(m).zfill(2))
        ans.append(time)
        return

      for i in range(s, len(hours) + len(minutes)):
        if i < 4 and h + hours[i] < 12:
          dfs(turnedOn - 1, i + 1, h + hours[i], m)
        elif i >= 4 and m + minutes[i - 4] < 60:
          dfs(turnedOn - 1, i + 1, h, m + minutes[i - 4])

    dfs(turnedOn, 0, 0, 0)
    return ans

```

## 139. Word Break_139-4.py

```python
class Solution:
  def wordBreak(self, s: str, wordDict: List[str]) -> bool:
    n = len(s)
    maxLength = len(max(wordDict, key=len))
    wordSet = set(wordDict)
    # dp[i] := True if s[0..i) can be segmented
    dp = [True] + [False] * n

    for i in range(1, n + 1):
      for j in reversed(range(i)):
        if i - j > maxLength:
          break
        # s[0..j) can be segmented and s[j..i) is in the wordSet, so s[0..i)
        # can be segmented.
        if dp[j] and s[j:i] in wordSet:
          dp[i] = True
          break

    return dp[n]

```

## 173. Binary Search Tree Iterator_173.py

```python
class BSTIterator:
  def __init__(self, root: Optional[TreeNode]):
    self.i = 0
    self.vals = []
    self._inorder(root)

  def next(self) -> int:
    self.i += 1
    return self.vals[self.i - 1]

  def hasNext(self) -> bool:
    return self.i < len(self.vals)

  def _inorder(self, root: Optional[TreeNode]) -> None:
    if not root:
      return
    self._inorder(root.left)
    self.vals.append(root.val)
    self._inorder(root.right)

```

## 2671. Frequency Tracker_2671.py

```python
class FrequencyTracker:
  def __init__(self):
    self.count = collections.Counter()
    self.freqCount = collections.Counter()

  def add(self, number: int) -> None:
    if self.count[number] > 0:
      self.freqCount[self.count[number]] -= 1
    self.count[number] += 1
    self.freqCount[self.count[number]] += 1

  def deleteOne(self, number: int) -> None:
    if self.count[number] == 0:
      return
    self.freqCount[self.count[number]] -= 1
    self.count[number] -= 1
    self.freqCount[self.count[number]] += 1

  def hasFrequency(self, frequency: int) -> bool:
    return self.freqCount[frequency] > 0

```

## 2698. Find the Punishment Number of an Integer_2698.py

```python
class Solution:
  def punishmentNumber(self, n: int) -> int:
    def isPossible(accumulate: int, running: int, numChars: List[str], s: int, target: int) -> bool:
      """
      Returns True if the sum of any split of `numChars` equals to the target.
      """
      if s == len(numChars):
        return target == accumulate + running
      d = int(numChars[s])
      return (
          # Keep growing `running`.
          isPossible(accumulate, running * 10 + d, numChars, s + 1, target) or
          # Start a new `running`.
          isPossible(accumulate + running, d, numChars, s + 1, target)
      )

    return sum(i * i
               for i in range(1, n + 1)
               if isPossible(0, 0, str(i * i), 0, i))

```

## 135. Candy_135.py

```python
class Solution:
  def candy(self, ratings: List[int]) -> int:
    n = len(ratings)

    ans = 0
    l = [1] * n
    r = [1] * n

    for i in range(1, n):
      if ratings[i] > ratings[i - 1]:
        l[i] = l[i - 1] + 1

    for i in range(n - 2, -1, -1):
      if ratings[i] > ratings[i + 1]:
        r[i] = r[i + 1] + 1

    for a, b in zip(l, r):
      ans += max(a, b)

    return ans

```

## 2830. Maximize the Profit as the Salesman_2830.py

```python
class Solution:
  def maximizeTheProfit(self, n: int, offers: List[List[int]]) -> int:
    # dp[i] := the maximum amount of gold of selling the first i houses
    dp = [0] * (n + 1)
    endToStartAndGolds = [[] for _ in range(n)]

    for start, end, gold in offers:
      endToStartAndGolds[end].append((start, gold))

    for end in range(1, n + 1):
      # Get at least the same gold as selling the first `end - 1` houses.
      dp[end] = dp[end - 1]
      for start, gold in endToStartAndGolds[end - 1]:
        dp[end] = max(dp[end], dp[start] + gold)

    return dp[n]

```

## 3143. Maximum Points Inside the Square_3143.py

```python
class Solution:
  def maxPointsInsideSquare(self, points: List[List[int]], s: str) -> int:
    secondMinSize = math.inf
    minSizes = {}

    for (x, y), c in zip(points, s):
      sz = max(abs(x), abs(y))
      if c not in minSizes:
        minSizes[c] = sz
      elif sz < minSizes[c]:
        # This is because minSizes[j] is about to be replaced by a smaller
        # value, so it becomes a candidate for the second minimum size.
        secondMinSize = min(secondMinSize, minSizes[c])
        minSizes[c] = sz
      else:
        # `sz` is not smaller than the current minimum size, but it could be
        # smaller than the current second minimum size.
        secondMinSize = min(secondMinSize, sz)

    return sum(sz < secondMinSize for sz in minSizes.values())

```

## 3152. Special Array II_3152.py

```python
class Solution:
  def isArraySpecial(self, nums: List[int], queries: List[List[int]]) -> List[bool]:
    ans = []
    id = 0
    # parityIds[i] := the id of the parity group that nums[i] belongs to
    parityIds = [id]

    for a, b in itertools.pairwise(nums):
      if a % 2 == b % 2:
        id += 1
      parityIds.append(id)

    for _from, to in queries:
      ans.append(parityIds[_from] == parityIds[to])

    return ans

```

## 2862. Maximum Element-Sum of a Complete Subset of Indices_2862.py

```python
class Solution:
  def maximumSum(self, nums: List[int]) -> int:
    ans = 0
    oddPowerToSum = collections.Counter()

    def divideSquares(val: int) -> int:
      for num in range(2, val + 1):
        while val % (num * num) == 0:
          val //= (num * num)
      return val

    for i, num in enumerate(nums):
      oddPower = divideSquares(i + 1)
      oddPowerToSum[oddPower] += num
      ans = max(ans, oddPowerToSum[oddPower])

    return ans

```

## 1219. Path with Maximum Gold_1219.py

```python
class Solution:
  def getMaximumGold(self, grid: List[List[int]]) -> int:
    def dfs(i: int, j: int) -> int:
      if i < 0 or j < 0 or i == len(grid) or j == len(grid[0]):
        return 0
      if grid[i][j] == 0:
        return 0

      gold = grid[i][j]
      grid[i][j] = 0  # Mark as visited.
      maxPath = max(dfs(i + 1, j), dfs(i - 1, j),
                    dfs(i, j + 1), dfs(i, j - 1))
      grid[i][j] = gold
      return gold + maxPath

    return max(dfs(i, j)
               for i in range(len(grid))
               for j in range(len(grid[0])))

```

## 1441. Build an Array With Stack Operations_1441.py

```python
class Solution:
  def buildArray(self, target: List[int], n: int) -> List[str]:
    ans = []
    i = 0  # Target pointer
    num = 1  # Curr num

    while i < len(target):
      t = target[i]
      if t == num:
        ans.append("Push")
        i += 1
      else:
        ans.append("Push")
        ans.append("Pop")
      num += 1

    return ans

```

## 823. Binary Trees With Factors_823.py

```python
class Solution:
  def numFactoredBinaryTrees(self, arr: List[int]) -> int:
    kMod = 1_000_000_007
    n = len(arr)
    # dp[i] := the number of binary trees with arr[i] as the root
    dp = [1] * n
    arr.sort()
    numToIndex = {a: i for i, a in enumerate(arr)}

    for i, root in enumerate(arr):  # arr[i] is the root
      for j in range(i):
        if root % arr[j] == 0:  # arr[j] is the left subtree
          right = root // arr[j]
          if right in numToIndex:
            dp[i] += dp[j] * dp[numToIndex[right]]
            dp[i] %= kMod

    return sum(dp) % kMod

```

## 159. Longest Substring with At Most Two Distinct Characters_159.py

```python
class Solution:
  def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:
    ans = 0
    distinct = 0
    count = [0] * 128

    l = 0
    for r, c in enumerate(s):
      count[ord(c)] += 1
      if count[ord(c)] == 1:
        distinct += 1
      while distinct == 3:
        count[ord(s[l])] -= 1
        if count[ord(s[l])] == 0:
          distinct -= 1
        l += 1
      ans = max(ans, r - l + 1)

    return ans

```

## 2256. Minimum Average Difference_2256.py

```python
class Solution:
  def minimumAverageDifference(self, nums: List[int]) -> int:
    n = len(nums)
    ans = 0
    minDiff = inf
    prefix = 0
    suffix = sum(nums)

    for i, num in enumerate(nums):
      prefix += num
      suffix -= num
      prefixAvg = prefix // (i + 1)
      suffixAvg = 0 if i == n - 1 else suffix // (n - 1 - i)
      diff = abs(prefixAvg - suffixAvg)
      if diff < minDiff:
        ans = i
        minDiff = diff

    return ans

```

## 885. Spiral Matrix III_885.py

```python
class Solution:
  def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:
    dx = [1, 0, -1, 0]
    dy = [0, 1, 0, -1]
    ans = [[rStart, cStart]]
    i = 0

    while len(ans) < rows * cols:
      for _ in range(i // 2 + 1):
        rStart += dy[i % 4]
        cStart += dx[i % 4]
        if 0 <= rStart < rows and 0 <= cStart < cols:
          ans.append([rStart, cStart])
      i += 1

    return ans

```

## 987. Vertical Order Traversal of a Binary Tree_987.py

```python
class Solution:
  def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:
    ans = []
    xToNodes = collections.defaultdict(list)

    def dfs(node: Optional[TreeNode], x: int, y: int) -> None:
      if not node:
        return
      xToNodes[x].append((-y, node.val))
      dfs(node.left, x - 1, y - 1)
      dfs(node.right, x + 1, y - 1)

    dfs(root, 0, 0)

    for _, nodes in sorted(xToNodes.items(), key=lambda item: item[0]):
      ans.append([val for _, val in sorted(nodes)])

    return ans

```

## 2368. Reachable Nodes With Restrictions_2368.py

```python
class Solution:
  def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:
    tree = [[] for _ in range(n)]
    seen = set(restricted)

    for u, v in edges:
      tree[u].append(v)
      tree[v].append(u)

    def dfs(u: int) -> int:
      if u in seen:
        return 0
      seen.add(u)
      return 1 + sum(dfs(v) for v in tree[u])

    return dfs(0)

```

## 250. Count Univalue Subtrees_250.py

```python
class Solution:
  def countUnivalSubtrees(self, root: Optional[TreeNode]) -> int:
    ans = 0

    def isUnival(root: Optional[TreeNode], val: int) -> bool:
      nonlocal ans
      if not root:
        return True

      if isUnival(root.left, root.val) & isUnival(root.right, root.val):
        ans += 1
        return root.val == val

      return False

    isUnival(root, math.inf)
    return ans

```

## 1567. Maximum Length of Subarray With Positive Product_1567.py

```python
class Solution:
  def getMaxLen(self, nums: List[int]) -> int:
    ans = 0
    # the maximum length of subarrays ending in `num` with a negative product
    neg = 0
    # the maximum length of subarrays ending in `num` with a positive product
    pos = 0

    for num in nums:
      pos = 0 if num == 0 else pos + 1
      neg = 0 if num == 0 or neg == 0 else neg + 1
      if num < 0:
        pos, neg = neg, pos
      ans = max(ans, pos)

    return ans

```

## 877. Stone Game_877.py

```python
class Solution:
  def stoneGame(self, piles: List[int]) -> bool:
    n = len(piles)
    # dp[i][j] := the maximum stones you can get more than your opponent in piles[i..j]
    dp = [[0] * n for _ in range(n)]

    for i, pile in enumerate(piles):
      dp[i][i] = pile

    for d in range(1, n):
      for i in range(n - d):
        j = i + d
        dp[i][j] = max(piles[i] - dp[i + 1][j],
                       piles[j] - dp[i][j - 1])

    return dp[0][n - 1] > 0

```

## 12. Integer to Roman_12.py

```python
class Solution:
  def intToRoman(self, num: int) -> str:
    valueSymbols = [(1000, 'M'), (900, 'CM'),
                    (500, 'D'), (400, 'CD'),
                    (100, 'C'), (90, 'XC'),
                    (50, 'L'), (40, 'XL'),
                    (10, 'X'), (9, 'IX'),
                    (5, 'V'), (4, 'IV'),
                    (1, 'I')]
    ans = []

    for value, symbol in valueSymbols:
      if num == 0:
        break
      count, num = divmod(num, value)
      ans.append(symbol * count)

    return ''.join(ans)

```

## 1282. Group the People Given the Group Size They Belong To_1282.py

```python
class Solution:
  def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:
    ans = []
    groupSizeToIndices = defaultdict(list)

    for i, groupSize in enumerate(groupSizes):
      groupSizeToIndices[groupSize].append(i)

    for groupSize, indices in groupSizeToIndices.items():
      groupIndices = []
      for index in indices:
        groupIndices.append(index)
        if len(groupIndices) == groupSize:
          ans.append(groupIndices.copy())
          groupIndices.clear()

    return ans

```

## 1358. Number of Substrings Containing All Three Characters_1358.py

```python
class Solution:
  # Similar to 3. Longest SubWithout Repeating Characters
  def numberOfSubstrings(self, s: str) -> int:
    ans = 0
    count = {c: 0 for c in 'abc'}

    l = 0
    for c in s:
      count[c] += 1
      while min(count.values()) > 0:
        count[s[l]] -= 1
        l += 1
      # s[0..r], s[1..r], ..., s[l - 1..r] are satified strings.
      ans += l

    return ans

```

## 1054. Distant Barcodes_1054.py

```python
class Solution:
  def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:
    ans = [0] * len(barcodes)
    count = collections.Counter(barcodes)
    i = 0  # ans' index
    maxNum = max(count, key=count.get)

    def fillAns(num: int) -> None:
      nonlocal i
      while count[num]:
        ans[i] = num
        i = i + 2 if i + 2 < len(barcodes) else 1
        count[num] -= 1

    fillAns(maxNum)
    for num in count.keys():
      fillAns(num)

    return ans

```

## 825. Friends Of Appropriate Ages_825.py

```python
class Solution:
  def numFriendRequests(self, ages: List[int]) -> int:
    ans = 0
    count = [0] * 121

    for age in ages:
      count[age] += 1

    for i in range(15, 121):
      ans += count[i] * (count[i] - 1)

    for i in range(15, 121):
      for j in range(i // 2 + 8, i):
        ans += count[i] * count[j]

    return ans

```

## 1124. Longest Well-Performing Interval_1124.py

```python
class Solution:
  def longestWPI(self, hours: List[int]) -> int:
    ans = 0
    prefix = 0
    dict = {}

    for i in range(len(hours)):
      prefix += 1 if hours[i] > 8 else -1
      if prefix > 0:
        ans = i + 1
      else:
        if prefix not in dict:
          dict[prefix] = i
        if prefix - 1 in dict:
          ans = max(ans, i - dict[prefix - 1])

    return ans

```

## 1560. Most Visited Sector in a Circular Track_1560.py

```python
class Solution:
  def mostVisited(self, n: int, rounds: List[int]) -> List[int]:
    # 1. if start <= end, [start, end] is the most visited.
    #
    #      s --------- n
    # 1 -------------- n
    # 1 ------ e
    #
    # 2. if start > end, [1, end] and [start, n] are the most visited.
    #
    #             s -- n
    # 1 -------------- n
    # 1 ------ e
    start = rounds[0]
    end = rounds[-1]
    if start <= end:
      return range(start, end + 1)
    return list(range(1, end + 1)) + list(range(start, n + 1))

```

## 2218. Maximum Value of K Coins From Piles_2218.py

```python
class Solution:
  def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:
    @functools.lru_cache(None)
    def dp(i: int, k: int) -> int:
      """Returns the maximum value of picking k coins from piles[i..n)."""
      if i == len(piles) or k == 0:
        return 0

      # Pick no coins from the current pile.
      res = dp(i + 1, k)
      val = 0  # the coins picked from the current pile

      # Try to pick 1, 2, ..., k coins from the current pile.
      for j in range(min(len(piles[i]), k)):
        val += piles[i][j]
        res = max(res, val + dp(i + 1, k - j - 1))

      return res

    return dp(0, k)

```

## 2192. All Ancestors of a Node in a Directed Acyclic Graph_2192.py

```python
class Solution:
  def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:
    ans = [[] for _ in range(n)]
    graph = [[] for _ in range(n)]

    for u, v in edges:
      graph[u].append(v)

    def dfs(u: int, ancestor: int, seen: Set[int]) -> None:
      seen.add(u)
      for v in graph[u]:
        if v in seen:
          continue
        ans[v].append(ancestor)
        dfs(v, ancestor, seen)

    for i in range(n):
      dfs(i, i, set())

    return ans

```

## 2310. Sum of Numbers With Units Digit K_2310.py

```python
class Solution:
  def minimumNumbers(self, num: int, k: int) -> int:
    if num == 0:
      return 0

    # Assume the size of the set is n, and the numbers in the set are X1, X2,
    # ..., Xn. Since the units digit of each number is k, X1 + X2 + ... + Xn =
    # N * k + 10 * (x1 + x2 + ... + xn) = num. Therefore, the goal is to find
    # the n s.t. n * k % 10 = num % 10
    for i in range(1, 11):
      if i * k > num + 1:
        break
      if i * k % 10 == num % 10:
        return i

    return -1

```

## 199. Binary Tree Right Side View_199.py

```python
class Solution:
  def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
    if not root:
      return []

    ans = []
    q = collections.deque([root])

    while q:
      size = len(q)
      for i in range(size):
        root = q.popleft()
        if i == size - 1:
          ans.append(root.val)
        if root.left:
          q.append(root.left)
        if root.right:
          q.append(root.right)

    return ans

```

## 983. Minimum Cost For Tickets_983.py

```python
class Solution:
  def mincostTickets(self, days: List[int], costs: List[int]) -> int:
    ans = 0
    last7 = collections.deque()
    last30 = collections.deque()

    for day in days:
      while last7 and last7[0][0] + 7 <= day:
        last7.popleft()
      while last30 and last30[0][0] + 30 <= day:
        last30.popleft()
      last7.append([day, ans + costs[1]])
      last30.append([day, ans + costs[2]])
      ans = min(ans + costs[0], last7[0][1], last30[0][1])

    return ans

```

## 22. Generate Parentheses_22.py

```python
class Solution:
  def generateParenthesis(self, n):
    ans = []

    def dfs(l: int, r: int, s: List[str]) -> None:
      if l == 0 and r == 0:
        ans.append(''.join(s))
      if l > 0:
        s.append('(')
        dfs(l - 1, r, s)
        s.pop()
      if l < r:
        s.append(')')
        dfs(l, r - 1, s)
        s.pop()

    dfs(n, n, [])
    return ans

```

## 1329. Sort the Matrix Diagonally_1329.py

```python
class Solution:
  def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:
    m = len(mat)
    n = len(mat[0])

    count = collections.defaultdict(list)

    for i in range(m):
      for j in range(n):
        count[i - j].append(mat[i][j])

    for value in count.values():
      value.sort(reverse=1)

    for i in range(m):
      for j in range(n):
        mat[i][j] = count[i - j].pop()

    return mat

```

## 1662. Check If Two String Arrays are Equivalent_1662.py

```python
class Solution:
  def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
    i = 0  # word1's index
    j = 0  # word2's index
    a = 0  # word1[i]'s index
    b = 0  # word2[j]'s index

    while i < len(word1) and j < len(word2):
      if word1[i][a] != word2[j][b]:
        return False
      a += 1
      if a == len(word1[i]):
        i += 1
        a = 0
      b += 1
      if b == len(word2[j]):
        j += 1
        b = 0

    return i == len(word1) and j == len(word2)

```

## 2151. Maximum Good People Based on Statements_2151-2.py

```python
class Solution:
  def maximumGood(self, statements: List[List[int]]) -> int:
    n = len(statements)

    def isValid(mask: int) -> bool:
      for i in range(n):
        # The i-th person is bad, so no need to check.
        if (mask >> i & 1) == 0:
          continue
        for j in range(n):
          if statements[i][j] == 2:
            continue
          if statements[i][j] != (mask >> j & 1):
            return False
      return True

    return max(mask.bit_count()
               for mask in range(1 << n)
               if isValid(mask))

```

## 1419. Minimum Number of Frogs Croaking_1419.py

```python
class Solution:
  def minNumberOfFrogs(self, croakOfFrogs: str) -> int:
    kCroak = 'croak'
    ans = 0
    frogs = 0
    count = [0] * 5

    for c in croakOfFrogs:
      count[kCroak.index(c)] += 1
      if any(count[i] > count[i - 1] for i in range(1, 5)):
        return -1
      if c == 'c':
        frogs += 1
      elif c == 'k':
        frogs -= 1
      ans = max(ans, frogs)

    return ans if frogs == 0 else -1

```

## 715. Range Module_715-3.py

```python
class RangeModule:
  def __init__(self):
    self.A = []

  def addRange(self, left: int, right: int) -> None:
    i = bisect_left(self.A, left)
    j = bisect_right(self.A, right)
    self.A[i:j] = [left] * (i % 2 == 0) + [right] * (j % 2 == 0)

  def queryRange(self, left: int, right: int) -> bool:
    i = bisect_right(self.A, left)
    j = bisect_left(self.A, right)
    return i == j and i % 2 == 1

  def removeRange(self, left: int, right: int) -> None:
    i = bisect_left(self.A, left)
    j = bisect_right(self.A, right)
    self.A[i:j] = [left] * (i % 2 == 1) + [right] * (j % 2 == 1)

```

## 1493. Longest Subarray of 1's After Deleting One Element_1493.py

```python
class Solution:
  def longestSubarray(self, nums: List[int]) -> int:
    ans = 0
    count0 = 0

    l = 0
    for r, num in enumerate(nums):
      if num == 0:
        count0 += 1
      while count0 == 2:
        if nums[l] == 0:
          count0 -= 1
        l += 1
      ans = max(ans, r - l)

    return ans

```

## 1695. Maximum Erasure Value_1695.py

```python
class Solution:
  def maximumUniqueSubarray(self, nums: List[int]) -> int:
    ans = 0
    score = 0
    seen = set()

    l = 0
    for r, num in enumerate(nums):
      while num in seen:
        score -= nums[l]
        seen.remove(nums[l])
        l += 1
      seen.add(nums[r])
      score += nums[r]
      ans = max(ans, score)

    return ans

```

## 2906. Construct Product Matrix_2906.py

```python
class Solution:
  def constructProductMatrix(self, grid: List[List[int]]) -> List[List[int]]:
    kMod = 12345
    m = len(grid)
    n = len(grid[0])
    ans = [[0] * n for _ in range(m)]
    prefix = [1]
    suffix = 1

    for row in grid:
      for cell in row:
        prefix.append(prefix[-1] * cell % kMod)

    for i in reversed(range(m)):
      for j in reversed(range(n)):
        ans[i][j] = prefix[i * n + j] * suffix % kMod
        suffix = suffix * grid[i][j] % kMod

    return ans

```

## 682. Baseball Game_682.py

```python
class Solution:
  def calPoints(self, operations: List[str]) -> int:
    scores = []

    for operation in operations:
      match operation:
        case '+':
          scores.append(scores[-1] + scores[-2])
        case 'D':
          scores.append(scores[-1] * 2)
        case 'C':
          scores.pop()
        case default:
          scores.append(int(operation))

    return sum(scores)

```

## 198. House Robber_198.py

```python
class Solution:
  def rob(self, nums: List[int]) -> int:
    if not nums:
      return 0
    if len(nums) == 1:
      return nums[0]

    # dp[i]:= max money of robbing nums[0..i]
    dp = [0] * len(nums)
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])

    for i in range(2, len(nums)):
      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])

    return dp[-1]

```

## 1694. Reformat Phone Number_1694.py

```python
class Solution:
  def reformatNumber(self, number: str) -> str:
    ans = []

    number = number.replace("-", "").replace(" ", "")

    i = 0  # number's index
    while i + 4 < len(number):
      ans.append(number[i:i + 3] + '-')
      i += 3

    countFinalDigits = len(number) - i
    if countFinalDigits < 4:
      ans.append(number[i:])
    else:  # countFinalDigits == 4
      ans.append(number[i:i + 2] + '-' + number[i + 2:])

    return ''.join(ans)

```

## 2226. Maximum Candies Allocated to K Children_2226.py

```python
class Solution:
  def maximumCandies(self, candies: List[int], k: int) -> int:
    l = 1
    r = sum(candies) // k

    def numChildren(m: int) -> bool:
      return sum(c // m for c in candies)

    while l < r:
      m = (l + r) // 2
      if numChildren(m) < k:
        r = m
      else:
        l = m + 1

    return l if numChildren(l) >= k else l - 1

```

## 1417. Reformat The String_1417.py

```python
class Solution:
  def reformat(self, s: str) -> str:
    A = [c for c in s if c.isalpha()]
    B = [c for c in s if c.isdigit()]

    if len(A) < len(B):
      A, B = B, A
    if len(A) - len(B) > 1:
      return ''

    ans = []

    for i in range(len(B)):
      ans.append(A[i])
      ans.append(B[i])

    if len(A) == len(B) + 1:
      ans.append(A[-1])
    return ''.join(ans)

```

## 851. Loud and Rich_851.py

```python
class Solution:
  def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:
    graph = [[] for _ in range(len(quiet))]

    for v, u in richer:
      graph[u].append(v)

    @functools.lru_cache(None)
    def dfs(u: int) -> int:
      ans = u

      for v in graph[u]:
        res = dfs(v)
        if quiet[res] < quiet[ans]:
          ans = res

      return ans

    return map(dfs, range(len(graph)))

```

## 3105. Longest Strictly Increasing or Strictly Decreasing Subarray_3105.py

```python
class Solution:
  # Similar to 978. Longest Turbulent Subarray
  def longestMonotonicSubarray(self, nums: List[int]) -> int:
    ans = 1
    increasing = 1
    decreasing = 1

    for i in range(1, len(nums)):
      if nums[i] > nums[i - 1]:
        increasing += 1
        decreasing = 1
      elif nums[i] < nums[i - 1]:
        decreasing += 1
        increasing = 1
      else:
        increasing = 1
        decreasing = 1
      ans = max(ans, increasing, decreasing)

    return ans

```

## 494. Target Sum_494.py

```python
class Solution:
  def findTargetSumWays(self, nums: List[int], target: int) -> int:
    summ = sum(nums)
    if summ < abs(target) or (summ + target) % 2 == 1:
      return 0

    def knapsack(target: int) -> int:
      # dp[i] := the number of ways to sum to i by nums so far
      dp = [1] + [0] * summ

      for num in nums:
        for j in range(summ, num - 1, -1):
          dp[j] += dp[j - num]

      return dp[target]

    return knapsack((summ + target) // 2)

```

## 2896. Apply Operations to Make Two Strings Equal_2896-2.py

```python
class Solution:
  def minOperations(self, s1: str, s2: str, x: int) -> int:
    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))
                   if a != b]
    if not diffIndices:
      return 0
    # It's impossible to make two strings equal if there are odd number of
    # differences.
    if len(diffIndices) & 1:
      return -1

    # dp[i] := the minimum cost to correct diffIndices[i:]
    dp = [math.inf] * len(diffIndices) + [0]
    dp[-2] = x / 2

    for i in reversed(range(len(diffIndices) - 1)):
      dp[i] = min(dp[i + 1] + x / 2,
                  dp[i + 2] + diffIndices[i + 1] - diffIndices[i])

    return int(dp[0])

```

## 2808. Minimum Seconds to Equalize a Circular Array_2808.py

```python
class Solution:
  def minimumSeconds(self, nums: List[int]) -> int:
    n = len(nums)
    ans = n
    numToIndices = collections.defaultdict(list)

    for i, num in enumerate(nums):
      numToIndices[num].append(i)

    def getSeconds(i: int, j: int) -> int:
      """Returns the number of seconds required to make nums[i..j] the same."""
      return (i - j) // 2

    for indices in numToIndices.values():
      seconds = getSeconds(indices[0] + n, indices[-1])
      for i in range(1, len(indices)):
        seconds = max(seconds, getSeconds(indices[i], indices[i - 1]))
      ans = min(ans, seconds)

    return ans

```

## 1247. Minimum Swaps to Make Strings Equal_1247.py

```python
class Solution:
  def minimumSwap(self, s1: str, s2: str) -> int:
    # ('xx', 'yy') = (2 'xy's) . 1 swap
    # ('yy', 'xx') = (2 'yx's) . 1 swap
    # ('xy', 'yx') = (1 'xy' and 1 'yx') . 2 swaps
    xy = 0  # the number of indices i's s.t. s1[i] = 'x' and s2[i] 'y'
    yx = 0  # the number of indices i's s.t. s1[i] = 'y' and s2[i] 'x'

    for a, b in zip(s1, s2):
      if a == b:
        continue
      if a == 'x':
        xy += 1
      else:
        yx += 1

    if (xy + yx) % 2 == 1:
      return -1
    return xy // 2 + yx // 2 + (0 if xy % 2 == 0 else 2)

```

## 416. Partition Equal Subset Sum_416-2.py

```python
class Solution:
  def canPartition(self, nums: List[int]) -> bool:
    summ = sum(nums)
    if summ % 2 == 1:
      return False
    return self.knapsack_(nums, summ // 2)

  def knapsack_(self, nums: List[int], subsetSum: int) -> bool:
    # dp[i] := True if i can be formed by nums so far
    dp = [False] * (subsetSum + 1)
    dp[0] = True

    for num in nums:
      for i in range(subsetSum, num - 1, -1):
        dp[i] = dp[i] or dp[i - num]

    return dp[subsetSum]

```

## 2512. Reward Top K Students_2512.py

```python
class Solution:
  def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:
    scoreAndIds = []
    pos = set(positive_feedback)
    neg = set(negative_feedback)

    for sid, r in zip(student_id, report):
      score = 0
      for word in r.split():
        if word in pos:
          score += 3
        if word in neg:
          score -= 1
      scoreAndIds.append((-score, sid))

    return [sid for _, sid in sorted(scoreAndIds)[:k]]

```

## 1176. Diet Plan Performance_1176.py

```python
class Solution:
  def dietPlanPerformance(self, calories: List[int], k: int, lower: int, upper: int) -> int:
    ans = 0
    summ = 0

    for i, calorie in enumerate(calories):
      summ += calorie
      if i < k - 1:
        continue
      if i >= k:
        summ -= calories[i - k]
      if summ < lower:
        ans -= 1
      elif summ > upper:
        ans += 1

    return ans

```

## 543. Diameter of Binary Tree_543.py

```python
class Solution:
  def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
    ans = 0

    def maxDepth(root: Optional[TreeNode]) -> int:
      nonlocal ans
      if not root:
        return 0

      l = maxDepth(root.left)
      r = maxDepth(root.right)
      ans = max(ans, l + r)
      return 1 + max(l, r)

    maxDepth(root)
    return ans

```

## 340. Longest Substring with At Most K Distinct Characters_340.py

```python
class Solution:
  def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:
    ans = 0
    distinct = 0
    count = collections.Counter()

    l = 0
    for r, c in enumerate(s):
      count[c] += 1
      if count[c] == 1:
        distinct += 1
      while distinct == k + 1:
        count[s[l]] -= 1
        if count[s[l]] == 0:
          distinct -= 1
        l += 1
      ans = max(ans, r - l + 1)

    return ans

```

## 2929. Distribute Candies Among Children II_2929.py

```python
class Solution:
  def distributeCandies(self, n: int, limit: int) -> int:
    def ways(n: int) -> int:
      """Returns the number of ways to distribute n candies to 3 children."""
      if n < 0:
        return 0
      # Stars and bars method:
      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where
      # stars (*) := candies and bars (|) := dividers between children.
      return math.comb(n + 2, 2)

    limitPlusOne = limit + 1
    oneChildExceedsLimit = ways(n - limitPlusOne)
    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)
    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)
    # Principle of Inclusion-Exclusion (PIE)
    return ways(n) \
        - 3 * oneChildExceedsLimit \
        + 3 * twoChildrenExceedLimit \
        - threeChildrenExceedLimit

```

## 115. Distinct Subsequences_115.py

```python
class Solution:
  def numDistinct(self, s: str, t: str) -> int:
    m = len(s)
    n = len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m + 1):
      dp[i][0] = 1

    for i in range(1, m + 1):
      for j in range(1, n + 1):
        if s[i - 1] == t[j - 1]:
          dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
        else:
          dp[i][j] = dp[i - 1][j]

    return dp[m][n]

```

## 2327. Number of People Aware of a Secret_2327.py

```python
class Solution:
  def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:
    kMod = 1_000_000_007
    share = 0
    # dp[i] := the number of people know the secret at day i
    dp = [0] * n  # Maps day i to i + 1.
    dp[0] = 1

    for i in range(1, n):
      if i - delay >= 0:
        share += dp[i - delay]
      if i - forget >= 0:
        share -= dp[i - forget]
      share += kMod
      share %= kMod
      dp[i] = share

    # People before day `n - forget - 1` already forget the secret.
    return sum(dp[-forget:]) % kMod

```

## 3209. Number of Subarrays With AND Value of K_3209.py

```python
class Solution:
  # Similar to 1521. Find a Value of a Mysterious Function Closest to Target
  def countSubarrays(self, nums: List[int], k: int) -> int:
    ans = 0
    # the counter of all the values of subarrays that end in the previous
    # number
    prev = collections.Counter()

    for num in nums:
      # Extend each subarray that ends in the previous number. Due to
      # monotonicity of the AND operation, the size of `curr` will be at most
      # num.bit_count() + 1.
      curr = collections.Counter({num: 1})
      for val, freq in prev.items():
        curr[val & num] += freq
      ans += curr[k]
      prev = curr

    return ans

```

## 1079. Letter Tile Possibilities_1079.py

```python
class Solution:
  def numTilePossibilities(self, tiles: str) -> int:
    count = collections.Counter(tiles)

    def dfs(count: Dict[int, int]) -> int:
      possibleSequences = 0

      for k, v in count.items():
        if v == 0:
          continue
        # Put c in the current position. We only care about the number of possible
        # sequences of letters but don't care about the actual combination.
        count[k] -= 1
        possibleSequences += 1 + dfs(count)
        count[k] += 1

      return possibleSequences

    return dfs(count)

```

## 1964. Find the Longest Valid Obstacle Course at Each Position_1964.py

```python
class Solution:
  # Similar to 300. Longest Increasing Subsequence
  def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:
    ans = []
    # tail[i] := the minimum tail of all the increasing subsequences having
    # length i + 1
    tail = []

    for obstacle in obstacles:
      if not tail or obstacle >= tail[-1]:
        tail.append(obstacle)
        ans.append(len(tail))
      else:
        index = bisect.bisect_right(tail, obstacle)
        tail[index] = obstacle
        ans.append(index + 1)

    return ans

```

## 2928. Distribute Candies Among Children I_2928.py

```python
class Solution:
  def distributeCandies(self, n: int, limit: int) -> int:
    def ways(n: int) -> int:
      """Returns the number of ways to distribute n candies to 3 children."""
      if n < 0:
        return 0
      # Stars and bars method:
      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where
      # stars (*) := candies and bars (|) := dividers between children.
      return math.comb(n + 2, 2)

    limitPlusOne = limit + 1
    oneChildExceedsLimit = ways(n - limitPlusOne)
    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)
    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)
    # Principle of Inclusion-Exclusion (PIE)
    return ways(n) \
        - 3 * oneChildExceedsLimit \
        + 3 * twoChildrenExceedLimit \
        - threeChildrenExceedLimit

```

## 388. Longest Absolute File Path_388.py

```python
class Solution:
  def lengthLongestPath(self, input: str) -> int:
    ans = 0
    stack = [(-1, 0)]  # placeholder

    for token in input.split('\n'):
      depth = token.count('\t')
      token = token.replace('\t', '')
      while depth <= stack[-1][0]:
        stack.pop()
      if '.' in token:  # `token` is file.
        ans = max(ans, stack[-1][1] + len(token))
      else:  # directory + '/'
        stack.append((depth, stack[-1][1] + len(token) + 1))

    return ans

```

## 801. Minimum Swaps To Make Sequences Increasing_801.py

```python
class Solution:
  def minSwap(self, nums1: List[int], nums2: List[int]) -> int:
    keepAt = [math.inf] * len(nums1)
    swapAt = [math.inf] * len(nums1)
    keepAt[0] = 0
    swapAt[0] = 1

    for i in range(1, len(nums1)):
      if nums1[i] > nums1[i - 1] and nums2[i] > nums2[i - 1]:
        keepAt[i] = keepAt[i - 1]
        swapAt[i] = swapAt[i - 1] + 1
      if nums1[i] > nums2[i - 1] and nums2[i] > nums1[i - 1]:
        keepAt[i] = min(keepAt[i], swapAt[i - 1])
        swapAt[i] = min(swapAt[i], keepAt[i - 1] + 1)

    return min(keepAt[-1], swapAt[-1])

```

## 43. Multiply Strings_43.py

```python
class Solution:
  def multiply(self, num1: str, num2: str) -> str:
    s = [0] * (len(num1) + len(num2))

    for i in reversed(range(len(num1))):
      for j in reversed(range(len(num2))):
        mult = int(num1[i]) * int(num2[j])
        summ = mult + s[i + j + 1]
        s[i + j] += summ // 10
        s[i + j + 1] = summ % 10

    for i, c in enumerate(s):
      if c != 0:
        break

    return ''.join(map(str, s[i:]))

```

## 719. Find K-th Smallest Pair Distance_719.py

```python
class Solution:
  def smallestDistancePair(self, nums: List[int], k: int) -> int:
    nums.sort()

    def numPairDistancesNoGreaterThan(m: int) -> int:
      count = 0
      j = 1
      # For each index i, find the first index j s.t. nums[j] > nums[i] + m,
      # so numPairDistancesNoGreaterThan for the index i will be j - i - 1.
      for i, num in enumerate(nums):
        while j < len(nums) and nums[j] <= num + m:
          j += 1
        count += j - i - 1
      return count

    return bisect.bisect_left(
        range(0, nums[-1] - nums[0]), k,
        key=lambda m: numPairDistancesNoGreaterThan(m))

```

## 1066. Campus Bikes II_1066.py

```python
class Solution:
  def assignBikes(self, workers: List[List[int]], bikes: List[List[int]]) -> int:
    def dist(p1: List[int], p2: List[int]) -> int:
      return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

    @functools.lru_cache(None)
    def dp(workerIndex: int, used: int) -> int:
      """
      Returns the minimum Manhattan distances to assign bikes to
      workers[workerIndex..n), where `used` is the bitmask of the used bikes.
      """
      if workerIndex == len(workers):
        return 0
      return min((dist(workers[workerIndex], bike) + dp(workerIndex + 1, used | 1 << i)
                  for i, bike in enumerate(bikes)
                  if not used >> i & 1), default=math.inf)

    return dp(0, 0)

```

## 2557. Maximum Number of Integers to Choose From a Range II_2557.py

```python
class Solution:
  def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:
    bannedSet = set(banned)
    l = 1
    r = n

    while l < r:
      m = (l + r + 1) // 2
      if self._getSum(bannedSet, m) > maxSum:
        r = m - 1
      else:
        l = m

    return l - sum(b <= l for b in banned)

  # Returns sum([1..m]) - sum(bannedSet).
  def _getSum(self, bannedSet: Set[int], m: int) -> int:
    return m * (m + 1) // 2 - sum(b for b in bannedSet if b <= m)

```

## 2434. Using a Robot to Print the Lexicographically Smallest String_2434.py

```python
class Solution:
  def robotWithString(self, s: str) -> str:
    ans = []
    count = collections.Counter(s)
    stack = []

    for c in s:
      stack.append(c)
      count[c] -= 1
      minChar = self._getMinChar(count)
      while stack and stack[-1] <= minChar:
        ans.append(stack.pop())

    return ''.join(ans + stack[::-1])

  def _getMinChar(self, count: List[int]) -> str:
    for c in string.ascii_lowercase:
      if count[c]:
        return c
    return 'a'

```

## 1696. Jump Game VI_1696.py

```python
class Solution:
  def maxResult(self, nums: List[int], k: int) -> int:
    # Stores dp[i] within the bounds.
    maxQ = collections.deque([0])
    # dp[i] := the maximum score to consider nums[0..i]
    dp = [0] * len(nums)
    dp[0] = nums[0]

    for i in range(1, len(nums)):
      # Pop the index if it's out-of-bounds.
      if maxQ[0] + k < i:
        maxQ.popleft()
      dp[i] = dp[maxQ[0]] + nums[i]
      # Pop indices that won't be chosen in the future.
      while maxQ and dp[maxQ[-1]] <= dp[i]:
        maxQ.pop()
      maxQ.append(i)

    return dp[-1]

```

## 1461. Check If a String Contains All Binary Codes of Size K_1461.py

```python
class Solution:
  def hasAllCodes(self, s: str, k: int) -> bool:
    n = 1 << k
    if len(s) < n:
      return False

    # used[i] := True if i is a substring of `s`
    used = [0] * n

    windowStr = 0 if k == 1 else int(s[0:k - 1], 2)
    for i in range(k - 1, len(s)):
      # Include the s[i].
      windowStr = (windowStr << 1) + int(s[i])
      # Discard the s[i - k].
      windowStr &= n - 1
      used[windowStr] = True

    return all(u for u in used)

```

## 756. Pyramid Transition Matrix_756.py

```python
class Solution:
  def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:
    prefixToBlocks = collections.defaultdict(list)

    for a in allowed:
      prefixToBlocks[a[:2]].append(a[2])

    def dfs(row: str, nextRow: str, i: int) -> bool:
      if len(row) == 1:
        return True
      if len(nextRow) + 1 == len(row):
        return dfs(nextRow, '', 0)

      for c in prefixToBlocks[row[i:i + 2]]:
        if dfs(row, nextRow + c, i + 1):
          return True

      return False

    return dfs(bottom, '', 0)

```

## 2288. Apply Discount to Prices_2288.py

```python
class Solution:
  def discountPrices(self, sentence: str, discount: int) -> str:
    kPrecision = 2
    ans = []

    for word in sentence.split():
      if word[0] == '$' and len(word) > 1:
        digits = word[1:]
        if all(digit.isdigit() for digit in digits):
          val = float(digits) * (100 - discount) / 100
          s = f'{val:.2f}'
          trimmed = s[:s.index('.') + kPrecision + 1]
          ans.append('$' + trimmed)
        else:
          ans.append(word)
      else:
        ans.append(word)

    return ' '.join(ans)

```

## 1838. Frequency of the Most Frequent Element_1838.py

```python
class Solution:
  def maxFrequency(self, nums: List[int], k: int) -> int:
    ans = 0
    summ = 0

    nums.sort()

    l = 0
    for r, num in enumerate(nums):
      summ += num
      while summ + k < num * (r - l + 1):
        summ -= nums[l]
        l += 1
      ans = max(ans, r - l + 1)

    return ans

```

## 1008. Construct Binary Search Tree from Preorder Traversal_1008.py

```python
class Solution:
  def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:
    root = TreeNode(preorder[0])
    stack = [root]

    for i in range(1, len(preorder)):
      parent = stack[-1]
      child = TreeNode(preorder[i])
      # Adjust the parent.
      while stack and stack[-1].val < child.val:
        parent = stack.pop()
      # Create parent-child link according to BST property.
      if parent.val > child.val:
        parent.left = child
      else:
        parent.right = child
      stack.append(child)

    return root

```

## 2905. Find Indices With Index and Value Difference II_2905.py

```python
class Solution:
  def findIndices(self, nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:
    # nums[minIndex] := the minimum number with enough index different from the current number
    minIndex = 0
    # nums[maxIndex] := the maximum number with enough index different from the current number
    maxIndex = 0

    for i in range(indexDifference, len(nums)):
      if nums[i - indexDifference] < nums[minIndex]:
        minIndex = i - indexDifference
      if nums[i - indexDifference] > nums[maxIndex]:
        maxIndex = i - indexDifference
      if nums[i] - nums[minIndex] >= valueDifference:
        return [i, minIndex]
      if nums[maxIndex] - nums[i] >= valueDifference:
        return [i, maxIndex]

    return [-1, -1]

```

## 107. Binary Tree Level Order Traversal II_107.py

```python
class Solution:
  def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
    if not root:
      return []

    ans = []
    q = collections.deque([root])

    while q:
      currLevel = []
      for _ in range(len(q)):
        node = q.popleft()
        currLevel.append(node.val)
        if node.left:
          q.append(node.left)
        if node.right:
          q.append(node.right)
      ans.append(currLevel)

    return ans[::-1]

```

## 2742. Painting the Walls_2742.py

```python
class Solution:
  def paintWalls(self, cost: List[int], time: List[int]) -> int:
    n = len(cost)

    @functools.lru_cache(None)
    def dp(i: int, walls: int) -> int:
      """Returns the minimum cost to paint j walls by painters[i..n)."""
      if walls <= 0:
        return 0
      if i == n:
        return math.inf
      pick = cost[i] + dp(i + 1, walls - time[i] - 1)
      skip = dp(i + 1, walls)
      return min(pick, skip)

    return dp(0, n)

```

## 948. Bag of Tokens_948.py

```python
class Solution:
  def bagOfTokensScore(self, tokens: List[int], power: int) -> int:
    ans = 0
    score = 0
    q = collections.deque(sorted(tokens))

    while q and (power >= q[0] or score):
      while q and power >= q[0]:
        # Play the smallest face up.
        power -= q.popleft()
        score += 1
      ans = max(ans, score)
      if q and score:
        # Play the largest face down.
        power += q.pop()
        score -= 1

    return ans

```

## 978. Longest Turbulent Subarray_978.py

```python
class Solution:
  def maxTurbulenceSize(self, arr: List[int]) -> int:
    ans = 1
    increasing = 1
    decreasing = 1

    for i in range(1, len(arr)):
      if arr[i] > arr[i - 1]:
        increasing = decreasing + 1
        decreasing = 1
      elif arr[i] < arr[i - 1]:
        decreasing = increasing + 1
        increasing = 1
      else:
        increasing = 1
        decreasing = 1
      ans = max(ans, max(increasing, decreasing))

    return ans

```

## 369. Plus One Linked List_369-2.py

```python
class Solution:
  def plusOne(self, head: ListNode) -> ListNode:
    dummy = ListNode(0)
    curr = dummy
    dummy.next = head

    while head:
      if head.val != 9:
        curr = head
      head = head.next
    # `curr` now points to the rightmost non-9 node.

    curr.val += 1
    while curr.next:
      curr.next.val = 0
      curr = curr.next

    return dummy.next if dummy.val == 0 else dummy

```

## 2403. Minimum Time to Kill All Monsters_2403.py

```python
class Solution:
  def minimumTime(self, power: List[int]) -> int:
    n = len(power)
    maxMask = 1 << n
    # dp[i] := the minimum number of days needed to defeat the monsters, where
    # i is the bitmask of the monsters
    dp = [math.inf] * maxMask
    dp[0] = 0

    for mask in range(1, maxMask):
      currentGain = mask.bit_count()
      for i in range(n):
        if mask >> i & 1:
          dp[mask] = min(dp[mask], dp[mask & ~(1 << i)] +
                         int(math.ceil(power[i] / currentGain)))

    return dp[-1]

```

## 2842. Count K-Subsequences of a String With Maximum Beauty Solved_2842.py

```python
class Solution:
  def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -> int:
    kMod = 1_000_000_007
    count = collections.Counter(s)
    if len(count) < k:
      return 0

    ans = 1
    # freqCount := (f(c), # of chars with f(c))
    freqCount = collections.Counter(count.values())

    for fc, numOfChars in list(sorted(freqCount.items(), reverse=True)):
      if numOfChars >= k:
        ans *= math.comb(numOfChars, k) * pow(fc, k, kMod)
        return ans % kMod
      ans *= pow(fc, numOfChars, kMod)
      ans %= kMod
      k -= numOfChars

```

## 1104. Path In Zigzag Labelled Binary Tree_1104.py

```python
class Solution:
  def pathInZigZagTree(self, label: int) -> List[int]:
    def boundarySum(level: int):
      return 2**level + 2**(level + 1) - 1

    ans = []

    for l in range(21):
      if 2**l > label:
        level = l - 1
        break

    if level % 2 == 1:
      label = boundarySum(level) - label

    for l in reversed(range(level + 1)):
      ans.append(label if l % 2 == 0 else boundarySum(l) - label)
      label //= 2

    return ans[::-1]

```

## 321. Create Maximum Number_321.py

```python
class Solution:
  def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
    def maxArray(nums: List[int], k: int) -> List[int]:
      res = []
      toTop = len(nums) - k
      for num in nums:
        while res and res[-1] < num and toTop > 0:
          res.pop()
          toTop -= 1
        res.append(num)
      return res[:k]

    def merge(nums1: List[int], nums2: List[int]) -> List[int]:
      return [max(nums1, nums2).pop(0) for _ in nums1 + nums2]

    return max(merge(maxArray(nums1, i), maxArray(nums2, k - i))
               for i in range(k + 1)
               if i <= len(nums1) and k - i <= len(nums2))

```

## 2209. Minimum White Tiles After Covering With Carpets_2209.py

```python
class Solution:
  def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:
    kMax = 1000

    @functools.lru_cache(None)
    def dp(i: int, j: int) -> int:
      """
      Returns the minimum number of visible white tiles of floor[i..n) after
      covering at most j carpets.
      """
      if j < 0:
        return kMax
      if i >= len(floor):
        return 0
      return min(dp(i + carpetLen, j - 1),
                 dp(i + 1, j) + int(floor[i]))

    return dp(0, numCarpets)

```

## 1363. Largest Multiple of Three_1363.py

```python
class Solution:
  def largestMultipleOfThree(self, digits: List[int]) -> str:
    ans = ''
    mod1 = [1, 4, 7, 2, 5, 8]
    mod2 = [2, 5, 8, 1, 4, 7]
    count = collections.Counter(digits)
    summ = sum(digits)

    while summ % 3 != 0:
      for digit in (mod1 if summ % 3 == 1 else mod2):
        if count[digit]:
          count[digit] -= 1
          summ -= digit
          break

    for digit in reversed(range(10)):
      ans += str(digit) * count[digit]

    return '0' if len(ans) and ans[0] == '0' else ans

```

## 2841. Maximum Sum of Almost Unique Subarray_2841.py

```python
class Solution:
  def maxSum(self, nums: List[int], m: int, k: int) -> int:
    ans = 0
    summ = 0
    count = collections.Counter()

    for i, num in enumerate(nums):
      summ += num
      count[num] += 1
      if i >= k:
        numToRemove = nums[i - k]
        summ -= numToRemove
        count[numToRemove] -= 1
        if count[numToRemove] == 0:
          del count[numToRemove]
      if len(count) >= m:
        ans = max(ans, summ)

    return ans

```

## 2410. Maximum Matching of Players With Trainers_2410.py

```python
class Solution:
  def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:
    ans = 0

    players.sort()
    trainers.sort()

    for i, trainer in enumerate(trainers):
      if players[ans] <= trainers[i]:
        ans += 1
        if ans == len(players):
          return ans

    return ans



```

## 3157. Find the Level of Tree with Minimum Sum_3157-2.py

```python
class Solution:
  # Similar to 1161. Maximum Level Sum of a Binary Tree
  def minimumLevel(self, root: Optional[TreeNode]) -> int:
    # levelSums[i] := the sum of level (i + 1) (1-indexed)
    levelSums = []

    def dfs(root: Optional[TreeNode], level: int) -> None:
      if not root:
        return
      if len(levelSums) == level:
        levelSums.append(0)
      levelSums[level] += root.val
      dfs(root.left, level + 1)
      dfs(root.right, level + 1)

    dfs(root, 0)
    return 1 + levelSums.index(min(levelSums))

```

## 1498. Number of Subsequences That Satisfy the Given Sum Condition_1498.py

```python
class Solution:
  def numSubseq(self, nums: List[int], target: int) -> int:
    kMod = 1_000_000_007
    n = len(nums)
    ans = 0

    nums.sort()

    l = 0
    r = n - 1
    while l <= r:
      if nums[l] + nums[r] <= target:
        ans += pow(2, r - l, kMod)
        l += 1
      else:
        r -= 1

    return ans % kMod

```

## 1429. First Unique Number_1429.py

```python
class FirstUnique:
  def __init__(self, nums: List[int]):
    self.seen = set()
    self.unique = {}
    for num in nums:
      self.add(num)

  def showFirstUnique(self) -> int:
    return next(iter(self.unique), -1)

  def add(self, value: int) -> None:
    if value not in self.seen:
      self.seen.add(value)
      self.unique[value] = 1
    elif value in self.unique:
      # We have added this value before, and this is the second time we're
      # adding it. So, erase the value from `unique`.
      self.unique.pop(value)

```

## 826. Most Profit Assigning Work_826.py

```python
class Solution:
  def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:
    ans = 0
    jobs = sorted(zip(difficulty, profit))
    worker.sort(reverse=1)

    i = 0
    maxProfit = 0

    for w in sorted(worker):
      while i < len(jobs) and w >= jobs[i][0]:
        maxProfit = max(maxProfit, jobs[i][1])
        i += 1
      ans += maxProfit

    return ans

```

## 1019. Next Greater Node In Linked List_1019.py

```python
class Solution:
  def nextLargerNodes(self, head: ListNode) -> List[int]:
    ans = []
    stack = []

    while head:
      while stack and head.val > ans[stack[-1]]:
        index = stack.pop()
        ans[index] = head.val
      stack.append(len(ans))
      ans.append(head.val)
      head = head.next

    for i in stack:
      ans[i] = 0

    return ans

```

## 2583. Kth Largest Sum in a Binary Tree_2583.py

```python
class Solution:
  def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:
    levelSums = []

    def dfs(root: Optional[TreeNode], level: int) -> None:
      if not root:
        return
      if len(levelSums) == level:
        levelSums.append(0)
      levelSums[level] += root.val
      dfs(root.left, level + 1)
      dfs(root.right, level + 1)

    dfs(root, 0)
    if len(levelSums) < k:
      return -1

    return sorted(levelSums, reverse=True)[k - 1]

```

## 917. Reverse Only Letters_917.py

```python
class Solution:
  def reverseOnlyLetters(self, s: str) -> str:
    ans = list(s)
    i = 0
    j = len(s) - 1

    while i < j:
      while i < j and not s[i].isalpha():
        i += 1
      while i < j and not s[j].isalpha():
        j -= 1
      ans[i], ans[j] = ans[j], ans[i]
      i += 1
      j -= 1

    return ''.join(ans)

```

## 1578. Minimum Time to Make Rope Colorful_1578.py

```python
class Solution:
  def minCost(self, colors: str, neededTime: List[int]) -> int:
    ans = 0
    maxNeededTime = neededTime[0]

    for i in range(1, len(colors)):
      if colors[i] == colors[i - 1]:
        ans += min(maxNeededTime, neededTime[i])
        # For each continuous group, Bob needs to remove every balloon except
        # the one with the maximum `neededTime`. So, he should hold the balloon
        # with the highest `neededTime` in his hand.
        maxNeededTime = max(maxNeededTime, neededTime[i])
      else:
        # If the current balloon is different from the previous one, discard
        # the balloon from the previous group and hold the new one in hand.
        maxNeededTime = neededTime[i]

    return ans

```

## 2069. Walking Robot Simulation II_2069.py

```python
class Robot:
  def __init__(self, width: int, height: int):
    self.isOrigin = True
    self.i = 0
    self.pos = [((0, 0), 'South')] + \
        [((i, 0), 'East') for i in range(1, width)] + \
        [((width - 1, j), 'North') for j in range(1, height)] + \
        [((i, height - 1), 'West') for i in range(width - 2, -1, -1)] +\
        [((0, j), 'South') for j in range(height - 2, 0, -1)]

  def step(self, num: int) -> None:
    self.isOrigin = False
    self.i = (self.i + num) % len(self.pos)

  def getPos(self) -> List[int]:
    return self.pos[self.i][0]

  def getDir(self) -> str:
    return 'East' if self.isOrigin else self.pos[self.i][1]

```

## 443. String Compression_443.py

```python
class Solution:
  def compress(self, chars: List[str]) -> int:
    ans = 0
    i = 0

    while i < len(chars):
      letter = chars[i]
      count = 0
      while i < len(chars) and chars[i] == letter:
        count += 1
        i += 1
      chars[ans] = letter
      ans += 1
      if count > 1:
        for c in str(count):
          chars[ans] = c
          ans += 1

    return ans

```

## 1386. Cinema Seat Allocation_1386.py

```python
class Solution:
  def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:
    ans = 0
    rowToSeats = collections.Counter()

    for row, seat in reservedSeats:
      rowToSeats[row] |= 1 << (seat - 1)

    for seats in rowToSeats.values():
      if (seats & 0b0111111110) == 0:
        # Can fit 2 four-person groups.
        ans += 2
      elif (seats & 0b0111100000) == 0 \
              or (seats & 0b0001111000) == 0 \
              or (seats & 0b0000011110) == 0:
        # Can fit 1 four-person group.
        ans += 1

    # Any empty row can fit 2 four-person groups.
    return ans + (n - len(rowToSeats)) * 2

```

## 405. Convert a Number to Hexadecimal_405.py

```python
class Solution:
  def toHex(self, num: int) -> str:
    if num == 0:
      return '0'

    hex = '0123456789abcdef'
    ans = []

    # Handling negative numbers by using 32-bit unsigned representation Python's
    # bitwise operation works on signed numbers, so we convert to 32-bit
    # unsigned for negative numbers.
    if num < 0:
      num += 2**32

    while num > 0:
      ans.append(hex[num & 0xF])
      num >>= 4

    return ''.join(reversed(ans))

```

## 2761. Prime Pairs With Target Sum_2761.py

```python
class Solution:
  def findPrimePairs(self, n: int) -> List[List[int]]:
    isPrime = self._sieveEratosthenes(n + 1)
    return [[i, n - i] for i in range(2, n // 2 + 1)
            if isPrime[i] and isPrime[n - i]]

  def _sieveEratosthenes(self, n: int) -> List[bool]:
    isPrime = [True] * n
    isPrime[0] = False
    isPrime[1] = False
    for i in range(2, int(n**0.5) + 1):
      if isPrime[i]:
        for j in range(i * i, n, i):
          isPrime[j] = False
    return isPrime
j

```

## 245. Shortest Word Distance III_245.py

```python
class Solution:
  def shortestWordDistance(self, wordsDict: List[str], word1: str, word2: str) -> int:
    isSame = word1 == word2
    ans = math.inf
    # If word1 == word2, index1 is the newest index.
    index1 = len(wordsDict)
    # If word1 == word2, index2 is the previous index.
    index2 = -len(wordsDict)

    for i, word in enumerate(wordsDict):
      if word == word1:
        if isSame:
          index2 = index1
        index1 = i
      elif word == word2:
        index2 = i
      ans = min(ans, abs(index1 - index2))

    return ans

```

## 2420. Find All Good Indices_2420.py

```python
class Solution:
  # Same as 2100. Find Good Days to Rob the Bank
  def goodIndices(self, nums: List[int], k: int) -> List[int]:
    n = len(nums)
    dec = [1] * n  # 1 + the number of continuous decreasing numbers before i
    inc = [1] * n  # 1 + the number of continuous increasing numbers after i

    for i in range(1, n):
      if nums[i - 1] >= nums[i]:
        dec[i] = dec[i - 1] + 1

    for i in range(n - 2, -1, -1):
      if nums[i] <= nums[i + 1]:
        inc[i] = inc[i + 1] + 1

    return [i for i in range(k, n - k)
            if dec[i - 1] >= k and inc[i + 1] >= k]

```

## 2817. Minimum Absolute Difference Between Elements With Constraint_2817.py

```python
from sortedcontainers import SortedSet


class Solution:
  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
    ans = math.inf
    seen = SortedSet()

    for i in range(x, len(nums)):
      seen.add(nums[i - x])
      it = seen.bisect_left(nums[i])
      if it != len(seen):
        ans = min(ans, seen[it] - nums[i])
      if it != 0:
        ans = min(ans, nums[i] - seen[it - 1])

    return ans

```

## 142. Linked List Cycle II_142.py

```python
class Solution:
  def detectCycle(self, head: ListNode) -> ListNode:
    slow = head
    fast = head

    while fast and fast.next:
      slow = slow.next
      fast = fast.next.next
      if slow == fast:
        slow = head
        while slow != fast:
          slow = slow.next
          fast = fast.next
        return slow

    return None

```

## 2297. Jump Game IX_2297.py

```python
class Solution:
  def minCost(self, nums: List[int], costs: List[int]) -> int:
    # dp[i] := the minimum cost to jump to i
    dp = [math.inf] * len(nums)
    maxStack = []
    minStack = []

    dp[0] = 0

    for i, num in enumerate(nums):
      while maxStack and num >= nums[maxStack[-1]]:
        dp[i] = min(dp[i], dp[maxStack.pop()] + costs[i])
      while minStack and num < nums[minStack[-1]]:
        dp[i] = min(dp[i], dp[minStack.pop()] + costs[i])
      maxStack.append(i)
      minStack.append(i)

    return dp[-1]

```

## 1383. Maximum Performance of a Team_1383.py

```python
class Solution:
  # Similar to 857. Minimum Cost to Hire K Workers
  def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:
    kMod = 1_000_000_007
    ans = 0
    speedSum = 0
    # (efficiency[i], speed[i]) sorted by efficiency[i] in descending order
    A = sorted([(e, s) for s, e in zip(speed, efficiency)], reverse=True)
    minHeap = []

    for e, s in A:
      heapq.heappush(minHeap, s)
      speedSum += s
      if len(minHeap) > k:
        speedSum -= heapq.heappop(minHeap)
      ans = max(ans, speedSum * e)

    return ans % kMod

```

## 114. Flatten Binary Tree to Linked List_114-3.py

```python
class Solution:
  def flatten(self, root: Optional[TreeNode]) -> None:
    if not root:
      return

    while root:
      if root.left:
        # Find the rightmost root
        rightmost = root.left
        while rightmost.right:
          rightmost = rightmost.right
        # Rewire the connections
        rightmost.right = root.right
        root.right = root.left
        root.left = None
      # Move on to the right side of the tree
      root = root.right

```

## 857. Minimum Cost to Hire K Workers_857.py

```python
class Solution:
  def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:
    ans = math.inf
    qualitySum = 0
    # (wagePerQuality, quality) sorted by wagePerQuality
    workers = sorted((w / q, q) for q, w in zip(quality, wage))
    maxHeap = []

    for wagePerQuality, q in workers:
      heapq.heappush(maxHeap, -q)
      qualitySum += q
      if len(maxHeap) > k:
        qualitySum += heapq.heappop(maxHeap)
      if len(maxHeap) == k:
        ans = min(ans, qualitySum * wagePerQuality)

    return ans

```

## 3212. Count Submatrices With Equal Frequency of X and Y_3212.py

```python
class Solution:
  def numberOfSubmatrices(self, grid: List[List[str]]) -> int:
    m = len(grid)
    n = len(grid[0])
    ans = 0
    # x[i][j] := the number of 'X' in grid[0..i)[0..j)
    x = [[0] * (n + 1) for _ in range(m + 1)]
    # y[i][j] := the number of 'Y' in grid[0..i)[0..j)
    y = [[0] * (n + 1) for _ in range(m + 1)]

    for i, row in enumerate(grid):
      for j, cell in enumerate(row):
        x[i + 1][j + 1] = (cell == 'X') + x[i][j + 1] + x[i + 1][j] - x[i][j]
        y[i + 1][j + 1] = (cell == 'Y') + y[i][j + 1] + y[i + 1][j] - y[i][j]
        if x[i + 1][j + 1] > 0 and x[i + 1][j + 1] == y[i + 1][j + 1]:
          ans += 1

    return ans

```

## 105. Construct Binary Tree from Preorder and Inorder Traversal_105.py

```python
class Solution:
  def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
    inToIndex = {num: i for i, num in enumerate(inorder)}

    def build(preStart: int, preEnd: int, inStart: int, inEnd: int) -> Optional[TreeNode]:
      if preStart > preEnd:
        return None

      rootVal = preorder[preStart]
      rootInIndex = inToIndex[rootVal]
      leftSize = rootInIndex - inStart

      root = TreeNode(rootVal)
      root.left = build(preStart + 1, preStart + leftSize,
                        inStart, rootInIndex - 1)
      root.right = build(preStart + leftSize + 1,
                         preEnd, rootInIndex + 1, inEnd)
      return root

    return build(0, len(preorder) - 1, 0, len(inorder) - 1)

```

## 515. Find Largest Value in Each Tree Row_515.py

```python
class Solution:
  def largestValues(self, root: Optional[TreeNode]) -> List[int]:
    if not root:
      return []

    ans = []
    q = collections.deque([root])

    while q:
      mx = -math.inf
      for _ in range(len(q)):
        root = q.popleft()
        mx = max(mx, root.val)
        if root.left:
          q.append(root.left)
        if root.right:
          q.append(root.right)
      ans.append(mx)

    return ans

```

## 2952. Minimum Number of Coins to be Added_2952.py

```python
class Solution:
  # Same as 330. Patching Array
  def minimumAddedCoins(self, coins: List[int], target: int) -> int:
    ans = 0
    i = 0  # coins' index
    miss = 1  # the minimum sum in [1, n] we might miss

    coins.sort()

    while miss <= target:
      if i < len(coins) and coins[i] <= miss:
        miss += coins[i]
        i += 1
      else:
        # Greedily add `miss` itself to increase the range from
        # [1, miss) to [1, 2 * miss).
        miss += miss
        ans += 1

    return ans

```

## 2156. Find Substring With Given Hash Value_2156.py

```python
class Solution:
  def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:
    maxPower = pow(power, k, modulo)
    hash = 0

    def val(c: str) -> int:
      return ord(c) - ord('a') + 1

    for i, c in reversed(list(enumerate(s))):
      hash = (hash * power + val(c)) % modulo
      if i + k < len(s):
        hash = (hash - val(s[i + k]) * maxPower) % modulo
      if hash == hashValue:
        bestLeft = i

    return s[bestLeft:bestLeft + k]

```

## 828. Count Unique Characters of All Substrings of a Given String_828.py

```python
class Solution:
  def uniqueLetterString(self, s: str) -> int:
    ans = 0
    # the number of unique letters in all the substrings ending in the index so
    # far
    dp = 0
    lastCount = {}
    lastSeen = {}

    for i, c in enumerate(s):
      newCount = i - lastSeen.get(c, -1)
      # Substract the duplicates.
      dp -= lastCount.get(c, 0)
      # Add count of s[lastSeen[c] + 1..i], s[lastSeen[c] + 2..i], ..., s[i].
      dp += newCount
      lastCount[c] = newCount
      lastSeen[c] = i
      ans += dp

    return ans

```

## 216. Combination Sum III_216.py

```python
class Solution:
  def combinationSum3(self, k: int, n: int) -> List[List[int]]:
    ans = []

    def dfs(k: int, n: int, s: int, path: List[int]) -> None:
      if k == 0 and n == 0:
        ans.append(path)
        return
      if k == 0 or n < 0:
        return

      for i in range(s, 10):
        dfs(k - 1, n - i, i + 1, path + [i])

    dfs(k, n, 1, [])
    return ans

```

## 224. Basic Calculator_224.py

```python
class Solution:
  def calculate(self, s: str) -> int:
    ans = 0
    num = 0
    sign = 1
    stack = [sign]  # stack[-1]: the current environment's sign

    for c in s:
      if c.isdigit():
        num = num * 10 + (ord(c) - ord('0'))
      elif c == '(':
        stack.append(sign)
      elif c == ')':
        stack.pop()
      elif c == '+' or c == '-':
        ans += sign * num
        sign = (1 if c == '+' else -1) * stack[-1]
        num = 0

    return ans + sign * num

```

## 2375. Construct Smallest Number From DI String_2375.py

```python
class Solution:
  def smallestNumber(self, pattern: str) -> str:
    ans = []
    stack = ['1']

    for c in pattern:
      maxSorFar = stack[-1]
      if c == 'I':
        while stack:
          maxSorFar = max(maxSorFar, stack[-1])
          ans.append(stack.pop())
      stack.append(chr(ord(maxSorFar) + 1))

    while stack:
      ans.append(stack.pop())

    return ''.join(ans)

```

## 257. Binary Tree Paths_257.py

```python
class Solution:
  def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
    ans = []

    def dfs(root: Optional[TreeNode], path: List[str]) -> None:
      if not root:
        return
      if not root.left and not root.right:
        ans.append(''.join(path) + str(root.val))
        return

      path.append(str(root.val) + '->')
      dfs(root.left, path)
      dfs(root.right, path)
      path.pop()

    dfs(root, [])
    return ans

```

## 2517. Maximum Tastiness of Candy Basket_2517.py

```python
class Solution:
  def maximumTastiness(self, price: List[int], k: int) -> int:
    price.sort()

    def cantPick(m: int) -> bool:
      """Returns True if we can't pick k distinct candies for m tastiness."""
      baskets = 0
      prevPrice = -m
      for p in price:
        if p >= prevPrice + m:
          prevPrice = p
          baskets += 1
      return baskets < k

    l = bisect.bisect_left(range(max(price) - min(price) + 1), True,
                           key=lambda m: cantPick(m))
    return l - 1

```

## 484. Find Permutation_484.py

```python
class Solution:
  def findPermutation(self, s: str) -> List[int]:
    ans = []
    stack = []

    for i, c in enumerate(s):
      stack.append(i + 1)
      if c == 'I':
        while stack:  # Consume all decreasings
          ans.append(stack.pop())
    stack.append(len(s) + 1)

    while stack:
      ans.append(stack.pop())

    return ans

```

## 1269. Number of Ways to Stay in the Same Place After Some Steps_1269.py

```python
class Solution:
  def numWays(self, steps: int, arrLen: int) -> int:
    kMod = 1_000_000_007
    # dp[i] := the number of ways to stay at index i
    dp = [0] * min(steps // 2 + 1, arrLen)
    dp[0] = 1

    for _ in range(steps):
      newDp = [0] * min(steps // 2 + 1, arrLen)
      for i, ways in enumerate(dp):
        if ways > 0:
          for dx in (-1, 0, 1):
            nextIndex = i + dx
            if 0 <= nextIndex < len(dp):
              newDp[nextIndex] += ways
              newDp[nextIndex] %= kMod
      dp = newDp

    return dp[0]

```

## 1260. Shift 2D Grid_1260.py

```python
class Solution:
  def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
    m = len(grid)
    n = len(grid[0])
    ans = [[0] * n for _ in range(m)]

    k %= m * n

    for i in range(m):
      for j in range(n):
        index = (i * n + j + k) % (m * n)
        x = index // n
        y = index % n
        ans[x][y] = grid[i][j]

    return ans

```

## 1918. Kth Smallest Subarray Sum_1918.py

```python
class Solution:
  def kthSmallestSubarraySum(self, nums: List[int], k: int) -> int:
    def numSubarrayLessThan(m: int) -> int:
      res = 0
      summ = 0
      l = 0
      for r, num in enumerate(nums):
        summ += num
        while summ > m:
          summ -= nums[l]
          l += 1
        res += r - l + 1
      return res

    return bisect.bisect_left(range(0, sum(nums)), k,
                              key=lambda m: numSubarrayLessThan(m))

```

## 732. My Calendar III_732.py

```python
from sortedcontainers import SortedDict


class MyCalendarThree:
  def __init__(self):
    self.timeline = SortedDict()

  def book(self, start: int, end: int) -> int:
    self.timeline[start] = self.timeline.get(start, 0) + 1
    self.timeline[end] = self.timeline.get(end, 0) - 1

    ans = 0
    activeEvents = 0

    for count in self.timeline.values():
      activeEvents += count
      ans = max(ans, activeEvents)

    return ans

```

## 2466. Count Ways To Build Good Strings_2466.py

```python
class Solution:
  def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
    kMod = 1_000_000_007
    ans = 0
    # dp[i] := the number of good strings with length i
    dp = [1] + [0] * high

    for i in range(1, high + 1):
      if i >= zero:
        dp[i] = (dp[i] + dp[i - zero]) % kMod
      if i >= one:
        dp[i] = (dp[i] + dp[i - one]) % kMod
      if i >= low:
        ans = (ans + dp[i]) % kMod

    return ans

```

## 523. Continuous Subarray Sum_523.py

```python
class Solution:
  def checkSubarraySum(self, nums: List[int], k: int) -> bool:
    prefix = 0
    prefixToIndex = {0: -1}

    for i, num in enumerate(nums):
      prefix += num
      if k != 0:
        prefix %= k
      if prefix in prefixToIndex:
        if i - prefixToIndex[prefix] > 1:
          return True
      else:
        # Set a new key if it's absent because the previous index is better.
        prefixToIndex[prefix] = i

    return False

```

## 835. Image Overlap_835.py

```python
class Solution:
  def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -> int:
    kMagic = 100
    ones1 = [(i, j)
             for i, row in enumerate(img1)
             for j, num in enumerate(row)
             if num == 1]
    ones2 = [(i, j)
             for i, row in enumerate(img2)
             for j, num in enumerate(row)
             if num == 1]
    offsetCount = collections.Counter()

    for ax, ay in ones1:
      for bx, by in ones2:
        offsetCount[(ax - bx) * kMagic + (ay - by)] += 1

    return max(offsetCount.values()) if offsetCount else 0

```

## 2172. Maximum AND Sum of Array_2172.py

```python
class Solution:
  def maximumANDSum(self, nums: List[int], numSlots: int) -> int:
    n = 2 * numSlots
    nSelected = 1 << n
    # dp[i] := the maximum value, where i is the bitmask of the selected
    # numbers
    dp = [0] * nSelected

    nums += [0] * (n - len(nums))

    for mask in range(1, nSelected):
      selected = mask.bit_count()
      slot = (selected + 1) // 2  # (1, 2) -> 1, (3, 4) -> 2
      for i, num in enumerate(nums):
        if mask >> i & 1:  # Assign `nums[i]` to the `slot`-th slot.
          dp[mask] = max(dp[mask], dp[mask ^ 1 << i] + (slot & num))

    return dp[-1]

```

## 36. Valid Sudoku_36.py

```python
class Solution:
  def isValidSudoku(self, board: List[List[str]]) -> bool:
    seen = set()

    for i in range(9):
      for j in range(9):
        c = board[i][j]
        if c == '.':
          continue
        if c + '@row ' + str(i) in seen or \
           c + '@col ' + str(j) in seen or \
           c + '@box ' + str(i // 3) + str(j // 3) in seen:
          return False
        seen.add(c + '@row ' + str(i))
        seen.add(c + '@col ' + str(j))
        seen.add(c + '@box ' + str(i // 3) + str(j // 3))

    return True

```

## 3177. Find the Maximum Length of a Good Subsequence II_3177.py

```python
class Solution:
  # Same as 3176. Find the Maximum Length of a Good Subsequence I
  def maximumLength(self, nums: List[int], k: int) -> int:
    # dp[count][num] := the maximum length of a good subsequence with at most
    # `count` indices where seq[i] != seq[i + 1] and it ends in `num`.
    dp = [collections.Counter() for _ in range(k + 1)]
    # maxLen[count] := the maximum length of a good subsequence with `count`
    # indices where seq[i] != seq[i + 1]
    maxLen = [0] * (k + 1)

    for num in nums:
      for count in range(k, -1, -1):
        # Append `num` to the subsequence.
        dp[count][num] += 1
        if count > 0:
          dp[count][num] = max(dp[count][num], maxLen[count - 1] + 1)
        maxLen[count] = max(maxLen[count], dp[count][num])

    return maxLen[k]

```

## 114. Flatten Binary Tree to Linked List_114-2.py

```python
class Solution:
  def flatten(self, root: Optional[TreeNode]) -> None:
    if not root:
      return

    stack = [root]

    while stack:
      root = stack.pop()
      if root.right:
        stack.append(root.right)
      if root.left:
        stack.append(root.left)
      if stack:
        root.right = stack[-1]
      root.left = None

```

## 1316. Distinct Echo Substrings_1316.py

```python
class Solution:
  def distinctEchoSubstrings(self, text: str) -> int:
    seen = set()

    for k in range(1, len(text) // 2 + 1):  # the target length
      same = 0
      l = 0
      for r in range(k, len(text)):
        if text[l] == text[r]:
          same += 1
        else:
          same = 0
        if same == k:
          seen.add(text[l - k + 1:l + 1])
          # Move the window thus leaving a letter behind, so we need to
          # decrease the counter.
          same -= 1
        l += 1

    return len(seen)

```

## 403. Frog Jump_403-2.py

```python
class Solution:
  def canCross(self, stones: List[int]) -> bool:
    n = len(stones)
    # dp[i][j] := True if a frog can make a size j jump from stones[i]
    dp = [[False] * (n + 1) for _ in range(n)]
    dp[0][1] = True

    for i in range(1, n):
      for j in range(i):
        k = stones[i] - stones[j]
        if k <= n and dp[j][k]:
          dp[i][k - 1] = True
          dp[i][k] = True
          dp[i][k + 1] = True

    return any(dp[-1])

```

## 1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K_1414-2.py

```python
class Solution:
  def findMinFibonacciNumbers(self, k: int) -> int:
    ans = 0
    a = 1  # F_1
    b = 1  # F_2

    while b <= k:
      #    a, b = F_{i + 1}, F_{i + 2}
      # -> a, b = F_{i + 2}, F_{i + 3}
      a, b = b, a + b

    while a > 0:
      if a <= k:
        k -= a
        ans += 1
      #    a, b = F_{i + 2}, F_{i + 3}
      # -> a, b = F_{i + 1}, F_{i + 2}
      a, b = b - a, a

    return ans

```

## 68. Text Justification_68.py

```python
class Solution:
  def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:
    ans = []
    row = []
    rowLetters = 0

    for word in words:
      # If we place the word in this row, it will exceed the maximum width.
      # Therefore, we cannot put the word in this row and have to pad spaces
      # for each word in this row.
      if rowLetters + len(word) + len(row) > maxWidth:
        for i in range(maxWidth - rowLetters):
          row[i % (len(row) - 1 or 1)] += ' '
        ans.append(''.join(row))
        row = []
        rowLetters = 0
      row.append(word)
      rowLetters += len(word)

    return ans + [' '.join(row).ljust(maxWidth)]

```

## 1115. Print FooBar Alternately_1115.py

```python
from threading import Semaphore


class FooBar:
  def __init__(self, n):
    self.n = n
    self.fooSemaphore = Semaphore(1)
    self.barSemaphore = Semaphore(0)

  def foo(self, printFoo: 'Callable[[], None]') -> None:
    for _ in range(self.n):
      self.fooSemaphore.acquire()
      printFoo()
      self.barSemaphore.release()

  def bar(self, printBar: 'Callable[[], None]') -> None:
    for _ in range(self.n):
      self.barSemaphore.acquire()
      printBar()
      self.fooSemaphore.release()

```

## 2342. Max Sum of a Pair With Equal Sum of Digits_2342.py

```python
class Solution:
  def maximumSum(self, nums: List[int]) -> int:
    kMax = 9 * 9  # 999,999,999
    ans = -1
    count = [[] for _ in range(kMax + 1)]

    for num in nums:
      count[self._getDigitSum(num)].append(num)

    for groupNums in count:
      if len(groupNums) < 2:
        continue
      groupNums.sort(reverse=True)
      ans = max(ans, groupNums[0] + groupNums[1])

    return ans

  def _getDigitSum(self, num: int) -> int:
    return sum(int(digit) for digit in str(num))

```

## 38. Count and Say_38.py

```python
class Solution:
  def countAndSay(self, n: int) -> str:
    ans = '1'

    for _ in range(n - 1):
      nxt = ''
      i = 0
      while i < len(ans):
        count = 1
        while i + 1 < len(ans) and ans[i] == ans[i + 1]:
          count += 1
          i += 1
        nxt += str(count) + ans[i]
        i += 1
      ans = nxt

    return ans

```

## 3063. Linked List Frequency_3063.py

```python
class Solution:
  def frequenciesOfElements(self, head: Optional[ListNode]) -> Optional[ListNode]:
    count = collections.Counter()
    curr = head

    while curr:
      count[curr.val] += 1
      curr = curr.next

    dummy = ListNode(0)
    tail = dummy

    for freq in count.values():
      tail.next = ListNode(freq)
      tail = tail.next

    return dummy.next

```

## 2167. Minimum Time to Remove All Cars Containing Illegal Goods_2167.py

```python
class Solution:
  def minimumTime(self, s: str) -> int:
    n = len(s)
    # left[i] := the minimum time to remove the illegal cars of s[0..i]
    left = [0] * n
    left[0] = ord(s[0]) - ord('0')
    # dp[i] := the minimum time to remove the illegal cars of s[0..i] optimally
    # + the time to remove the illegal cars of s[i + 1..n) consecutively
    # Note that the way to remove the illegal cars in the right part
    # doesn't need to be optimal since:
    #   `left | illegal cars | n - 1 - k` will be covered in
    #   `left' | n - 1 - i` later.
    dp = [n] * n
    dp[0] = left[0] + n - 1

    for i in range(1, n):
      left[i] = min(left[i - 1] + (ord(s[i]) - ord('0')) * 2, i + 1)
      dp[i] = min(dp[i], left[i] + n - 1 - i)

    return min(dp)

```

## 114. Flatten Binary Tree to Linked List_114.py

```python
class Solution:
  def flatten(self, root: Optional[TreeNode]) -> None:
    if not root:
      return

    self.flatten(root.left)
    self.flatten(root.right)

    left = root.left  # flattened left
    right = root.right  # flattened right

    root.left = None
    root.right = left

    # Connect the original right subtree to the end of the new right subtree.
    rightmost = root
    while rightmost.right:
      rightmost = rightmost.right
    rightmost.right = right

```

## 1122. Relative Sort Array_1122.py

```python
class Solution:
  def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
    ans = []
    count = [0] * 1001

    for a in arr1:
      count[a] += 1

    for a in arr2:
      while count[a] > 0:
        ans.append(a)
        count[a] -= 1

    for num in range(1001):
      for _ in range(count[num]):
        ans.append(num)

    return ans

```

## 233. Number of Digit One_233.py

```python
class Solution:
  def countDigitOne(self, n: int) -> int:
    ans = 0

    pow10 = 1
    while pow10 <= n:
      divisor = pow10 * 10
      quotient = n // divisor
      remainder = n % divisor
      if quotient > 0:
        ans += quotient * pow10
      if remainder >= pow10:
        ans += min(remainder - pow10 + 1, pow10)
      pow10 *= 10

    return ans

```

## 318. Maximum Product of Word Lengths_318.py

```python
class Solution:
  def maxProduct(self, words: List[str]) -> int:
    ans = 0

    def getMask(word: str) -> int:
      mask = 0
      for c in word:
        mask |= 1 << ord(c) - ord('a')
      return mask

    masks = [getMask(word) for word in words]

    for i in range(len(words)):
      for j in range(i):
        if not (masks[i] & masks[j]):
          ans = max(ans, len(words[i]) * len(words[j]))

    return ans

```

## 221. Maximal Square_221.py

```python
class Solution:
  def maximalSquare(self, matrix: List[List[str]]) -> int:
    m = len(matrix)
    n = len(matrix[0])
    dp = [[0] * n for _ in range(m)]
    maxLength = 0

    for i in range(m):
      for j in range(n):
        if i == 0 or j == 0 or matrix[i][j] == '0':
          dp[i][j] = 1 if matrix[i][j] == '1' else 0
        else:
          dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1]
                         [j], dp[i][j - 1]) + 1
        maxLength = max(maxLength, dp[i][j])

    return maxLength * maxLength

```

## 408. Valid Word Abbreviation_408.py

```python
class Solution:
  def validWordAbbreviation(self, word: str, abbr: str) -> bool:
    i = 0  # word's index
    j = 0  # abbr's index

    while i < len(word) and j < len(abbr):
      if word[i] == abbr[j]:
        i += 1
        j += 1
        continue
      if not abbr[j].isdigit() or abbr[j] == '0':
        return False
      num = 0
      while j < len(abbr) and abbr[j].isdigit():
        num = num * 10 + int(abbr[j])
        j += 1
      i += num

    return i == len(word) and j == len(abbr)

```

## 133. Clone Graph_133-2.py

```python
class Solution:
  def cloneGraph(self, node: 'Node') -> 'Node':
    if not node:
      return None
    if node in self.map:
      return self.map[node]

    newNode = Node(node.val, [])
    self.map[node] = newNode

    for neighbor in node.neighbors:
      self.map[node].neighbors.append(self.cloneGraph(neighbor))

    return newNode

  map = {}

```

## 930. Binary Subarrays With Sum_930-2.py

```python
class Solution:
  def numSubarraysWithSum(self, nums: List[int], goal: int) -> int:
    def numSubarraysWithSumAtMost(goal: int) -> int:
      res = 0
      count = 0
      l = 0
      r = 0

      while r < len(nums):
        count += nums[r]
        r += 1
        while l < r and count > goal:
          count -= nums[l]
          l += 1
        # nums[l..r), nums[l + 1..r), ..., nums[r - 1]
        res += r - l

      return res

    return numSubarraysWithSumAtMost(goal) - numSubarraysWithSumAtMost(goal - 1)

```

## 2209. Minimum White Tiles After Covering With Carpets_2209-2.py

```python
class Solution:
  def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:
    n = len(floor)
    # dp[i][j] := the minimum number of visible white tiles of floor[i..n)
    # after covering at most j carpets
    dp = [[0] * (numCarpets + 1) for _ in range(n + 1)]

    for i in reversed(range(n)):
      dp[i][0] = int(floor[i]) + dp[i + 1][0]

    for i in reversed(range(n)):
      for j in range(1, numCarpets + 1):
        cover = dp[i + carpetLen][j - 1] if i + carpetLen < n else 0
        skip = int(floor[i]) + dp[i + 1][j]
        dp[i][j] = min(cover, skip)

    return dp[0][numCarpets]

```

## 1351. Count Negative Numbers in a Sorted Matrix_1351.py

```python
class Solution:
  def countNegatives(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    ans = 0
    i = m - 1
    j = 0

    while i >= 0 and j < n:
      if grid[i][j] < 0:
        ans += n - j
        i -= 1
      else:
        j += 1

    return ans

```

## 1839. Longest Substring Of All Vowels in Order_1839.py

```python
class Solution:
  def longestBeautifulSubstring(self, word: str) -> int:
    ans = 0
    count = 1

    l = 0
    for r in range(1, len(word)):
      curr = word[r]
      prev = word[r - 1]
      if curr >= prev:
        if curr > prev:
          count += 1
        if count == 5:
          ans = max(ans, r - l + 1)
      else:
        count = 1
        l = r

    return ans

```

## 2760. Longest Even Odd Subarray With Threshold_2760.py

```python
class Solution:
  def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:
    ans = 0
    dp = 0

    def isOddEven(a: int, b: int) -> bool:
      return a % 2 != b % 2

    for i, num in enumerate(nums):
      if num > threshold:
        dp = 0
      elif i > 0 and dp > 0 and isOddEven(nums[i - 1], num):
        # Increase the size of the subarray.
        dp += 1
      else:
        # Start a new subarray if the start is valid.
        dp = 1 if num % 2 == 0 else 0
      ans = max(ans, dp)

    return ans

```

## 3082. Find the Sum of the Power of All Subsequences_3082.py

```python
class Solution:
  def sumOfPower(self, nums: List[int], k: int) -> int:
    kMod = 1_000_000_007

    @functools.lru_cache(None)
    def dp(i: int, j: int) -> int:
      """Returns the number of subsequences in nums[i..n) that sums to j."""
      if j == 0:
        # For each of the remaining number, we can either pick it or skip it.
        return pow(2, len(nums) - i, kMod)
      if i == len(nums) or j < 0:
        return 0
        # 1. Include nums[i] in the subsequence and pick it.
        # 2. Include nums[i] in the subsequence and skip it.
        # 3. Exclude nums[i] in the subsequence.
      return (dp(i + 1, j - nums[i]) + 2 * dp(i + 1, j)) % kMod

    return dp(0, k)

```

## 113. Path Sum II_113.py

```python
class Solution:
  def pathSum(self, root: TreeNode, summ: int) -> List[List[int]]:
    ans = []

    def dfs(root: TreeNode, summ: int, path: List[int]) -> None:
      if not root:
        return
      if root.val == summ and not root.left and not root.right:
        ans.append(path + [root.val])
        return

      dfs(root.left, summ - root.val, path + [root.val])
      dfs(root.right, summ - root.val, path + [root.val])

    dfs(root, summ, [])
    return ans

```

## 2360. Longest Cycle in a Graph_2360.py

```python
class Solution:
  def longestCycle(self, edges: List[int]) -> int:
    ans = -1
    time = 1
    timeVisited = [0] * len(edges)

    for i, edge in enumerate(edges):
      if timeVisited[i]:
        continue
      startTime = time
      u = i
      while u != -1 and not timeVisited[u]:
        timeVisited[u] = time
        time += 1
        u = edges[u]  # Move to the next node.
      if u != -1 and timeVisited[u] >= startTime:
        ans = max(ans, time - timeVisited[u])

    return ans

```

## 131. Palindrome Partitioning_131.py

```python
class Solution:
  def partition(self, s: str) -> List[List[str]]:
    ans = []

    def isPalindrome(s: str) -> bool:
      return s == s[::-1]

    def dfs(s: str, j: int, path: List[str], ans: List[List[str]]) -> None:
      if j == len(s):
        ans.append(path)
        return

      for i in range(j, len(s)):
        if isPalindrome(s[j: i + 1]):
          dfs(s, i + 1, path + [s[j: i + 1]], ans)

    dfs(s, 0, [], ans)
    return ans

```

## 1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers_1577.py

```python
class Solution:
  def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
    def countTriplets(A: List[int], B: List[int]):
      """Returns the number of triplet (i, j, k) if A[i]^2 == B[j] * B[k]."""
      res = 0
      count = collections.Counter(B)

      for a in A:
        target = a * a
        for b, freq in count.items():
          if target % b > 0 or target // b not in count:
            continue
          if target // b == b:
            res += freq * (freq - 1)
          else:
            res += freq * count[target // b]

      return res // 2

    return countTriplets(nums1, nums2) + countTriplets(nums2, nums1)

```

## 2064. Minimized Maximum of Products Distributed to Any Store_2064.py

```python
class Solution:
  def minimizedMaximum(self, n: int, quantities: List[int]) -> int:
    l = 1
    r = max(quantities)

    def numStores(m: int) -> int:
      return sum((q - 1) // m + 1 for q in quantities)

    while l < r:
      m = (l + r) // 2
      if numStores(m) <= n:
        r = m
      else:
        l = m + 1

    return l

```

## 155. Min Stack_155.py

```python
class MinStack:
  def __init__(self):
    self.stack = []

  def push(self, x: int) -> None:
    mn = x if not self.stack else min(self.stack[-1][1], x)
    self.stack.append([x, mn])

  def pop(self) -> None:
    self.stack.pop()

  def top(self) -> int:
    return self.stack[-1][0]

  def getMin(self) -> int:
    return self.stack[-1][1]

```

## 1891. Cutting Ribbons_1891.py

```python
class Solution:
  def maxLength(self, ribbons: List[int], k: int) -> int:
    def isCutPossible(length: int) -> bool:
      count = 0
      for ribbon in ribbons:
        count += ribbon // length
      return count >= k

    l = 1
    r = sum(ribbons) // k + 1

    while l < r:
      m = (l + r) // 2
      if not isCutPossible(m):
        r = m
      else:
        l = m + 1

    return l - 1

```

## 2746. Decremental String Concatenation_2746.py

```python
class Solution:
  def minimizeConcatenatedLength(self, words: List[str]) -> int:
    @functools.lru_cache(None)
    def dp(i: int, first: str, last: str) -> int:
      """
      Returns the minimum concatenated length of the first i words starting with
      `first` and ending in `last`.
      """
      if i == len(words):
        return 0
      nextFirst = words[i][0]
      nextLast = words[i][-1]
      return len(words[i]) + min(
          # join(words[i - 1], words[i])
          dp(i + 1, first, nextLast) - (last == nextFirst),
          # join(words[i], words[i - 1])
          dp(i + 1, nextFirst, last) - (first == nextLast)
      )

    return len(words[0]) + dp(1, words[0][0], words[0][-1])

```

## 312. Burst Balloons_312-2.py

```python
class Solution:
  def maxCoins(self, nums: List[int]) -> int:
    n = len(nums)
    # dp[i][j] := maxCoins(nums[i..j])
    dp = [[0] * (n + 2) for _ in range(n + 2)]

    nums = [1] + nums + [1]

    for d in range(n):
      for i in range(1, n - d + 1):
        j = i + d
        for k in range(i, j + 1):
          dp[i][j] = max(
              dp[i][j],
              dp[i][k - 1] +
              dp[k + 1][j] +
              nums[i - 1] * nums[k] * nums[j + 1])

    return dp[1][n]

```

## 2659. Make Array Empty_2659.py

```python
class Solution:
  def countOperationsToEmptyArray(self, nums: List[int]) -> int:
    n = len(nums)
    ans = n
    numToIndex = {}

    for i, num in enumerate(nums):
      numToIndex[num] = i

    nums.sort()

    for i in range(1, n):
      # On the i-th step we've already removed the i - 1 smallest numbers and
      # can ignore them. If an element nums[i] has smaller index in origin
      # array than nums[i - 1], we should rotate the whole left array n - i
      # times to set nums[i] element on the first position.
      if numToIndex[nums[i]] < numToIndex[nums[i - 1]]:
        ans += n - i

    return ans

```

## 788. Rotated Digits_788.py

```python
class Solution:
  def rotatedDigits(self, n: int) -> int:
    def isGoodNumber(i: int) -> bool:
      isRotated = False

      for c in str(i):
        if c == '0' or c == '1' or c == '8':
          continue
        if c == '2' or c == '5' or c == '6' or c == '9':
          isRotated = True
        else:
          return False

      return isRotated

    return sum(isGoodNumber(i) for i in range(1, n + 1))

```

## 1576. Replace All ?'s to Avoid Consecutive Repeating Characters_1576.py

```python
class Solution:
  def modifyString(self, s: str) -> str:
    ans = []

    def nextAvailable(ans: List[int], s: str, i: int) -> str:
      c = 'a'
      while (i > 0 and ans[i - 1] == c) or \
              (i + 1 < len(s) and c == s[i + 1]):
        c = chr(ord(c) + 1)
      return c

    for i, c in enumerate(s):
      if c == '?':
        ans.append(nextAvailable(ans, s, i))
      else:
        ans.append(c)

    return ''.join(ans)

```

## 463. Island Perimeter_463.py

```python
class Solution:
  def islandPerimeter(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])

    islands = 0
    neighbors = 0

    for i in range(m):
      for j in range(n):
        if grid[i][j] == 1:
          islands += 1
          if i + 1 < m and grid[i + 1][j] == 1:
            neighbors += 1
          if j + 1 < n and grid[i][j + 1] == 1:
            neighbors += 1

    return islands * 4 - neighbors * 2

```

## 364. Nested List Weight Sum II_364.py

```python
class Solution:
  def depthSumInverse(self, nestedList: List[NestedInteger]) -> int:
    ans = 0
    prevSum = 0
    q = collections.deque(nestedList)

    while q:
      for _ in range(len(q)):
        ni = q.popleft()
        if ni.isInteger():
          prevSum += ni.getInteger()
        else:
          for nextNi in ni.getList():
            q.append(nextNi)
      ans += prevSum

    return ans

```

## 1975. Maximum Matrix Sum_1975.py

```python
class Solution:
  def maxMatrixSum(self, matrix: List[List[int]]) -> int:
    absSum = 0
    minAbs = math.inf
    # 0 := even number of negatives
    # 1 := odd number of negatives
    oddNeg = 0

    for row in matrix:
      for num in row:
        absSum += abs(num)
        minAbs = min(minAbs, abs(num))
        if num < 0:
          oddNeg ^= 1

    return absSum - oddNeg * minAbs * 2

```

## 61. Rotate List_61.py

```python
class Solution:
  def rotateRight(self, head: ListNode, k: int) -> ListNode:
    if not head or not head.next or k == 0:
      return head

    tail = head
    length = 1
    while tail.next:
      tail = tail.next
      length += 1
    tail.next = head  # Circle the list.

    t = length - k % length
    for _ in range(t):
      tail = tail.next
    newHead = tail.next
    tail.next = None

    return newHead

```

## 1852. Distinct Numbers in Each Subarray_1852.py

```python
class Solution:
  def distinctNumbers(self, nums: List[int], k: int) -> List[int]:
    ans = []
    count = collections.Counter()
    distinct = 0

    for i, num in enumerate(nums):
      count[num] += 1
      if count[num] == 1:
        distinct += 1
      if i >= k:
        count[nums[i - k]] -= 1
        if count[nums[i - k]] == 0:
          distinct -= 1
      if i >= k - 1:
        ans.append(distinct)

    return ans

```

## 563. Binary Tree Tilt_563.py

```python
class Solution:
  def findTilt(self, root: Optional[TreeNode]) -> int:
    ans = 0

    def summ(root: Optional[TreeNode]) -> None:
      nonlocal ans
      if not root:
        return 0

      l = summ(root.left)
      r = summ(root.right)
      ans += abs(l - r)
      return root.val + l + r

    summ(root)
    return ans

```

## 2834. Find the Minimum Possible Sum of a Beautiful Array_2834.py

```python
class Solution:
  # Same as 2829. Determine the Minimum Sum of a k-avoiding Array
  def minimumPossibleSum(self, n: int, target: int) -> int:
    # These are the unique pairs that sum up to k (target):
    # (1, k - 1), (2, k - 2), ..., (ceil(k // 2), floor(k // 2)).
    # Our optimal strategy is to select 1, 2, ..., floor(k // 2), and then
    # choose k, k + 1, ... if necessary, as selecting any number in the range
    # [ceil(k // 2), k - 1] will result in a pair summing up to k.
    kMod = 1_000_000_007

    def trapezoid(a: int, b: int) -> int:
      """Returns sum(a..b)."""
      return (a + b) * (b - a + 1) // 2

    mid = target // 2  # floor(k // 2)
    if n <= mid:
      return trapezoid(1, n)
    return (trapezoid(1, mid) + trapezoid(target, target + (n - mid - 1))) % kMod

```

## 1996. The Number of Weak Characters in the Game_1996-2.py

```python
class Solution:
  def numberOfWeakCharacters(self, properties: List[List[int]]) -> int:
    ans = 0
    maxAttack = max(attack for attack, _ in properties)
    # maxDefenses[i] := the maximum defense for the i-th attack
    maxDefenses = [0] * (maxAttack + 2)

    for attack, defense in properties:
      maxDefenses[attack] = max(maxDefenses[attack], defense)

    for i in range(maxAttack, 0, -1):
      maxDefenses[i] = max(maxDefenses[i], maxDefenses[i + 1])

    for attack, defense in properties:
      if maxDefenses[attack + 1] > defense:
        ans += 1

    return ans

```

## 2609. Find the Longest Balanced Substring of a Binary String_2609.py

```python
class Solution:
  def findTheLongestBalancedSubstring(self, s: str) -> int:
    ans = 0

    i = 0
    while i < len(s):
      zeros = 0
      ones = 0
      while i < len(s) and s[i] == '0':
        zeros += 1
        i += 1
      while i < len(s) and s[i] == '1':
        ones += 1
        i += 1
      ans = max(ans, min(zeros, ones))

    return ans * 2

```

## 311. Sparse Matrix Multiplication_311-2.py

```python
class Solution:
  def multiply(self, mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]:
    m = len(mat1)
    n = len(mat2)
    l = len(mat2[0])
    ans = [[0] * l for _ in range(m)]
    nonZeroColIndicesInMat2 = [
        [j for j, a in enumerate(row) if a]
        for row in mat2
    ]

    for i in range(m):
      for j, a in enumerate(mat1[i]):
        if a == 0:
          continue
        # mat1s j-th column matches mat2's j-th row
        for colIndex in nonZeroColIndicesInMat2[j]:
          ans[i][colIndex] += a * mat2[j][colIndex]

    return ans

```

## 663. Equal Tree Partition_663.py

```python
class Solution:
  def checkEqualTree(self, root: Optional[TreeNode]) -> bool:
    if not root:
      return False

    seen = set()

    def dfs(root: Optional[TreeNode]) -> int:
      if not root:
        return 0

      summ = root.val + dfs(root.left) + dfs(root.right)
      seen.add(summ)
      return summ

    summ = root.val + dfs(root.left) + dfs(root.right)
    return summ % 2 == 0 and summ // 2 in seen

```

## 147. Insertion Sort List_147.py

```python
class Solution:
  def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
    dummy = ListNode(0)
    prev = dummy  # the last and thus largest of the sorted list

    while head:  # the current inserting node
      next = head.next  # Cache the next inserting node.
      if prev.val >= head.val:
        prev = dummy  # Move `prev` to the front.
      while prev.next and prev.next.val < head.val:
        prev = prev.next
      head.next = prev.next
      prev.next = head
      head = next  # Update the current inserting node.

    return dummy.next

```

## 3183. The Number of Ways to Make the Sum_3183.py

```python
class Solution:
  def numberOfWays(self, n: int) -> int:
    kMod = 1_000_000_007
    # dp[i] := the number of ways to make the sum of i using coins 1, 2, and 6
    dp = [1] + [0] * n

    for coin in (1, 2, 6):
      for i in range(coin, n + 1):
        dp[i] = (dp[i] + dp[i - coin]) % kMod

    ans = dp[n]
    if n - 4 >= 0:
      ans = (ans + dp[n - 4]) % kMod
    if n - 8 >= 0:
      ans = (ans + dp[n - 8]) % kMod
    return ans

```

## 1073. Adding Two Negabinary Numbers_1073.py

```python
class Solution:
  def addNegabinary(self, arr1: List[int], arr2: List[int]) -> List[int]:
    ans = []
    carry = 0

    while carry != 0 or arr1 or arr2:
      if arr1:
        carry += arr1.pop()
      if arr2:
        carry += arr2.pop()
      ans.append(carry & 1)
      carry = -(carry >> 1)

    while len(ans) > 1 and ans[-1] == 0:
      ans.pop()

    return ans[::-1]

```

## 911. Online Election_911.py

```python
class TopVotedCandidate:
  def __init__(self, persons: List[int], times: List[int]):
    self.times = times
    self.timeToLead = {}
    count = collections.Counter()  # {person: voted}
    lead = -1

    for person, time in zip(persons, times):
      count[person] += 1
      if count[person] >= count[lead]:
        lead = person
      self.timeToLead[time] = lead

  def q(self, t: int) -> int:
    i = bisect_right(self.times, t)
    return self.timeToLead[self.times[i - 1]]

```

## 3009. Maximum Number of Intersections on the Chart_3009.py

```python
class Solution:
  def maxIntersectionCount(self, y: List[int]) -> int:
    ans = 0
    intersectionCount = 0
    line = collections.Counter()

    for i, (a, b) in enumerate(itertools.pairwise(y)):
      start = 2 * a
      end = 2 * b + (0 if i == len(y) - 2 else -1 if b > a else 1)
      line[min(start, end)] += 1
      line[max(start, end) + 1] -= 1

    for count in sorted(line):
      intersectionCount += line[count]
      ans = max(ans, intersectionCount)

    return ans

```

## 1021. Remove Outermost Parentheses_1021.py

```python
class Solution:
  def removeOuterParentheses(self, s: str) -> str:
    ans = []
    opened = 0

    for c in s:
      if c == '(':
        opened += 1
        if opened > 1:
          ans.append(c)
      else:  # c == ')'
        opened -= 1
        if opened > 0:
          ans.append(c)

    return ''.join(ans)

```

## 1185. Day of the Week_1185.py

```python
class Solution:
  def dayOfTheWeek(self, day: int, month: int, year: int) -> str:
    def isLeapYear(year: int) -> bool:
      return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0

    week = ["Sunday", "Monday", "Tuesday",
            "Wednesday", "Thursday", "Friday", "Saturday"]
    days = [31, 29 if isLeapYear(
        year) else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    count = 0

    for i in range(1971, year):
      count += 366 if i % 4 == 0 else 365
    for i in range(month - 1):
      count += days[i]
    count += day

    return week[(count + 4) % 7]

```

## 1751. Maximum Number of Events That Can Be Attended II_1751.py

```python
class Solution:
  def maxValue(self, events: List[List[int]], k: int) -> int:
    events.sort()

    @functools.lru_cache(None)
    def dp(i: int, k: int) -> int:
      """
      Returns the maximum sum of values that you can receive by attending
      events[i..n), where k is the maximum number of attendance.
      """
      if k == 0 or i == len(events):
        return 0

      # Binary search `events` to find the first index j
      # s.t. events[j][0] > events[i][1].
      j = bisect.bisect(events, [events[i][1], math.inf, math.inf], i + 1)
      return max(events[i][2] + dp(j, k - 1), dp(i + 1, k))

    return dp(0, k)

```

## 1088. Confusing Number II_1088.py

```python
class Solution:
  def confusingNumberII(self, n: int) -> int:
    digitToRotated = [(0, 0), (1, 1), (6, 9), (8, 8), (9, 6)]

    def dfs(num: int, rotatedNum: int, unit: int) -> int:
      ans = 0 if num == rotatedNum else 1
      # Add one more digit
      for digit, rotated in digitToRotated:
        if digit == 0 and num == 0:
          continue
        nextNum = num * 10 + digit
        if nextNum > n:
          break
        ans += dfs(nextNum, rotated * unit + rotatedNum, unit * 10)
      return ans

    return dfs(0, 0, 1)

```

## 92. Reverse Linked List II_92.py

```python
class Solution:
  def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
    if left == 1:
      return self.reverseN(head, right)

    head.next = self.reverseBetween(head.next, left - 1, right - 1)
    return head

  def reverseN(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
    if n == 1:
      return head

    newHead = self.reverseN(head.next, n - 1)
    headNext = head.next
    head.next = headNext.next
    headNext.next = head
    return newHead

```

## 2419. Longest Subarray With Maximum Bitwise AND_2419.py

```python
class Solution:
  def longestSubarray(self, nums: List[int]) -> int:
    ans = 0
    maxIndex = 0
    sameNumLength = 0

    for i, num in enumerate(nums):
      if nums[i] == nums[maxIndex]:
        sameNumLength += 1
        ans = max(ans, sameNumLength)
      elif nums[i] > nums[maxIndex]:
        maxIndex = i
        sameNumLength = 1
        ans = 1
      else:
        sameNumLength = 0

    return ans

```

## 312. Burst Balloons_312.py

```python
class Solution:
  def maxCoins(self, nums: List[int]) -> int:
    n = len(nums)
    nums = [1] + nums + [1]

    @functools.lru_cache(None)
    def dp(i: int, j: int) -> int:
      """Returns maxCoins(nums[i..j])."""
      if i > j:
        return 0
      return max(dp(i, k - 1) +
                 dp(k + 1, j) +
                 nums[i - 1] * nums[k] * nums[j + 1]
                 for k in range(i, j + 1))

    return dp(1, n)

```

## 1536. Minimum Swaps to Arrange a Binary Grid_1536.py

```python
class Solution:
  def minSwaps(self, grid: List[List[int]]) -> int:
    n = len(grid)
    ans = 0
    # suffixZeros[i] := the number of suffix zeros in the i-th row
    suffixZeros = [n if 1 not in row else row[::-1].index(1) for row in grid]

    for i in range(n):
      neededZeros = n - 1 - i
      # Get the first row with suffix zeros >= `neededZeros` in suffixZeros[i:..n).
      j = next((j for j in range(i, n) if suffixZeros[j] >= neededZeros), -1)
      if j == -1:
        return -1
      # Move the rows[j] to the rows[i].
      for k in range(j, i, -1):
        suffixZeros[k] = suffixZeros[k - 1]
      ans += j - i

    return ans

```

## 1999. Smallest Greater Multiple Made of Two Digits_1999-2.py

```python
class Solution:
  def findInteger(self, k: int, digit1: int, digit2: int) -> int:
    def dfs(x: int) -> int:
      if x > 2**31 - 1:
        return -1
      if x > k and x % k == 0:
        return x
      # Skip if digit1/digit2 and x are zero.
      a = -1 if x + digit1 == 0 else dfs(x * 10 + digit1)
      b = -1 if x + digit2 == 0 else dfs(x * 10 + digit2)
      if a == -1:
        return b
      if b == -1:
        return a
      return min(a, b)

    return dfs(0)

```

## 1330. Reverse Subarray To Maximize Array Value_1330.py

```python
class Solution:
  def maxValueAfterReverse(self, nums: List[int]) -> int:
    mn = math.inf
    mx = -math.inf

    for a, b in zip(nums, nums[1:]):
      mn = min(mn, max(a, b))
      mx = max(mx, min(a, b))
    diff = max(0, (mx - mn) * 2)

    for a, b in zip(nums, nums[1:]):
      headDiff = -abs(a - b) + abs(nums[0] - b)
      tailDiff = -abs(a - b) + abs(nums[-1] - a)
      diff = max(diff, headDiff, tailDiff)

    return sum(abs(a - b) for a, b in zip(nums, nums[1:])) + diff

```

## 1644. Lowest Common Ancestor of a Binary Tree II_1644-2.py

```python
class Solution:
  def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
    def getLCA(root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
      if not root or root == p or root == q:
        return root
      left = getLCA(root.left, p, q)
      right = getLCA(root.right, p, q)
      if left and right:
        return root
      return left or right

    ans = getLCA(root, p, q)
    if ans == p:  # Search q in the subtree rooted at p.
      return ans if getLCA(p, q, q) else None
    if ans == q:  # Search p in the subtree rooted at q.
      return ans if getLCA(q, p, p) else None
    return ans  # (ans != p and ans != q) or ans is None

```

## 1745. Palindrome Partitioning IV_1745.py

```python
class Solution:
  def checkPartitioning(self, s: str) -> bool:
    @functools.lru_cache(None)
    def isPalindrome(i: int, j: int) -> bool:
      """Returns True if s[i..j] is a palindrome."""
      if i > j:
        return True
      if s[i] == s[j]:
        return isPalindrome(i + 1, j - 1)
      return False

    n = len(s)
    return any(isPalindrome(0, i) and
               isPalindrome(i + 1, j) and
               isPalindrome(j + 1, n - 1)
               for i in range(n)
               for j in range(i + 1, n - 1))

```

## 1396. Design Underground System_1396.py

```python
class UndergroundSystem:
  def __init__(self):
    # {id: (stationName, time)}
    self.checkIns = {}
    # {route: (numTrips, totalTime)}
    self.checkOuts = collections.defaultdict(lambda: [0, 0])

  def checkIn(self, id: int, stationName: str, t: int) -> None:
    self.checkIns[id] = (stationName, t)

  def checkOut(self, id: int, stationName: str, t: int) -> None:
    startStation, startTime = self.checkIns.pop(id)
    route = (startStation, stationName)
    self.checkOuts[route][0] += 1
    self.checkOuts[route][1] += t - startTime

  def getAverageTime(self, startStation: str, endStation: str) -> float:
    numTrips, totalTime = self.checkOuts[(startStation, endStation)]
    return totalTime / numTrips

```

## 152. Maximum Product Subarray_152.py

```python
class Solution:
  def maxProduct(self, nums: List[int]) -> int:
    ans = nums[0]
    dpMin = nums[0]  # the minimum so far
    dpMax = nums[0]  # the maximum so far

    for i in range(1, len(nums)):
      num = nums[i]
      prevMin = dpMin  # dpMin[i - 1]
      prevMax = dpMax  # dpMax[i - 1]
      if num < 0:
        dpMin = min(prevMax * num, num)
        dpMax = max(prevMin * num, num)
      else:
        dpMin = min(prevMin * num, num)
        dpMax = max(prevMax * num, num)

      ans = max(ans, dpMax)

    return ans

```

## 567. Permutation in String_567-2.py

```python
class Solution:
  def checkInclusion(self, s1: str, s2: str) -> bool:
    count = collections.Counter(s1)
    required = len(s1)

    for r, c in enumerate(s2):
      count[c] -= 1
      if count[c] >= 0:
        required -= 1
      if r >= len(s1):  # The window is oversized.
        count[s2[r - len(s1)]] += 1
        if count[s2[r - len(s1)]] > 0:
          required += 1
      if required == 0:
        return True

    return False

```

## 918. Maximum Sum Circular Subarray_918.py

```python
class Solution:
  def maxSubarraySumCircular(self, nums: List[int]) -> int:
    totalSum = 0
    currMaxSum = 0
    currMinSum = 0
    maxSum = -math.inf
    minSum = math.inf

    for num in nums:
      totalSum += num
      currMaxSum = max(currMaxSum + num, num)
      currMinSum = min(currMinSum + num, num)
      maxSum = max(maxSum, currMaxSum)
      minSum = min(minSum, currMinSum)

    return maxSum if maxSum < 0 else max(maxSum, totalSum - minSum)

```

## 2370. Longest Ideal Subsequence_2370.py

```python
class Solution:
  def longestIdealString(self, s: str, k: int) -> int:
    # dp[i] := the longest subsequence that ends in ('a' + i)
    dp = [0] * 26

    for c in s:
      i = ord(c) - ord('a')
      dp[i] = 1 + self._getMaxReachable(dp, i, k)

    return max(dp)

  def _getMaxReachable(self, dp: List[int], i: int, k: int) -> int:
    first = max(0, i - k)
    last = min(25, i + k)
    maxReachable = 0
    for j in range(first, last + 1):
      maxReachable = max(maxReachable, dp[j])
    return maxReachable

```

## 304. Range Sum Query 2D - Immutable_304.py

```python
class NumMatrix:
  def __init__(self, matrix: List[List[int]]):
    if not matrix:
      return

    m = len(matrix)
    n = len(matrix[0])
    # prefix[i][j] := the sum of matrix[0..i)[0..j)
    self.prefix = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m):
      for j in range(n):
        self.prefix[i + 1][j + 1] = \
            matrix[i][j] + self.prefix[i][j + 1] + \
            self.prefix[i + 1][j] - self.prefix[i][j]

  def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
    return self.prefix[row2 + 1][col2 + 1] - self.prefix[row1][col2 + 1] - \
        self.prefix[row2 + 1][col1] + self.prefix[row1][col1]

```

## 516. Longest Palindromic Subsequence_516-2.py

```python
class Solution:
  def longestPalindromeSubseq(self, s: str) -> int:
    n = len(s)
    # dp[i][j] := the length of LPS(s[i..j])
    dp = [[0] * n for _ in range(n)]

    for i in range(n):
      dp[i][i] = 1

    for d in range(1, n):
      for i in range(n - d):
        j = i + d
        if s[i] == s[j]:
          dp[i][j] = 2 + dp[i + 1][j - 1]
        else:
          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])

    return dp[0][n - 1]

```

## 1105. Filling Bookcase Shelves_1105.py

```python
class Solution:
  def minHeightShelves(self, books: List[List[int]], shelfWidth: int) -> int:
    # dp[i] := the minimum height to place the first i books
    dp = [0] + [math.inf] * len(books)

    for i in range(len(books)):
      sumThickness = 0
      maxHeight = 0
      # Place books[j..i] on a new shelf.
      for j in range(i, -1, -1):
        thickness, height = books[j]
        sumThickness += thickness
        if sumThickness > shelfWidth:
          break
        maxHeight = max(maxHeight, height)
        dp[i + 1] = min(dp[i + 1], dp[j] + maxHeight)

    return dp[-1]

```

## 1161. Maximum Level Sum of a Binary Tree_1161-2.py

```python
class Solution:
  def maxLevelSum(self, root: Optional[TreeNode]) -> int:
    # levelSums[i] := the sum of level (i + 1) (1-indexed)
    levelSums = []

    def dfs(root: Optional[TreeNode], level: int) -> None:
      if not root:
        return
      if len(levelSums) == level:
        levelSums.append(0)
      levelSums[level] += root.val
      dfs(root.left, level + 1)
      dfs(root.right, level + 1)

    dfs(root, 0)
    return 1 + levelSums.index(max(levelSums))

```

## 356. Line Reflection_356.py

```python
class Solution:
  def isReflected(self, points: List[List[int]]) -> bool:
    minX = math.inf
    maxX = -math.inf
    seen = set()

    for x, y in points:
      minX = min(minX, x)
      maxX = max(maxX, x)
      seen.add((x, y))

    summ = minX + maxX
    # (leftX + rightX) / 2 = (minX + maxX) / 2
    #  leftX = minX + maxX - rightX
    # rightX = minX + maxX - leftX

    return all((summ - x, y) in seen for x, y in points)

```

## 1335. Minimum Difficulty of a Job Schedule_1335.py

```python
class Solution:
  def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:
    n = len(jobDifficulty)
    if d > n:
      return -1

    # dp[i][k] := the minimum difficulty to schedule the first i jobs in k days
    dp = [[math.inf] * (d + 1) for _ in range(n + 1)]
    dp[0][0] = 0

    for i in range(1, n + 1):
      for k in range(1, d + 1):
        maxDifficulty = 0  # max(job[j + 1..i])
        for j in range(i - 1, k - 2, -1):  # 1-based
          maxDifficulty = max(maxDifficulty, jobDifficulty[j])  # 0-based
          dp[i][k] = min(dp[i][k], dp[j][k - 1] + maxDifficulty)

    return dp[n][d]

```

## 1540. Can Convert String in K Moves_1540.py

```python
class Solution:
  def canConvertString(self, s: str, t: str, k: int) -> bool:
    if len(s) != len(t):
      return False

    # e.g. s = "aab", t = "bbc", so shiftCount[1] = 3
    # 1. a -> b, need 1 move.
    # 2. a -> b, need 1 + 26 moves.
    # 3. b -> c, need 1 + 26 * 2 moves.
    shiftCount = [0] * 26

    for a, b in zip(s, t):
      shiftCount[(ord(b) - ord(a) + 26) % 26] += 1

    for shift in range(1, 26):
      if shift + 26 * (shiftCount[shift] - 1) > k:
        return False

    return True

```

## 60. Permutation Sequence_60.py

```python
class Solution:
  def getPermutation(self, n: int, k: int) -> str:
    ans = ''
    nums = [i + 1 for i in range(n)]
    fact = [1] * (n + 1)  # fact[i] := i!

    for i in range(2, n + 1):
      fact[i] = fact[i - 1] * i

    k -= 1  # 0-indexed

    for i in reversed(range(n)):
      j = k // fact[i]
      k %= fact[i]
      ans += str(nums[j])
      nums.pop(j)

    return ans

```

## 1721. Swapping Nodes in a Linked List_1721.py

```python
class Solution:
  def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
    p = None  # Points the k-th node from the beginning.
    q = None  # Points the k-th node from the end.

    curr = head
    while curr:
      if q:
        q = q.next
      k -= 1
      if k == 0:
        p = curr
        q = head
      curr = curr.next

    p.val, q.val = q.val, p.val
    return head

```

## 1840. Maximum Building Height_1840.py

```python
class Solution:
  def maxBuilding(self, n: int, restrictions: List[List[int]]) -> int:
    A = sorted(restrictions + [[1, 0]] + [[n, n - 1]])

    for i in range(len(A)):
      dist = A[i][0] - A[i - 1][0]
      A[i][1] = min(A[i][1], A[i - 1][1] + dist)

    for i in reversed(range(len(A) - 1)):
      dist = A[i + 1][0] - A[i][0]
      A[i][1] = min(A[i][1], A[i + 1][1] + dist)

    ans = 0

    for (l, hL), (r, hR) in zip(A, A[1:]):
      ans = max(ans, max(hL, hR) + (r - l - abs(hL - hR)) // 2)

    return ans

```

## 288. Unique Word Abbreviation_288.py

```python
class ValidWordAbbr:
  def __init__(self, dictionary: List[str]):
    self.dict = set(dictionary)
    # T := unique, F := not unique
    self.abbrUnique = {}

    for word in self.dict:
      abbr = self._getAbbr(word)
      self.abbrUnique[abbr] = abbr not in self.abbrUnique

  def isUnique(self, word: str) -> bool:
    abbr = self._getAbbr(word)
    return abbr not in self.abbrUnique or self.abbrUnique[abbr] and word in self.dict

  def _getAbbr(self, s: str) -> str:
    n = len(s)
    if n <= 2:
      return s
    return s[0] + str(n - 2) + s[-1]

```

## 713. Subarray Product Less Than K_713.py

```python
class Solution:
  def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
    if k <= 1:
      return 0

    ans = 0
    prod = 1

    j = 0
    for i, num in enumerate(nums):
      prod *= num
      while prod >= k:
        prod /= nums[j]
        j += 1
      ans += i - j + 1

    return ans

```

## 2707. Extra Characters in a String_2707.py

```python
class Solution:
  # Similar to 139. Word Break
  def minExtraChar(self, s: str, dictionary: List[str]) -> int:
    n = len(s)
    dictionarySet = set(dictionary)
    # dp[i] := the minimum extra letters if breaking up s[0..i) optimally
    dp = [0] + [n] * n

    for i in range(1, n + 1):
      for j in range(i):
        if s[j:i] in dictionarySet:
          dp[i] = min(dp[i], dp[j])
        else:
          dp[i] = min(dp[i], dp[j] + i - j)

    return dp[n]

```

## 2. Add Two Numbers_2.py

```python
class Solution:
  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
    dummy = ListNode(0)
    curr = dummy
    carry = 0

    while carry or l1 or l2:
      if l1:
        carry += l1.val
        l1 = l1.next
      if l2:
        carry += l2.val
        l2 = l2.next
      curr.next = ListNode(carry % 10)
      carry //= 10
      curr = curr.next

    return dummy.next

```

## 2233. Maximum Product After K Increments_2233.py

```python
class Solution:
  def maximumProduct(self, nums: List[int], k: int) -> int:
    kMod = 1_000_000_007
    ans = 1
    minHeap = nums.copy()
    heapq.heapify(minHeap)

    for _ in range(k):
      minNum = heapq.heappop(minHeap)
      heapq.heappush(minHeap, minNum + 1)

    while minHeap:
      ans *= heapq.heappop(minHeap)
      ans %= kMod

    return ans

```

## 170. Two Sum III - Data structure design_170.py

```python
class TwoSum:
  def __init__(self):
    self.count = collections.Counter()

  def add(self, number: int) -> None:
    self.count[number] += 1

  def find(self, value: int) -> bool:
    for key, freq in self.count.items():
      remain = value - key
      if key == remain and freq > 1:
        return True
      if key != remain and remain in self.count:
        return True

    return False

```

## 2265. Count Nodes Equal to Average of Subtree_2265.py

```python
class Solution:
  def averageOfSubtree(self, root: Optional[TreeNode]) -> int:
    ans = 0

    def dfs(root: Optional[TreeNode]) -> Tuple[int, int]:
      nonlocal ans
      if not root:
        return (0, 0)
      leftSum, leftCount = dfs(root.left)
      rightSum, rightCount = dfs(root.right)
      summ = root.val + leftSum + rightSum
      count = 1 + leftCount + rightCount
      if summ // count == root.val:
        ans += 1
      return (summ, count)

    dfs(root)
    return ans

```

## 1100. Find K-Length Substrings With No Repeated Characters_1100.py

```python
class Solution:
  def numKLenSubstrNoRepeats(self, s: str, k: int) -> int:
    ans = 0
    unique = 0
    count = collections.Counter()

    for i, c in enumerate(s):
      count[c] += 1
      if count[c] == 1:
        unique += 1
      if i >= k:
        count[s[i - k]] -= 1
        if count[s[i - k]] == 0:
          unique -= 1
        if unique == k:
          ans += 1

    return ans

```

## 2107. Number of Unique Flavors After Sharing K Candies_2107.py

```python
class Solution:
  def shareCandies(self, candies: List[int], k: int) -> int:
    ans = 0
    count = collections.Counter(candies)
    unique = len(count)

    for i, candy in enumerate(candies):
      count[candy] -= 1
      if count[candy] == 0:
        del count[candy]
        unique -= 1
      if i >= k:
        count[candies[i - k]] += 1
        if count[candies[i - k]] == 1:
          unique += 1
      if i >= k - 1:
        ans = max(ans, unique)

    return ans

```

## 759. Employee Free Time_759.py

```python
class Solution:
  def employeeFreeTime(self, schedule: '[[Interval]]') -> '[Interval]':
    ans = []
    intervals = []

    for s in schedule:
      intervals.extend(s)

    intervals.sort(key=lambda x: x.start)

    prevEnd = intervals[0].end

    for interval in intervals:
      if interval.start > prevEnd:
        ans.append(Interval(prevEnd, interval.start))
      prevEnd = max(prevEnd, interval.end)

    return ans

```

## 824. Goat Latin_824.py

```python
class Solution:
  def toGoatLatin(self, sentence: str) -> str:
    ans = []
    kVowels = 'aeiouAEIOU'

    i = 1
    for word in sentence.split():
      if i > 1:
        ans.append(' ')
      if word[0] in kVowels:
        ans.append(word)
      else:
        ans.append(word[1:] + word[0])
      ans.append('ma' + 'a' * i)
      i += 1

    return ''.join(ans)

```

## 517. Super Washing Machines_517.py

```python
class Solution:
  def findMinMoves(self, machines: List[int]) -> int:
    dresses = sum(machines)

    if dresses % len(machines) != 0:
      return -1

    ans = 0
    average = dresses // len(machines)
    inout = 0

    for dress in machines:
      inout += dress - average
      ans = max(ans, abs(inout), dress - average)

    return ans

```

## 3027. Find the Number of Ways to Place People II_3027.py

```python
class Solution:
  # Same as 3025. Find the Number of Ways to Place People I
  def numberOfPairs(self, points: List[List[int]]) -> int:
    ans = 0

    points.sort(key=lambda x: (x[0], -x[1]))

    for i, (_, yi) in enumerate(points):
      maxY = -math.inf
      for j in range(i + 1, len(points)):
        _, yj = points[j]
        # Chisato is in the upper-left corner at (xi, yi), and Takina is in the
        # lower-right corner at (xj, yj). Also, if yj > maxY, it means that
        # nobody other than Chisato and Takina is inside or on the fence.
        if yi >= yj > maxY:
          ans += 1
          maxY = yj

    return ans

```

## 2950. Number of Divisible Substrings_2950.py

```python
class Solution:
  def countDivisibleSubstrings(self, word: str) -> int:
    # Let f(c) = d, where d = 1, 2, ..., 9.
    # Rephrase the question to return the number of substrings that satisfy
    #    f(c1) + f(c2) + ... + f(ck) // k = avg
    # => f(c1) + f(c2) + ... + f(ck) - k * avg, where avg in [1, 9].
    ans = 0

    def f(c: str) -> int:
      return 9 - (ord('z') - ord(c)) // 3

    for avg in range(1, 10):
      prefix = 0
      prefixCount = collections.Counter({0: 1})
      for c in word:
        prefix += f(c) - avg
        ans += prefixCount[prefix]
        prefixCount[prefix] += 1

    return ans

```

## 1433. Check If a String Can Break Another String_1433.py

```python
class Solution:
  def checkIfCanBreak(self, s1: str, s2: str) -> bool:
    count1 = collections.Counter(s1)
    count2 = collections.Counter(s2)

    def canBreak(count1: Dict[str, int], count2: Dict[str, int]) -> bool:
      """Returns True if count1 can break count2."""
      diff = 0
      for c in string.ascii_lowercase:
        diff += count2[c] - count1[c]
        # count2 is alphabetically greater than count1.
        if diff < 0:
          return False
      return True

    return canBreak(count1, count2) or canBreak(count2, count1)

```

## 1243. Array Transformation_1243.py

```python
class Solution:
  def transformArray(self, arr: List[int]) -> List[int]:
    if len(arr) < 3:
      return arr

    ans = []

    while ans != arr:
      ans = arr[:]
      for i in range(1, len(arr) - 1):
        if ans[i - 1] > ans[i] < ans[i + 1]:
          arr[i] += 1
        elif ans[i - 1] < ans[i] > ans[i + 1]:
          arr[i] -= 1

    return ans

```

## 90. Subsets II_90.py

```python
class Solution:
  def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
    ans = []

    def dfs(s: int, path: List[int]) -> None:
      ans.append(path)
      if s == len(nums):
        return

      for i in range(s, len(nums)):
        if i > s and nums[i] == nums[i - 1]:
          continue
        dfs(i + 1, path + [nums[i]])

    nums.sort()
    dfs(0, [])
    return ans

```

## 2680. Maximum OR_2680.py

```python
class Solution:
  def maximumOr(self, nums: List[int], k: int) -> int:
    n = len(nums)
    # prefix[i] := nums[0] | nums[1] | ... | nums[i - 1]
    prefix = [0] * n
    # suffix[i] := nums[i + 1] | nums[i + 2] | ... nums[n - 1]
    suffix = [0] * n

    for i in range(1, n):
      prefix[i] = prefix[i - 1] | nums[i - 1]

    for i in range(n - 2, -1, -1):
      suffix[i] = suffix[i + 1] | nums[i + 1]

    # For each num, greedily shift it left by k bits.
    return max(p | num << k | s for num, p, s in zip(nums, prefix, suffix))

```

## 2660. Determine the Winner of a Bowling Game_2660.py

```python
class Solution:
  def isWinner(self, player1: List[int], player2: List[int]) -> int:
    def getScore(player: List[int]) -> int:
      kInvalid = -3
      score = 0
      last10 = kInvalid
      for i, p in enumerate(player):
        score += p if i - last10 > 2 else p * 2
        if p == 10:
          last10 = i
      return score

    score1 = getScore(player1)
    score2 = getScore(player2)
    if score1 > score2:
      return 1
    if score2 > score1:
      return 2
    return 0

```

## 1763. Longest Nice Substring_1763.py

```python
class Solution:
  def longestNiceSubstring(self, s: str) -> str:
    if len(s) < 2:
      return ''

    seen = set(s)

    for i, c in enumerate(s):
      # If both upper and lower case letters exists in the string, keep moving,
      # else take the erroneous character as a partition and check for its left
      # and right parts to be nice strings.
      if c.swapcase() not in seen:
        prefix = self.longestNiceSubstring(s[:i])
        suffix = self.longestNiceSubstring(s[i + 1:])
        return max(prefix, suffix, key=len)

    return s

```

## 515. Find Largest Value in Each Tree Row_515-2.py

```python
class Solution:
  def largestValues(self, root: Optional[TreeNode]) -> List[int]:
    ans = []

    def dfs(root: Optional[TreeNode], depth: int) -> None:
      if not root:
        return
      if depth + 1 > len(ans):
        ans.append(root.val)
      else:
        ans[depth] = max(ans[depth], root.val)

      dfs(root.left, depth + 1)
      dfs(root.right, depth + 1)

    dfs(root, 0)
    return ans

```

## 3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K_3007.py

```python
class Solution:
  def findMaximumNumber(self, k: int, x: int) -> int:
    def getSumPrices(num: int) -> int:
      """Returns the sum of prices of all numbers from 1 to `num`."""
      sumPrices = 0
      # Increment `num` to account the 0-th row in the count of groups.
      num += 1
      for i in range(num.bit_length(), 0, -1):
        if i % x == 0:
          groupSize = 1 << i
          halfGroupSize = 1 << i - 1
          sumPrices += num // groupSize * halfGroupSize
          sumPrices += max(0, (num % groupSize) - halfGroupSize)
      return sumPrices

    return bisect.bisect_right(range(1, 10**15), k,
                               key=lambda m: getSumPrices(m))

```

## 1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target_1546.py

```python
class Solution:
  def maxNonOverlapping(self, nums: List[int], target: int) -> int:
    # Ending the subarray ASAP always has a better result.
    ans = 0
    prefix = 0
    prefixes = {0}

    # Greedily find the subarrays that equal to the target.
    for num in nums:
      # Check if there is a subarray ends in here and equals to the target.
      prefix += num
      if prefix - target in prefixes:
        # Find one and discard all the prefixes that have been used.
        ans += 1
        prefix = 0
        prefixes = {0}
      else:
        prefixes.add(prefix)

    return ans

```

## 609. Find Duplicate File in System_609.py

```python
class Solution:
  def findDuplicate(self, paths: List[str]) -> List[List[str]]:
    contentToPathFiles = collections.defaultdict(list)

    for path in paths:
      words = path.split(' ')
      rootPath = words[0]  # "root/d1/d2/.../dm"
      for fileAndContent in words[1:]:  # "fn.txt(fn_content)"
        l = fileAndContent.find('(')
        r = fileAndContent.find(')')
        # "fn.txt"
        file = fileAndContent[:l]
        # "fn_content"
        content = fileAndContent[l + 1:r]
        # "root/d1/d2/.../dm/fn.txt"
        filePath = rootPath + '/' + file
        contentToPathFiles[content].append(filePath)

    return [filePath for filePath in contentToPathFiles.values() if len(filePath) > 1]

```

## 133. Clone Graph_133.py

```python
class Solution:
  def cloneGraph(self, node: 'Node') -> 'Node':
    if not node:
      return None

    q = collections.deque([node])
    map = {node: Node(node.val)}

    while q:
      u = q.popleft()
      for v in u.neighbors:
        if v not in map:
          map[v] = Node(v.val)
          q.append(v)
        map[u].neighbors.append(map[v])

    return map[node]

```

## 2614. Prime In Diagonal_2614.py

```python
class Solution:
  def diagonalPrime(self, nums: List[List[int]]) -> int:
    def isPrime(n: int) -> bool:
      if n <= 1:
        return False
      for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
          return False
      return True

    primes1 = [row[i]
               for i, row in enumerate(nums) if isPrime(row[i])]
    primes2 = [row[-i - 1]
               for i, row in enumerate(nums) if isPrime(row[-i - 1])]
    return max(max(primes1) if primes1 else 0,
               max(primes2) if primes2 else 0)

```

## 1390. Four Divisors_1390.py

```python
class Solution:
  def sumFourDivisors(self, nums: List[int]) -> int:
    ans = 0

    for num in nums:
      divisor = 0
      for i in range(2, math.isqrt(num) + 1):
        if num % i == 0:
          if divisor == 0:
            divisor = i
          else:
            divisor = 0
            break
      if divisor > 0 and divisor * divisor < num:
        ans += 1 + num + divisor + num // divisor

    return ans

```

## 1229. Meeting Scheduler_1229.py

```python
class Solution:
  def minAvailableDuration(self, slots1: List[List[int]], slots2: List[List[int]], duration: int) -> List[int]:
    slots1.sort()
    slots2.sort()

    i = 0  # slots1's index
    j = 0  # slots2's index

    while i < len(slots1) and j < len(slots2):
      start = max(slots1[i][0], slots2[j][0])
      end = min(slots1[i][1], slots2[j][1])
      if start + duration <= end:
        return [start, start + duration]
      if slots1[i][1] < slots2[j][1]:
        i += 1
      else:
        j += 1

    return []

```

## 1989. Maximum Number of People That Can Be Caught in Tag_1989.py

```python
class Solution:
  def catchMaximumAmountofPeople(self, team: List[int], dist: int) -> int:
    ans = 0
    i = 0  # 0s index
    j = 0  # 1s index

    while i < len(team) and j < len(team):
      if i + dist < j or team[i] != 0:
        # Find the next 0 that can be caught by 1.
        i += 1
      elif j + dist < i or team[j] != 1:
        # Find the next 1 that can catch 0.
        j += 1
      else:
        # team[j] catches team[i], so move both.
        ans += 1
        i += 1
        j += 1

    return ans

```

## 1451. Rearrange Words in a Sentence_1451.py

```python
class Solution:
  def arrangeWords(self, text: str) -> str:
    words = text.split()
    count = collections.defaultdict(list)

    for word in words:
      count[len(word)].append(word.lower())

    c2 = OrderedDict(sorted(count.items()))

    ans = []

    for l in c2:
      for word in c2[l]:
        ans.append(word)

    ans[0] = ans[0].capitalize()

    return ' '.join(ans)

```

## 2657. Find the Prefix Common Array of Two Arrays_2657.py

```python
class Solution:
  def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:
    n = len(A)
    prefixCommon = 0
    ans = []
    count = [0] * (n + 1)

    for a, b in zip(A, B):
      count[a] += 1
      if count[a] == 2:
        prefixCommon += 1
      count[b] += 1
      if count[b] == 2:
        prefixCommon += 1
      ans.append(prefixCommon)

    return ans

```

## 378. Kth Smallest Element in a Sorted Matrix_378.py

```python
class Solution:
  def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
    minHeap = []  # (matrix[i][j], i, j)

    i = 0
    while i < k and i < len(matrix):
      heapq.heappush(minHeap, (matrix[i][0], i, 0))
      i += 1

    while k > 1:
      k -= 1
      _, i, j = heapq.heappop(minHeap)
      if j + 1 < len(matrix[0]):
        heapq.heappush(minHeap, (matrix[i][j + 1], i, j + 1))

    return minHeap[0][0]

```

## 880. Decoded String at Index_880.py

```python
class Solution:
  def decodeAtIndex(self, s: str, k: int) -> str:
    size = 0

    for c in s:
      if c.isdigit():
        size *= int(c)
      else:
        size += 1

    for c in reversed(s):
      k %= size
      if k == 0 and c.isalpha():
        return c
      if c.isdigit():
        size //= int(c)
      else:
        size -= 1

```

## 232. Implement Queue using Stacks_232.py

```python
class MyQueue:
  def __init__(self):
    self.input = []
    self.output = []

  def push(self, x: int) -> None:
    self.input.append(x)

  def pop(self) -> int:
    self.peek()
    return self.output.pop()

  def peek(self) -> int:
    if not self.output:
      while self.input:
        self.output.append(self.input.pop())
    return self.output[-1]

  def empty(self) -> bool:
    return not self.input and not self.output

```

## 2903. Find Indices With Index and Value Difference I_2903.py

```python
class Solution:
  def findIndices(self, nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:
    # nums[minIndex] := the minimum number with enough index different from the
    # current number
    minIndex = 0
    # nums[maxIndex] := the maximum number with enough index different from the
    # current number
    maxIndex = 0

    for i in range(indexDifference, len(nums)):
      if nums[i - indexDifference] < nums[minIndex]:
        minIndex = i - indexDifference
      if nums[i - indexDifference] > nums[maxIndex]:
        maxIndex = i - indexDifference
      if nums[i] - nums[minIndex] >= valueDifference:
        return [i, minIndex]
      if nums[maxIndex] - nums[i] >= valueDifference:
        return [i, maxIndex]

    return [-1, -1]

```

## 1987. Number of Unique Good Subsequences_1987.py

```python
class Solution:
  # Similar to 940. Distinct Subsequences II
  def numberOfUniqueGoodSubsequences(self, binary: str) -> int:
    kMod = 1_000_000_007
    # endsIn[i] := the number of subsequence that end in ('0' + i)
    endsIn = {'0': 0, '1': 0}

    for c in binary:
      endsIn[c] = sum(endsIn.values()) % kMod
      # Don't count '0' since we want to avoid the leading zeros case.
      # However, we can always count '1'.
      if c == '1':
        endsIn['1'] += 1

    # Count '0' in the end.
    return (sum(endsIn.values()) + ('0' in binary)) % kMod

```

## 2541. Minimum Operations to Make Array Equal II_2541.py

```python
class Solution:
  def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:
    if k == 0:
      return 0 if nums1 == nums2 else -1

    ans = 0
    opsDiff = 0  # the number of increments - number of decrements

    for num1, num2 in zip(nums1, nums2):
      diff = num1 - num2
      if diff == 0:
        continue
      if diff % k != 0:
        return -1
      ops = diff // k
      opsDiff += ops
      ans += abs(ops)

    return ans // 2 if opsDiff == 0 else -1

```

## 414. Third Maximum Number_414-2.py

```python
class Solution:
  def thirdMax(self, nums: List[int]) -> int:
    minHeap = []
    seen = set()

    for num in nums:
      if num not in seen:
        seen.add(num)
        heapq.heappush(minHeap, num)
        if len(minHeap) > 3:
          heapq.heappop(minHeap)

    if len(minHeap) == 2:
      heapq.heappop(minHeap)

    return minHeap[0]

```

## 1889. Minimum Space Wasted From Packaging_1889.py

```python
class Solution:
  def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:
    ans = math.inf

    packages.sort()

    for box in boxes:
      box.sort()
      if box[-1] < packages[-1]:
        continue
      accu = 0
      i = 0
      for b in box:
        j = bisect.bisect(packages, b, i)
        accu += b * (j - i)
        i = j
      ans = min(ans, accu)

    return -1 if ans == math.inf else (ans - sum(packages)) % int(1e9 + 7)

```

## 1442. Count Triplets That Can Form Two Arrays of Equal XOR_1442.py

```python
class Solution:
  def countTriplets(self, arr: List[int]) -> int:
    ans = 0
    xors = [0]
    prefix = 0

    for i, a in enumerate(arr):
      prefix ^= a
      xors.append(prefix)

    for j in range(1, len(arr)):
      for i in range(0, j):
        xors_i = xors[j] ^ xors[i]
        for k in range(j, len(arr)):
          xors_k = xors[k + 1] ^ xors[j]
          if xors_i == xors_k:
            ans += 1

    return ans

```

## 1913. Maximum Product Difference Between Two Pairs_1913.py

```python
class Solution:
  def maxProductDifference(self, nums: List[int]) -> int:
    max1 = -math.inf
    max2 = -math.inf
    min1 = math.inf
    min2 = math.inf

    for num in nums:
      if num > max1:
        max2 = max1
        max1 = num
      elif num > max2:
        max2 = num
      if num < min1:
        min2 = min1
        min1 = num
      elif num < min2:
        min2 = num

    return max1 * max2 - min1 * min2

```

## 1041. Robot Bounded In Circle_1041.py

```python
class Solution:
  def isRobotBounded(self, instructions: str) -> bool:
    x = 0
    y = 0
    d = 0
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    for instruction in instructions:
      if instruction == 'G':
        x += directions[d][0]
        y += directions[d][1]
      elif instruction == 'L':
        d = (d + 3) % 4
      else:
        d = (d + 1) % 4

    return (x, y) == (0, 0) or d > 0

```

## 2563. Count the Number of Fair Pairs_2563.py

```python
class Solution:
  def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:
    # nums[i] + nums[j] == nums[j] + nums[i], so the condition that i < j
    # degrades to i != j and we can sort the array.
    nums.sort()

    def countLess(summ: int) -> int:
      res = 0
      i = 0
      j = len(nums) - 1
      while i < j:
        while i < j and nums[i] + nums[j] > summ:
          j -= 1
        res += j - i
        i += 1
      return res

    return countLess(upper) - countLess(lower - 1)

```

## 77. Combinations_77.py

```python
class Solution:
  def combine(self, n: int, k: int) -> List[List[int]]:
    ans = []

    def dfs(s: int, path: List[int]) -> None:
      if len(path) == k:
        ans.append(path.copy())
        return

      for i in range(s, n + 1):
        path.append(i)
        dfs(i + 1, path)
        path.pop()

    dfs(1, [])
    return ans

```

## 2090. K Radius Subarray Averages_2090.py

```python
class Solution:
  def getAverages(self, nums: List[int], k: int) -> List[int]:
    n = len(nums)
    size = 2 * k + 1
    ans = [-1] * n
    if size > n:
      return ans

    summ = sum(nums[:size])

    for i in range(k, n - k):
      ans[i] = summ // size
      if i + k + 1 < n:
        summ += nums[i + k + 1] - nums[i - k]

    return ans

```

## 1805. Number of Different Integers in a String_1805.py

```python
class Solution:
  def numDifferentIntegers(self, word: str) -> int:
    nums = set()
    curr = []

    for c in word:
      if c.isdigit():
        curr.append(c)
      elif curr:
        nums.add(''.join(self._removeLeadingZeros(curr)))
        curr = []

    if curr:
      nums.add(''.join(self._removeLeadingZeros(curr)))

    return len(nums)

  def _removeLeadingZeros(self, s: str) -> str:
    index = next((i for i, c in enumerate(s) if c != '0'), -1)
    return ['0'] if index == -1 else s[index:]

```

## 3195. Find the Minimum Area to Cover All Ones I_3195.py

```python
class Solution:
  def minimumArea(self, grid: List[List[int]]) -> int:
    x1 = math.inf
    y1 = math.inf
    x2 = 0
    y2 = 0

    for i, row in enumerate(grid):
      for j, num in enumerate(row):
        if num == 1:
          x1 = min(x1, i)
          y1 = min(y1, j)
          x2 = max(x2, i)
          y2 = max(y2, j)

    return (x2 - x1 + 1) * (y2 - y1 + 1)

```

## 1404. Number of Steps to Reduce a Number in Binary Representation to One_1404.py

```python
class Solution:
  def numSteps(self, s: str) -> int:
    ans = 0
    chars = list(s)

    # All the trailing 0s can be popped by 1 step.
    while chars[-1] == '0':
      chars.pop()
      ans += 1

    if ''.join(chars) == '1':
      return ans

    # `s` is now odd, so add 1 to `s` and cost 1 step.
    # All the 1s will become 0s and can be popped by 1 step.
    # All the 0s will become 1s and can be popped by 2 steps (adding 1 then
    # dividing by 2).
    return ans + 1 + sum(1 if c == '1' else 2 for c in chars)

```

## 215. Kth Largest Element in an Array_215-2.py

```python
class Solution:
  def findKthLargest(self, nums: List[int], k: int) -> int:
    def quickSelect(l: int, r: int, k: int) -> int:
      pivot = nums[r]

      nextSwapped = l
      for i in range(l, r):
        if nums[i] >= pivot:
          nums[nextSwapped], nums[i] = nums[i], nums[nextSwapped]
          nextSwapped += 1
      nums[nextSwapped], nums[r] = nums[r], nums[nextSwapped]

      count = nextSwapped - l + 1  # Number of nums >= pivot
      if count == k:
        return nums[nextSwapped]
      if count > k:
        return quickSelect(l, nextSwapped - 1, k)
      return quickSelect(nextSwapped + 1, r, k - count)

    return quickSelect(0, len(nums) - 1, k)

```

## 487. Max Consecutive Ones II_487.py

```python
class Solution:
  def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
    ans = 0
    zeros = 0

    l = 0
    for r, num in enumerate(nums):
      if num == 0:
        zeros += 1
      while zeros == 2:
        if nums[l] == 0:
          zeros -= 1
        l += 1
      ans = max(ans, r - l + 1)

    return ans

```

## 1110. Delete Nodes And Return Forest_1110.py

```python
class Solution:
  def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:
    ans = []
    toDeleteSet = set(to_delete)

    def dfs(root: TreeNode, isRoot: bool) -> TreeNode:
      if not root:
        return None

      deleted = root.val in toDeleteSet
      if isRoot and not deleted:
        ans.append(root)

      # If root is deleted, both children have the possibility to be a new root
      root.left = dfs(root.left, deleted)
      root.right = dfs(root.right, deleted)
      return None if deleted else root

    dfs(root, True)
    return ans

```

## 2838. Maximum Coins Heroes Can Collect_2838.py

```python
class Solution:
  def maximumCoins(self, heroes: List[int], monsters: List[int], coins: List[int]) -> List[int]:
    monsterAndCoins = sorted(list(zip(monsters, coins)))
    coinsPrefix = [0] + \
        list(itertools.accumulate(coin for _, coin in monsterAndCoins))
    return [coinsPrefix[self._firstGreaterEqual(monsterAndCoins, hero)] for hero in heroes]

  def _firstGreaterEqual(self, monsterAndCoins: List[tuple[int, int]], hero: int) -> int:
    l, r = 0, len(monsterAndCoins)
    while l < r:
      m = (l + r) // 2
      if monsterAndCoins[m][0] > hero:
        r = m
      else:
        l = m + 1
    return l

```

## 410. Split Array Largest Sum_410.py

```python
class Solution:
  def splitArray(self, nums: List[int], k: int) -> int:
    prefix = list(itertools.accumulate(nums, initial=0))

    @functools.lru_cache(None)
    def dp(i: int, k: int) -> int:
      """
      Returns the minimum of the maximum sum to split the first i numbers into
      k groups.
      """
      if k == 1:
        return prefix[i]
      return min(max(dp(j, k - 1), prefix[i] - prefix[j])
                 for j in range(k - 1, i))

    return dp(len(nums), k)

```

## 1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree_1379.py

```python
class Solution:
  def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:
    ans = None

    def dfs(original: TreeNode, cloned: TreeNode) -> None:
      nonlocal ans
      if ans:
        return
      if not original:
        return
      if original == target:
        ans = cloned
        return

      dfs(original.left, cloned.left)
      dfs(original.right, cloned.right)

    dfs(original, cloned)
    return ans

```

## 2863. Maximum Length of Semi-Decreasing Subarrays_2863.py

```python
class Solution:
  def maxSubarrayLength(self, nums: List[int]) -> int:
    ans = 0
    stack = []

    for i in range(len(nums) - 1, -1, -1):
      # If nums[stack[-1]] <= nums[i], stack[-1] is better than i.
      # So, no need to append it.
      if not stack or nums[stack[-1]] > nums[i]:
        stack.append(i)

    for i, num in enumerate(nums):
      while stack and num > nums[stack[-1]]:
        ans = max(ans, stack.pop() - i + 1)

    return ans

```

## 697. Degree of an Array_697.py

```python
class Solution:
  def findShortestSubArray(self, nums: List[int]) -> int:
    ans = 0
    degree = 0
    debut = {}
    count = collections.Counter()

    for i, num in enumerate(nums):
      debut.setdefault(num, i)
      count[num] += 1
      if count[num] > degree:
        degree = count[num]
        ans = i - debut[num] + 1
      elif count[num] == degree:
        ans = min(ans, i - debut[num] + 1)

    return ans

```

## 3229. Minimum Operations to Make Array Equal to Target_3229.py

```python
class Solution:
  # Similar to 1526. Minimum Number of Increments on Subarrays to Form a Target Array
  def minimumOperations(self, nums: List[int], target: List[int]) -> int:
    ans = abs(nums[0] - target[0])

    for (prevNum, prevTarget), (currNum, currTarget) in \
            itertools.pairwise(zip(nums, target)):
      currDiff = currTarget - currNum
      prevDiff = prevTarget - prevNum
      if currDiff >= 0 and prevDiff >= 0:
        ans += max(0, currDiff - prevDiff)
      elif currDiff <= 0 and prevDiff <= 0:
        ans += max(0, abs(currDiff) - abs(prevDiff))
      else:
        ans += abs(currDiff)

    return ans

```

## 1582. Special Positions in a Binary Matrix_1582.py

```python
class Solution:
  def numSpecial(self, mat: List[List[int]]) -> int:
    m = len(mat)
    n = len(mat[0])
    ans = 0
    rowOnes = [0] * m
    colOnes = [0] * n

    for i in range(m):
      for j in range(n):
        if mat[i][j] == 1:
          rowOnes[i] += 1
          colOnes[j] += 1

    for i in range(m):
      for j in range(n):
        if mat[i][j] == 1 and rowOnes[i] == 1 and colOnes[j] == 1:
          ans += 1

    return ans

```

## 1191. K-Concatenation Maximum Sum_1191.py

```python
class Solution:
  def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:
    kMod = 1_000_000_007
    sz = len(arr) * (1 if k == 1 else 2)
    summ = sum(arr)
    # The concatenated array will be [arr1, arr2, ..., arrk].
    # If sum(arr) > 0 and k > 2, then arr2, ..., arr(k - 1) should be included.
    # Equivalently, maxSubarraySum is from arr1 and arrk.
    if summ > 0 and k > 2:
      return (self.kadane(arr, sz) + summ * (k - 2)) % kMod
    return self.kadane(arr, sz) % kMod

  def kadane(self, A: List[int], sz: int) -> int:
    ans = 0
    summ = 0
    for i in range(sz):
      a = A[i % len(A)]
      summ = max(a, summ + a)
      ans = max(ans, summ)
    return ans

```

## 661. Image Smoother_661.py

```python
class Solution:
  def imageSmoother(self, M: List[List[int]]) -> List[List[int]]:
    m = len(M)
    n = len(M[0])
    ans = [[0 for j in range(n)] for i in range(m)]

    for i in range(m):
      for j in range(n):
        ones = 0
        count = 0
        for y in range(max(0, i - 1), min(m, i + 2)):
          for x in range(max(0, j - 1), min(n, j + 2)):
            ones += M[y][x]
            count += 1
        ans[i][j] = ones // count

    return ans

```

## 2658. Maximum Number of Fish in a Grid_2658.py

```python
class Solution:
  def findMaxFish(self, grid: List[List[int]]) -> int:
    def dfs(i: int, j: int) -> int:
      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):
        return 0
      if grid[i][j] == 0:
        return 0
      caughtFish = grid[i][j]
      grid[i][j] = 0  # Mark 0 as visited
      return caughtFish + \
          dfs(i + 1, j) + dfs(i - 1, j) + \
          dfs(i, j + 1) + dfs(i, j - 1)

    return max(dfs(i, j)
               for i in range(len(grid))
               for j in range(len(grid[0])))

```

## 513. Find Bottom Left Tree Value_513-2.py

```python
class Solution:
  def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
    ans = 0
    maxDepth = 0

    def dfs(root: Optional[TreeNode], depth: int) -> None:
      nonlocal ans
      nonlocal maxDepth
      if not root:
        return
      if depth > maxDepth:
        maxDepth = depth
        ans = root.val

      dfs(root.left, depth + 1)
      dfs(root.right, depth + 1)

    dfs(root, 1)
    return ans

```

## 2445. Number of Nodes With Value One_2445.py

```python
class Solution:
  def numberOfNodes(self, n: int, queries: List[int]) -> int:
    # flipped[i] := True if we should flip all the values in the subtree rooted
    # at i
    flipped = [False] * (n + 1)

    for query in queries:
      flipped[query] = flipped[query] ^ True

    def dfs(label: int, value: int) -> int:
      if label > n:
        return 0
      value ^= flipped[label]
      return value + dfs(label * 2, value) + dfs(label * 2 + 1, value)

    return dfs(1, 0)

```

## 871. Minimum Number of Refueling Stops_871-2.py

```python
class Solution:
  def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:
    ans = 0
    i = 0  # station's index
    curr = startFuel
    maxHeap = []

    while curr < target:
      # Add all the reachable stops to maxHeap
      while i < len(stations) and stations[i][0] <= curr:
        heapq.heappush(maxHeap, -stations[i][1])
        i += 1
      if not maxHeap:  # Can't be refueled.
        return -1
      curr -= heapq.heappop(maxHeap)  # Pop out the largest gas.
      ans += 1  # Then, refuel once.

    return ans

```

## 1040. Moving Stones Until Consecutive II_1040.py

```python
class Solution:
  def numMovesStonesII(self, stones: List[int]) -> List[int]:
    n = len(stones)
    minMoves = n

    stones.sort()

    l = 0
    for r, stone in enumerate(stones):
      while stone - stones[l] + 1 > n:
        l += 1
      alreadyStored = r - l + 1
      if alreadyStored == n - 1 and stone - stones[l] + 1 == n - 1:
        minMoves = 2
      else:
        minMoves = min(minMoves, n - alreadyStored)

    return [minMoves, max(stones[n - 1] - stones[1] - n + 2, stones[n - 2] - stones[0] - n + 2)]

```

## 995. Minimum Number of K Consecutive Bit Flips_995.py

```python
class Solution:
  def minKBitFlips(self, nums: List[int], k: int) -> int:
    ans = 0
    flippedTime = 0

    for i, num in enumerate(nums):
      if i >= k and nums[i - k] == 2:
        flippedTime -= 1
      if flippedTime % 2 == num:
        if i + k > len(nums):
          return -1
        ans += 1
        flippedTime += 1
        nums[i] = 2

    return ans

```

## 3160. Find the Number of Distinct Colors Among the Balls_3160.py

```python
class Solution:
  def queryResults(self, limit: int, queries: List[List[int]]) -> List[int]:
    ans = []
    ballToColor = {}
    colorCount = collections.Counter()

    for ball, color in queries:
      if ball in ballToColor:
        prevColor = ballToColor[ball]
        colorCount[prevColor] -= 1
        if colorCount[prevColor] == 0:
          del colorCount[prevColor]
      ballToColor[ball] = color
      colorCount[color] += 1
      ans.append(len(colorCount))

    return ans

```

## 2561. Rearranging Fruits_2561.py

```python
class Solution:
  def minCost(self, basket1: List[int], basket2: List[int]) -> int:
    swapped = []
    count = collections.Counter(basket1)
    count.subtract(collections.Counter(basket2))

    for num, freq in count.items():
      if freq % 2 != 0:
        return -1
      swapped += [num] * abs(freq // 2)

    swapped.sort()
    minNum = min(min(basket1), min(basket2))
    # Other than directly swap basket1[i] and basket2[j], we can swap basket1[i]
    # with `minNum` first then swap `minNum` with basket2[j], and vice versa.
    # That's why we take min(2 * minNum, num) in the below.
    return sum(min(2 * minNum, num) for num in swapped[0:len(swapped) // 2])

```

## 2100. Find Good Days to Rob the Bank_2100.py

```python
class Solution:
  def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:
    n = len(security)
    dec = [0] * n  # dec[i] := the number of continuous decreasing numbers before i
    inc = [0] * n  # inc[i] := the number of continuous increasing numbers after i

    for i in range(1, n):
      if security[i - 1] >= security[i]:
        dec[i] = dec[i - 1] + 1

    for i in range(n - 2, -1, -1):
      if security[i] <= security[i + 1]:
        inc[i] = inc[i + 1] + 1

    return [i for i, (a, b) in enumerate(zip(dec, inc))
            if a >= time and b >= time]

```

## 821. Shortest Distance to a Character_821.py

```python
class Solution:
  def shortestToChar(self, s: str, c: str) -> List[int]:
    n = len(s)
    ans = [0] * n
    prev = -n

    for i in range(n):
      if s[i] == c:
        prev = i
      ans[i] = i - prev

    for i in range(prev - 1, -1, -1):
      if s[i] == c:
        prev = i
      ans[i] = min(ans[i], prev - i)

    return ans

```

## 3062. Winner of the Linked List Game_3062.py

```python
class Solution:
  def gameResult(self, head: Optional[ListNode]) -> str:
    even = 0
    odd = 0

    while head:
      if head.val > head.next.val:
        even += 1
      elif head.val < head.next.val:
        odd += 1
      head = head.next.next

    if even > odd:
      return 'Even'
    if even < odd:
      return 'Odd'
    return 'Tie'

```

## 116. Populating Next Right Pointers in Each Node_116-2.py

```python
class Solution:
  def connect(self, root: 'Node') -> 'Node':
    node = root  # the node that is above the current needling

    while node and node.left:
      dummy = Node(0)  # a dummy node before needling
      # Needle the children of the node.
      needle = dummy
      while node:
        needle.next = node.left
        needle = needle.next
        needle.next = node.right
        needle = needle.next
        node = node.next
      node = dummy.next  # Move the node to the next level.

    return root

```

## 1682. Longest Palindromic Subsequence II_1682-2.py

```python
class Solution:
  def longestPalindromeSubseq(self, s: str) -> int:
    n = len(s)
    # dp[i][j][k] := the length of LPS(s[i..j]), where the previous letter is
    # ('a' + k).
    dp = [[[0] * 27 for _ in range(n)] for _ in range(n)]

    for d in range(1, n):
      for i in range(n - d):
        for k in range(27):
          j = i + d
          if s[i] == s[j] and s[i] != chr(ord('a') + k):
            dp[i][j][k] = dp[i + 1][j - 1][ord(s[i]) - ord('a')] + 2
          else:
            dp[i][j][k] = max(dp[i + 1][j][k], dp[i][j - 1][k])

    return dp[0][n - 1][26]

```

## 3219. Minimum Cost for Cutting Cake II_3219.py

```python
class Solution:
  # Same as 3218. Minimum Cost for Cutting Cake I
  def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:
    ans = 0
    sumH = sum(horizontalCut)
    sumV = sum(verticalCut)

    horizontalCut.sort()
    verticalCut.sort()

    while horizontalCut and verticalCut:
      if horizontalCut[-1] > verticalCut[-1]:
        ans += horizontalCut[-1] + sumV
        sumH -= horizontalCut.pop()
      else:
        ans += verticalCut[-1] + sumH
        sumV -= verticalCut.pop()

    return ans + sumH + sumV

```

## 1956. Minimum Time For K Virus Variants to Spread_1956.py

```python
class Solution:
  def minDayskVariants(self, points: List[List[int]], k: int) -> int:
    kMax = 100
    ans = math.inf

    for a in range(1, kMax + 1):
      for b in range(1, kMax + 1):
        # Stores the k minimum distances of points that can reach (a, b).
        maxHeap = []
        for x, y in points:
          heapq.heappush(maxHeap, -abs(x - a) + -abs(y - b))
          if len(maxHeap) > k:
            heapq.heappop(maxHeap)
        ans = min(ans, -maxHeap[0])

    return ans

```

## 2223. Sum of Scores of Built Strings_2223.py

```python
class Solution:
  def sumScores(self, s: str) -> int:
    n = len(s)
    # https://cp-algorithms.com/string/z-function.html#implementation
    z = [0] * n
    # [l, r] := the indices of the rightmost segment match
    l = 0
    r = 0

    for i in range(1, n):
      if i < r:
        z[i] = min(r - i, z[i - l])
      while i + z[i] < n and s[z[i]] == s[i + z[i]]:
        z[i] += 1
      if i + z[i] > r:
        l = i
        r = i + z[i]

    return sum(z) + n

```

## 45. Jump Game II_45.py

```python
class Solution:
  def jump(self, nums: List[int]) -> int:
    ans = 0
    end = 0
    farthest = 0

    # Start an implicit BFS.
    for i in range(len(nums) - 1):
      farthest = max(farthest, i + nums[i])
      if farthest >= len(nums) - 1:
        ans += 1
        break
      if i == end:      # Visited all the items on the current level.
        ans += 1        # Increment the level.
        end = farthest  # Make the queue size for the next level.

    return ans

```

## 2273. Find Resultant Array After Removing Anagrams_2273.py

```python
class Solution:
  def removeAnagrams(self, words: List[str]) -> List[str]:
    ans = []

    def isAnagram(a: str, b: str) -> bool:
      count = collections.Counter(a)
      count.subtract(collections.Counter(b))
      return all(value == 0 for value in count.values())

    i = 0
    while i < len(words):
      j = i + 1
      while j < len(words) and isAnagram(words[i], words[j]):
        j += 1
      ans.append(words[i])
      i = j

    return ans

```

## 2829. Determine the Minimum Sum of a k-avoiding Array_2829.py

```python
class Solution:
  def minimumSum(self, n: int, k: int) -> int:
    # These are the unique pairs that sum up to k:
    # (1, k - 1), (2, k - 2), ..., (ceil(k // 2), floor(k // 2)).
    # Our optimal strategy is to select 1, 2, ..., floor(k // 2), and then
    # choose k, k + 1, ... if necessary, as selecting any number in the range
    # [ceil(k // 2), k - 1] will result in a pair summing up to k.

    def trapezoid(a: int, b: int) -> int:
      """Returns sum(a..b)."""
      return (a + b) * (b - a + 1) // 2

    mid = k // 2  # floor(k // 2)
    if n <= mid:
      return trapezoid(1, n)
    return trapezoid(1, mid) + trapezoid(k, k + (n - mid - 1))

```

## 583. Delete Operation for Two Strings_583.py

```python
class Solution:
  def minDistance(self, word1: str, word2: str) -> int:
    k = self._lcs(word1, word2)
    return (len(word1) - k) + (len(word2) - k)

  def _lcs(self, a: str, b: str) -> int:
    m = len(a)
    n = len(b)
    # dp[i][j] := the length of LCS(a[0..i), b[0..j))
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
      for j in range(1, n + 1):
        if a[i - 1] == b[j - 1]:
          dp[i][j] = 1 + dp[i - 1][j - 1]
        else:
          dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]

```

## 2609. Find the Longest Balanced Substring of a Binary String_2609-2.py

```python
class Solution:
  def findTheLongestBalancedSubstring(self, s: str) -> int:
    ans = 0
    zeros = 0
    ones = 0

    for c in s:
      if c == '0':
        zeros = 1 if ones > 0 else zeros + 1
        ones = 0
      else:  # c == '1'
        ones += 1
      if zeros >= ones:
        ans = max(ans, ones)

    return ans * 2

```

## 1675. Minimize Deviation in Array_1675.py

```python
class Solution:
  def minimumDeviation(self, nums: List[int]) -> int:
    ans = math.inf
    mn = math.inf
    maxHeap = []

    for num in nums:
      evenNum = num if num % 2 == 0 else num * 2
      heapq.heappush(maxHeap, -evenNum)
      mn = min(mn, evenNum)

    while maxHeap[0] % 2 == 0:
      mx = -heapq.heappop(maxHeap)
      ans = min(ans, mx - mn)
      mn = min(mn, mx // 2)
      heapq.heappush(maxHeap, -mx // 2)

    return min(ans, -maxHeap[0] - mn)

```

## 3106. Lexicographically Smallest String After Operations With Constraint_3106.py

```python
class Solution:
  def getSmallestString(self, s: str, k: int) -> str:
    ans = list(s)

    for i, c in enumerate(s):
      if k == 0:
        break
      distToA = min(ord(c) - ord('a'), ord('z') - ord(c) + 1)
      if k >= distToA:
        k -= distToA
        ans[i] = 'a'
      else:
        # k is not enough to change the current letter to 'a', so move as closer
        # to 'a' as possible.
        ans[i] = chr(ord(c) - k)
        k = 0

    return ''.join(ans)

```

## 1013. Partition Array Into Three Parts With Equal Sum_1013.py

```python
class Solution:
  def canThreePartsEqualSum(self, arr: List[int]) -> bool:
    summ = sum(arr)
    if summ % 3 != 0:
      return False

    average = summ // 3
    partCount = 0
    partSum = 0

    for a in arr:
      partSum += a
      if partSum == average:
        partCount += 1
        partSum = 0

    # edge case: arr = [0, 0, 0, 0] . partCount = 4.
    return partCount >= 3

```

## 2067. Number of Equal Count Substrings_2067.py

```python
class Solution:
  def equalCountSubstrings(self, s: str, count: int) -> int:
    maxUnique = len(set(s))
    ans = 0

    for unique in range(1, maxUnique + 1):
      windowSize = unique * count
      lettersCount = collections.Counter()
      uniqueCount = 0
      for i, c in enumerate(s):
        lettersCount[c] += 1
        if lettersCount[c] == count:
          uniqueCount += 1
        if i >= windowSize:
          lettersCount[s[i - windowSize]] -= 1
          if lettersCount[s[i - windowSize]] == count - 1:
            uniqueCount -= 1
        ans += uniqueCount == unique

    return ans

```

## 1584. Min Cost to Connect All Points_1584.py

```python
class Solution:
  def minCostConnectPoints(self, points: List[int]) -> int:
    # dist[i] := the minimum distance to connect the points[i]
    dist = [math.inf] * len(points)
    ans = 0

    for i in range(len(points) - 1):
      for j in range(i + 1, len(points)):
        # Try to connect the points[i] with the points[j].
        dist[j] = min(dist[j], abs(points[i][0] - points[j][0]) +
                      abs(points[i][1] - points[j][1]))
        # Swap the points[j] (the point with the mnimum distance) with the
        # points[i + 1].
        if dist[j] < dist[i + 1]:
          points[j], points[i + 1] = points[i + 1], points[j]
          dist[j], dist[i + 1] = dist[i + 1], dist[j]
      ans += dist[i + 1]

    return ans

```

## 225. Implement Stack using Queues_225.py

```python
class MyStack:
  def __init__(self):
    self.q = collections.deque()

  def push(self, x: int) -> None:
    self.q.append(x)
    for _ in range(len(self.q) - 1):
      self.q.append(self.q.popleft())

  def pop(self) -> int:
    return self.q.popleft()

  def top(self) -> int:
    return self.q[0]

  def empty(self) -> bool:
    return not self.q

```

## 39. Combination Sum_39.py

```python
class Solution:
  def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
    ans = []

    def dfs(s: int, target: int, path: List[int]) -> None:
      if target < 0:
        return
      if target == 0:
        ans.append(path.clone())
        return

      for i in range(s, len(candidates)):
        path.append(candidates[i])
        dfs(i, target - candidates[i], path)
        path.pop()

    candidates.sort()
    dfs(0, target, [])
    return ans

```

## 688. Knight Probability in Chessboard_688.py

```python
class Solution:
  def knightProbability(self, n: int, k: int, row: int, column: int) -> float:
    dirs = ((1, 2), (2, 1), (2, -1), (1, -2),
            (-1, -2), (-2, -1), (-2, 1), (-1, 2))
    # dp[i][j] := the probability to stand on (i, j)
    dp = [[0] * n for _ in range(n)]
    dp[row][column] = 1.0

    for _ in range(k):
      newDp = [[0] * n for _ in range(n)]
      for i in range(n):
        for j in range(n):
          for dx, dy in dirs:
            x = i + dx
            y = j + dy
            if 0 <= x < n and 0 <= y < n:
              newDp[i][j] += dp[x][y]
      dp = newDp

    return sum(map(sum, dp)) / 8**k

```

## 75. Sort Colors_75-2.py

```python
class Solution:
  def sortColors(self, nums: List[int]) -> None:
    l = 0  # The next 0 should be placed in l.
    r = len(nums) - 1  # THe next 2 should be placed in r.

    i = 0
    while i <= r:
      if nums[i] == 0:
        nums[i], nums[l] = nums[l], nums[i]
        i += 1
        l += 1
      elif nums[i] == 1:
        i += 1
      else:
        # We may swap a 0 to index i, but we're still not sure whether this 0
        # is placed in the correct index, so we can't move pointer i.
        nums[i], nums[r] = nums[r], nums[i]
        r -= 1

```

## 1024. Video Stitching_1024.py

```python
class Solution:
  def videoStitching(self, clips: List[List[int]], time: int) -> int:
    ans = 0
    end = 0
    farthest = 0

    clips.sort()

    i = 0
    while farthest < time:
      while i < len(clips) and clips[i][0] <= end:
        farthest = max(farthest, clips[i][1])
        i += 1
      if end == farthest:
        return -1
      ans += 1
      end = farthest

    return ans

```

## 2044. Count Number of Maximum Bitwise-OR Subsets_2044.py

```python
class Solution:
  def countMaxOrSubsets(self, nums: List[int]) -> int:
    ors = functools.reduce(operator.or_, nums)
    ans = 0

    def dfs(i: int, path: int) -> None:
      nonlocal ans
      if i == len(nums):
        if path == ors:
          ans += 1
        return

      dfs(i + 1, path)
      dfs(i + 1, path | nums[i])

    dfs(0, 0)
    return ans

```

## 111. Minimum Depth of Binary Tree_111-2.py

```python
class Solution:
  def minDepth(self, root: Optional[TreeNode]) -> int:
    if not root:
      return 0

    ans = 0
    q = collections.deque([root])

    while q:
      ans += 1
      for _ in range(len(q)):
        node = q.popleft()
        if not node.left and not node.right:
          return ans
        if node.left:
          q.append(node.left)
        if node.right:
          q.append(node.right)

```

## 1457. Pseudo-Palindromic Paths in a Binary Tree_1457.py

```python
class Solution:
  def pseudoPalindromicPaths(self, root: Optional[TreeNode]) -> int:
    ans = 0

    def dfs(root: Optional[TreeNode], path: int) -> None:
      nonlocal ans
      if not root:
        return
      if not root.left and not root.right:
        path ^= 1 << root.val
        if path & (path - 1) == 0:
          ans += 1
        return

      dfs(root.left, path ^ 1 << root.val)
      dfs(root.right, path ^ 1 << root.val)

    dfs(root, 0)
    return ans

```

## 98. Validate Binary Search Tree_98-2.py

```python
class Solution:
  def isValidBST(self, root: Optional[TreeNode]) -> bool:
    stack = []
    pred = None

    while root or stack:
      while root:
        stack.append(root)
        root = root.left
      root = stack.pop()
      if pred and pred.val >= root.val:
        return False
      pred = root
      root = root.right

    return True

```

## 1006. Clumsy Factorial_1006.py

```python
class Solution:
  def clumsy(self, n: int) -> int:
    if n == 1:
      return 1
    if n == 2:
      return 2
    if n == 3:
      return 6
    if n == 4:
      return 7
    if n % 4 == 1:
      return n + 2
    if n % 4 == 2:
      return n + 2
    if n % 4 == 3:
      return n - 1
    return n + 1

```

## 3154. Find Number of Ways to Reach the K-th Stair_3154.py

```python
class Solution:
  def waysToReachStair(self, k: int) -> int:
    # Let's say we have `down` operation 1 and `jump` operation 2.
    # The final stair is 1 + (2^0 + 2^1 + ... + 2^(jump - 1)) - down = k.
    # => 1 + (2^jump - 1) - down = k.
    # => down = 2^jump - k.
    # Since `down` operations cannot be used consecutively, there're jump + 1
    # positions (before and after each `jump`) for  `down`. The maximum jump is
    # 29, as it satisfies the condition down = 2^jump - k <= jump + 1, with k
    # being the maximum value of 10^9.
    kMaxJump = 29
    ans = 0

    for jump in range(kMaxJump + 1):
      down = (1 << jump) - k
      if down < 0 or down > jump + 1:
        continue
      ans += math.comb(jump + 1, down)

    return ans

```

## 2208. Minimum Operations to Halve Array Sum_2208.py

```python
class Solution:
  def halveArray(self, nums: List[int]) -> int:
    halfSum = sum(nums) / 2
    ans = 0
    runningSum = 0.0
    maxHeap = [-num for num in nums]

    heapq.heapify(maxHeap)

    while runningSum < halfSum:
      maxValue = -heapq.heappop(maxHeap) / 2
      runningSum += maxValue
      heapq.heappush(maxHeap, -maxValue)
      ans += 1

    return ans

```

## 582. Kill Process_582.py

```python
class Solution:
  def killProcess(self, pid: List[int], ppid: List[int], kill: int) -> List[int]:
    ans = []
    tree = collections.defaultdict(list)

    for v, u in zip(pid, ppid):
      if u == 0:
        continue
      tree[u].append(v)

    def dfs(u: int) -> None:
      ans.append(u)
      for v in tree.get(u, []):
        dfs(v)

    dfs(kill)
    return ans

```

## 1589. Maximum Sum Obtained of Any Permutation_1589.py

```python
class Solution:
  def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -> int:
    kMod = 1_000_000_007
    ans = 0
    # count[i] := the number of times nums[i] has been requested
    count = [0] * len(nums)

    for start, end in requests:
      count[start] += 1
      if end + 1 < len(nums):
        count[end + 1] -= 1

    for i in range(1, len(nums)):
      count[i] += count[i - 1]

    for num, c in zip(sorted(nums), sorted(count)):
      ans += num * c
      ans %= kMod

    return ans

```

## 1224. Maximum Equal Frequency_1224.py

```python
class Solution:
  def maxEqualFreq(self, nums: List[int]) -> int:
    ans = 0
    maxFreq = 0
    count = collections.Counter()
    freq = collections.Counter()

    for i, num in enumerate(nums):
      freq[count[num]] -= 1
      count[num] += 1
      freq[count[num]] += 1
      maxFreq = max(maxFreq, count[num])
      if maxFreq == 1 or maxFreq * freq[maxFreq] == i or (maxFreq - 1) * (freq[maxFreq - 1] + 1) == i:
        ans = i + 1

    return ans

```

## 1676. Lowest Common Ancestor of a Binary Tree IV_1676.py

```python
class Solution:
  def lowestCommonAncestor(self, root: 'TreeNode', nodes: 'List[TreeNode]') -> 'TreeNode':
    nodes = set(nodes)

    def lca(root: 'TreeNode') -> 'TreeNode':
      if not root:
        return None
      if root in nodes:
        return root
      left = lca(root.left)
      right = lca(root.right)
      if left and right:
        return root
      return left or right

    return lca(root)

```

## 2262. Total Appeal of A String_2262.py

```python
class Solution:
  def appealSum(self, s: str) -> int:
    ans = 0
    # the total appeal of all substrings ending in the index so far
    dp = 0
    lastSeen = {}

    for i, c in enumerate(s):
      #   the total appeal of all substrings ending in s[i]
      # = the total appeal of all substrings ending in s[i - 1]
      # + the number of substrings ending in s[i] that contain only this s[i]
      dp += i - lastSeen.get(c, -1)
      ans += dp
      lastSeen[c] = i

    return ans

```

## 676. Implement Magic Dictionary_676.py

```python
class MagicDictionary:
  def __init__(self):
    self.dict = {}

  def buildDict(self, dictionary: List[str]) -> None:
    for word in dictionary:
      for i, c in enumerate(word):
        replaced = self._getReplaced(word, i)
        self.dict[replaced] = '*' if replaced in self.dict else c

  def search(self, searchWord: str) -> bool:
    for i, c in enumerate(searchWord):
      replaced = self._getReplaced(searchWord, i)
      if self.dict.get(replaced, c) != c:
        return True
    return False

  def _getReplaced(self, s: str, i: int) -> str:
    return s[:i] + '*' + s[i + 1:]

```

## 2848. Points That Intersect With Cars_2848.py

```python
class Solution:
  def numberOfPoints(self, nums: List[List[int]]) -> int:
    kMax = 100
    ans = 0
    runningSum = 0
    count = [0] * (kMax + 2)

    for start, end in nums:
      count[start] += 1
      count[end + 1] -= 1

    for i in range(1, kMax + 1):
      runningSum += count[i]
      if runningSum > 0:
        ans += 1

    return ans

```

## 2518. Number of Great Partitions_2518.py

```python
class Solution:
  def countPartitions(self, nums: List[int], k: int) -> int:
    kMod = 1_000_000_007
    summ = sum(nums)
    ans = pow(2, len(nums), kMod)  # 2^n % kMod
    dp = [1] + [0] * k

    for num in nums:
      for i in range(k, num - 1, -1):
        dp[i] += dp[i - num]
        dp[i] %= kMod

    # Substract the cases that're not satisfied.
    for i in range(k):
      if summ - i < k:  # Both group1 and group2 < k.
        ans -= dp[i]
      else:
        ans -= dp[i] * 2

    return ans % kMod

```

## 438. Find All Anagrams in a String_438.py

```python
class Solution:
  def findAnagrams(self, s: str, p: str) -> List[int]:
    ans = []
    count = collections.Counter(p)
    required = len(p)

    for r, c in enumerate(s):
      count[c] -= 1
      if count[c] >= 0:
        required -= 1
      if r >= len(p):
        count[s[r - len(p)]] += 1
        if count[s[r - len(p)]] > 0:
          required += 1
      if required == 0:
        ans.append(r - len(p) + 1)

    return ans

```

## 19. Remove Nth Node From End of List_19.py

```python
class Solution:
  def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
    slow = head
    fast = head

    for _ in range(n):
      fast = fast.next
    if not fast:
      return head.next

    while fast.next:
      slow = slow.next
      fast = fast.next
    slow.next = slow.next.next

    return head

```

## 254. Factor Combinations_254.py

```python
class Solution:
  def getFactors(self, n: int) -> List[List[int]]:
    ans = []

    def dfs(n: int, s: int, path: List[int]) -> None:
      if n <= 1:
        if len(path) > 1:
          ans.append(path.copy())
        return

      for i in range(s, n + 1):
        if n % i == 0:
          path.append(i)
          dfs(n // i, i, path)
          path.pop()

    dfs(n, 2, [])  # The minimum factor is 2.
    return ans

```

## 1643. Kth Smallest Instructions_1643.py

```python
class Solution:
  def kthSmallestPath(self, destination: List[int], k: int) -> str:
    ans = []
    v, h = destination

    for _ in range(h + v):
      # If pick 'H', then we're able to reack 1, 2, ..., availableRank.
      availableRank = math.comb(h + v - 1, v)
      if availableRank >= k:  # Should pick 'H'.
        ans.append('H')
        h -= 1
      else:  # Should pick 'V'.
        k -= availableRank
        ans.append('V')
        v -= 1

    return ''.join(ans)

```

## 923. 3Sum With Multiplicity_923.py

```python
class Solution:
  def threeSumMulti(self, arr: List[int], target: int) -> int:
    kMod = 1_000_000_007
    ans = 0
    count = collections.Counter(arr)

    for i, x in count.items():
      for j, y in count.items():
        k = target - i - j
        if k not in count:
          continue
        if i == j and j == k:
          ans = (ans + x * (x - 1) * (x - 2) // 6) % kMod
        elif i == j and j != k:
          ans = (ans + x * (x - 1) // 2 * count[k]) % kMod
        elif i < j and j < k:
          ans = (ans + x * y * count[k]) % kMod

    return ans % kMod

```

## 1222. Queens That Can Attack the King_1222.py

```python
class Solution:
  def queensAttacktheKing(self, queens: List[List[int]], king: List[int]) -> List[List[int]]:
    ans = []
    queens = {(i, j) for i, j in queens}

    for d in [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]:
      i = king[0] + d[0]
      j = king[1] + d[1]
      while 0 <= i < 8 and 0 <= j < 8:
        if (i, j) in queens:
          ans.append([i, j])
          break
        i += d[0]
        j += d[1]

    return ans

```

## 2311. Longest Binary Subsequence Less Than or Equal to K_2311.py

```python
class Solution:
  def longestSubsequence(self, s: str, k: int) -> int:
    oneCount = 0
    num = 0
    pow = 1

    # Take as many 1s as possible from the right.
    for i in reversed(range(len(s))):
      if num + pow > k:
        break
      if s[i] == '1':
        oneCount += 1
        num += pow
      pow *= 2

    return s.count('0') + oneCount

```

## 1063. Number of Valid Subarrays_1063.py

```python
class Solution:
  def validSubarrays(self, nums: List[int]) -> int:
    # For each `num` in `nums`, each element x in the stack can be the leftmost
    # element s.t. [x, num] forms a valid subarray, so the size of the stack is
    # the number of valid subarrays ending in the current number.
    #
    # e.g. nums = [1, 3, 2]
    # num = 1, stack = [1] -> valid subarray is [1]
    # num = 3, stack = [1, 3] -> valid subarrays are [1, 3], [3]
    # num = 2, stack = [1, 2] -> valid subarrays are [1, 3, 2], [2]
    ans = 0
    stack = []

    for num in nums:
      while stack and stack[-1] > num:
        stack.pop()
      stack.append(num)
      ans += len(stack)

    return ans

```

## 2771. Longest Non-decreasing Subarray From Two Arrays_2771.py

```python
class Solution:
  def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:
    ans = 1
    dp1 = 1  # the longest subarray that ends in nums1[i] so far
    dp2 = 1  # the longest subarray that ends in nums2[i] so far

    for i in range(1, len(nums1)):
      dp11 = dp1 + 1 if nums1[i - 1] <= nums1[i] else 1
      dp21 = dp2 + 1 if nums2[i - 1] <= nums1[i] else 1
      dp12 = dp1 + 1 if nums1[i - 1] <= nums2[i] else 1
      dp22 = dp2 + 1 if nums2[i - 1] <= nums2[i] else 1
      dp1 = max(dp11, dp21)
      dp2 = max(dp12, dp22)
      ans = max(ans, dp1, dp2)

    return ans

```

## 1966. Binary Searchable Numbers in an Unsorted Array_1966.py

```python
class Solution:
  def binarySearchableNumbers(self, nums: List[int]) -> int:
    n = len(nums)
    # prefixMaxs[i] := max(nums[0..i))
    prefixMaxs = [0] * n
    # suffixMins[i] := min(nums[i + 1..n))
    suffixMins = [0] * n

    # Fill in `prefixMaxs`.
    prefixMaxs[0] = -math.inf
    for i in range(1, n):
      prefixMaxs[i] = max(prefixMaxs[i - 1], nums[i - 1])

    # Fill in `suffixMins`.
    suffixMins[n - 1] = math.inf
    for i in range(n - 2, -1, -1):
      suffixMins[i] = min(suffixMins[i + 1], nums[i + 1])

    return sum(prefixMaxs[i] < nums[i] < suffixMins[i] for i in range(n))

```

## 1849. Splitting a String Into Descending Consecutive Values_1849.py

```python
class Solution:
  def splitString(self, s: str) -> bool:
    def isValid(s: str, start: int, prev: int, segment: int) -> bool:
      if start == len(s) and segment > 1:
        return True

      curr = 0
      for i in range(start, len(s)):
        curr = curr * 10 + ord(s[i]) - ord('0')
        if curr > 9999999999:
          return False
        if (prev == -1 or curr == prev - 1) and isValid(s, i + 1, curr, segment + 1):
          return True

      return False

    return isValid(s, 0, -1, 0)

```

## 1540. Can Convert String in K Moves_1540-2.py

```python
class Solution:
  def canConvertString(self, s: str, t: str, k: int) -> bool:
    if len(s) != len(t):
      return False

    # e.g. s = "aab", t = "bbc", so shiftCount[1] = 3
    # 1. a -> b, need 1 move.
    # 2. a -> b, need 1 + 26 moves.
    # 3. b -> c, need 1 + 26 * 2 moves.
    shiftCount = [0] * 26

    for a, b in zip(s, t):
      shift = (ord(b) - ord(a) + 26) % 26
      if shift == 0:
        continue
      if shift + 26 * shiftCount[shift] > k:
        return False
      shiftCount[shift] += 1

    return True

```

## 2250. Count Number of Rectangles Containing Each Point_2250.py

```python
class Solution:
  def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:
    ans = []
    yToXs = [[] for _ in range(101)]

    for l, h in rectangles:
      yToXs[h].append(l)

    for xs in yToXs:
      xs.sort()

    for xi, yi in points:
      count = 0
      for y in range(yi, 101):
        xs = yToXs[y]
        count += len(xs) - bisect.bisect_left(xs, xi)
      ans.append(count)

    return ans

```

## 230. Kth Smallest Element in a BST_230-3.py

```python
class Solution:
  def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
    stack = []

    while root:
      stack.append(root)
      root = root.left

    for _ in range(k - 1):
      root = stack.pop()
      root = root.right
      while root:
        stack.append(root)
        root = root.left

    return stack[-1].val

```

## 2193. Minimum Number of Moves to Make Palindrome_2193.py

```python
class Solution:
  def minMovesToMakePalindrome(self, s: str) -> int:
    ans = 0
    chars = list(s)

    while len(chars) > 1:
      # Greedily match the last digit.
      i = chars.index(chars[-1])
      if i == len(chars) - 1:
        # s[i] is the middle letter.
        ans += i // 2
      else:
        chars.pop(i)
        ans += i  # Swap the matched letter to the left.
      chars.pop()

    return ans

```

## 41. First Missing Positive_41.py

```python
class Solution:
  def firstMissingPositive(self, nums: List[int]) -> int:
    n = len(nums)

    # Correct slot:
    # nums[i] = i + 1
    # nums[i] - 1 = i
    # nums[nums[i] - 1] = nums[i]
    for i in range(n):
      while nums[i] > 0 and nums[i] <= n and nums[nums[i] - 1] != nums[i]:
        nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]

    for i, num in enumerate(nums):
      if num != i + 1:
        return i + 1

    return n + 1

```

## 2969. Minimum Number of Coins for Fruits II_2969-3.py

```python
class Solution:
  # Same as 2944. Minimum Number of Coins for Fruits
  def minimumCoins(self, prices: List[int]) -> int:
    n = len(prices)
    ans = math.inf
    # Stores (dp[i], i), where dp[i] := the minimum number of coins to acquire
    # fruits[i:] (0-indexed) in ascending order.
    minQ = collections.deque([(0, n)])

    for i in range(n - 1, -1, -1):
      while minQ and minQ[0][1] > (i + 1) * 2:
        minQ.popleft()
      ans = prices[i] + minQ[0][0]
      while minQ and minQ[-1][0] >= ans:
        minQ.pop()
      minQ.append((ans, i))

    return ans

```

## 809. Expressive Words_809.py

```python
class Solution:
  def expressiveWords(self, s: str, words: List[str]) -> int:
    def isStretchy(word: str) -> bool:
      n = len(s)
      m = len(word)

      j = 0
      for i in range(n):
        if j < m and s[i] == word[j]:
          j += 1
        elif i > 1 and s[i] == s[i - 1] == s[i - 2]:
          continue
        elif 0 < i < n - 1 and s[i - 1] == s[i] == s[i + 1]:
          continue
        else:
          return False

      return j == m

    return sum(isStretchy(word) for word in words)

```

## 2750. Ways to Split Array Into Good Subarrays_2750.py

```python
class Solution:
  def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:
    if 1 not in nums:
      return 0

    kMod = 1_000_000_007
    prev = -1  # the previous index of 1
    ans = 1

    for i, num in enumerate(nums):
      if num == 1:
        if prev != -1:
          ans *= i - prev
          ans %= kMod
        prev = i

    return ans

```

## 469. Convex Polygon_469.py

```python
class Solution:
  def isConvex(self, points: List[List[int]]) -> bool:
    # Pq x qr
    def getCross(p: List[int], q: List[int], r: List[int]):
      return (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])

    sign = 0
    for i in range(len(points)):
      cross = getCross(points[i - 2], points[i - 1], points[i])
      if cross == 0:  # p, q, r are collinear.
        continue
      if sign == 0:  # Find the first cross that's not 0.
        sign = cross
      elif cross * sign < 0:
        return False

    return True

```

## 144. Binary Tree Preorder Traversal_144-2.py

```python
class Solution:
  def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
    if not root:
      return []

    ans = []
    stack = [root]

    while stack:
      node = stack.pop()
      ans.append(node.val)
      if node.right:
        stack.append(node.right)
      if node.left:
        stack.append(node.left)

    return ans

```

## 1261. Find Elements in a Contaminated Binary Tree_1261.py

```python
class FindElements:
  def __init__(self, root: Optional[TreeNode]):
    self.vals = set()
    self.dfs(root, 0)

  def find(self, target: int) -> bool:
    return target in self.vals

  def dfs(self, root: Optional[TreeNode], val: int) -> None:
    if not root:
      return

    root.val = val
    self.vals.add(val)
    self.dfs(root.left, val * 2 + 1)
    self.dfs(root.right, val * 2 + 2)

```

## 808. Soup Servings_808.py

```python
class Solution:
  def soupServings(self, n: int) -> float:
    @functools.lru_cache(None)
    def dfs(a: int, b: int) -> float:
      if a <= 0 and b <= 0:
        return 0.5
      if a <= 0:
        return 1.0
      if b <= 0:
        return 0.0
      return 0.25 * (dfs(a - 4, b) +
                     dfs(a - 3, b - 1) +
                     dfs(a - 2, b - 2) +
                     dfs(a - 1, b - 3))

    return 1 if n >= 4800 else dfs((n + 24) // 25, (n + 24) // 25)

```

## 652. Find Duplicate Subtrees_652.py

```python
class Solution:
  def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:
    ans = []
    count = collections.Counter()

    def encode(root: Optional[TreeNode]) -> str:
      if not root:
        return ''

      encoded = str(root.val) + '#' + \
          encode(root.left) + '#' + \
          encode(root.right)
      count[encoded] += 1
      if count[encoded] == 2:
        ans.append(root)
      return encoded

    encode(root)
    return ans

```

## 1756. Design Most Recently Used Queue_1756.py

```python
from sortedcontainers import SortedList


class MRUQueue:
  def __init__(self, n: int):
    # [(priority value, actual value)]
    self.q = SortedList((i, i) for i in range(1, n + 1))

  def fetch(self, k: int) -> int:
    _, num = self.q.pop(k - 1)
    if self.q:
      maxPriority = self.q[-1][0]
      self.q.add((maxPriority + 1, num))
    else:
      self.q.add((0, num))
    return num

```

## 255. Verify Preorder Sequence in Binary Search Tree_255.py

```python
class Solution:
  def verifyPreorder(self, preorder: List[int]) -> bool:
    i = 0

    def dfs(min: int, max: int) -> None:
      nonlocal i
      if i == len(preorder):
        return
      if preorder[i] < min or preorder[i] > max:
        return

      val = preorder[i]
      i += 1
      dfs(min, val)
      dfs(val, max)

    dfs(-math.inf, math.inf)
    return i == len(preorder)

```

## 1099. Two Sum Less Than K_1099.py

```python
class Solution:
  def twoSumLessThanK(self, nums: List[int], k: int) -> int:
    if len(nums) < 2:
      return -1

    ans = -1  # Note the constrathat nums[i] > 0.
    l = 0
    r = len(nums) - 1

    nums.sort()

    while l < r:
      if nums[l] + nums[r] < k:
        ans = max(ans, nums[l] + nums[r])
        l += 1
      else:
        r -= 1

    return ans

```

## 2792. Count Nodes That Are Great Enough_2792.py

```python
class Solution:
  def countGreatEnoughNodes(self, root: Optional[TreeNode], k: int) -> int:
    ans = 0

    def dfs(root: Optional[TreeNode]) -> List[int]:
      nonlocal ans
      if not root:
        return []

      kSmallest = sorted(dfs(root.left) + dfs(root.right))[:k]
      if len(kSmallest) == k and root.val > kSmallest[-1]:
        ans += 1

      return kSmallest + [root.val]

    dfs(root)
    return ans

```

## 1146. Snapshot Array_1146.py

```python
class SnapshotArray:
  def __init__(self, length: int):
    self.snaps = [[[0, 0]] for _ in range(length)]
    self.snap_id = 0

  def set(self, index: int, val: int) -> None:
    snap = self.snaps[index][-1]
    if snap[0] == self.snap_id:
      snap[1] = val
    else:
      self.snaps[index].append([self.snap_id, val])

  def snap(self) -> int:
    self.snap_id += 1
    return self.snap_id - 1

  def get(self, index: int, snap_id: int) -> int:
    i = bisect_left(self.snaps[index], [snap_id + 1]) - 1
    return self.snaps[index][i][1]

```

## 828. Count Unique Characters of All Substrings of a Given String_828-2.py

```python
class Solution:
  def uniqueLetterString(self, s: str) -> int:
    ans = 0
    # lastSeen[c] := the index of the last time ('a' + i) appeared
    lastSeen = collections.defaultdict(lambda: -1)
    # prevSeen[c] := the previous index of the last time ('a' + i) appeared
    prevLastSeen = collections.defaultdict(lambda: -1)

    for i, c in enumerate(s):
      if c in lastSeen:
        ans += (i - lastSeen[c]) * (lastSeen[c] - prevLastSeen[c])
      prevLastSeen[c] = lastSeen[c]
      lastSeen[c] = i

    for c in string.ascii_uppercase:
      ans += (len(s) - lastSeen[c]) * (lastSeen[c] - prevLastSeen[c])

    return ans

```

## 2381. Shifting Letters II_2381.py

```python
class Solution:
  def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:
    ans = []
    currShift = 0
    timeline = [0] * (len(s) + 1)

    for start, end, direction in shifts:
      diff = 1 if direction else -1
      timeline[start] += diff
      timeline[end + 1] -= diff

    for i, c in enumerate(s):
      currShift = (currShift + timeline[i]) % 26
      num = (ord(c) - ord('a') + currShift + 26) % 26
      ans.append(chr(ord('a') + num))

    return ''.join(ans)

```

## 1215. Stepping Numbers_1215.py

```python
class Solution:
  def countSteppingNumbers(self, low: int, high: int) -> List[int]:
    ans = [0] if low == 0 else []
    q = collections.deque(list(range(1, 10)))

    while q:
      curr = q.popleft()
      if curr > high:
        continue
      if curr >= low:
        ans.append(curr)
      lastDigit = curr % 10
      if lastDigit > 0:
        q.append(curr * 10 + lastDigit - 1)
      if lastDigit < 9:
        q.append(curr * 10 + lastDigit + 1)

    return ans

```

## 1642. Furthest Building You Can Reach_1642.py

```python
class Solution:
  def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:
    minHeap = []

    for i, (a, b) in enumerate(itertools.pairwise(heights)):
      diff = b - a
      if diff <= 0:
        continue
      heapq.heappush(minHeap, diff)
      # If we run out of ladders, greedily use as less bricks as possible.
      if len(minHeap) > ladders:
        bricks -= heapq.heappop(minHeap)
      if bricks < 0:
        return i

    return len(heights) - 1

```

## 533. Lonely Pixel II_533.py

```python
class Solution:
  def findBlackPixel(self, picture: List[List[str]], target: int) -> int:
    m = len(picture)
    n = len(picture[0])
    ans = 0
    rows = [row.count('B') for row in picture]
    cols = [col.count('B') for col in zip(*picture)]
    rowStrings = [''.join(row) for row in picture]
    countRowStrings = collections.Counter(rowStrings)

    for i, (row, stringRow) in enumerate(zip(rows, rowStrings)):
      if row == target and countRowStrings[stringRow] == target:
        for j, col in enumerate(cols):
          if picture[i][j] == 'B' and col == target:
            ans += 1

    return ans

```

## 341. Flatten Nested List Iterator_341.py

```python
class NestedIterator:
  def __init__(self, nestedList: List[NestedInteger]):
    self.q = collections.deque()
    self.addInteger(nestedList)

  def next(self) -> int:
    return self.q.popleft()

  def hasNext(self) -> bool:
    return self.q

  def addInteger(self, nestedList: List[NestedInteger]) -> None:
    for ni in nestedList:
      if ni.isInteger():
        self.q.append(ni.getInteger())
      else:
        self.addInteger(ni.getList())

```

## 17. Letter Combinations of a Phone Number_17-2.py

```python
class Solution:
  def letterCombinations(self, digits: str) -> List[str]:
    if not digits:
      return []

    ans = ['']
    digitToLetters = ['', '', 'abc', 'def', 'ghi',
                      'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']

    for d in digits:
      temp = []
      for s in ans:
        for c in digitToLetters[ord(d) - ord('0')]:
          temp.append(s + c)
      ans = temp

    return ans

```

## 1406. Stone Game III_1406-2.py

```python
class Solution:
  def stoneGameIII(self, stoneValue: List[int]) -> str:
    n = len(stoneValue)
    # dp[i] := the maximum relative score Alice can make with stoneValue[i..n)
    dp = [-math.inf] * n + [0]

    for i in reversed(range(n)):
      summ = 0
      for j in range(i, i + 3):
        if j == n:
          break
        summ += stoneValue[j]
        dp[i] = max(dp[i], summ - dp[j + 1])

    score = dp[0]
    if score == 0:
      return 'Tie'
    return 'Alice' if score > 0 else 'Bob'

```

## 124. Binary Tree Maximum Path Sum_124.py

```python
class Solution:
  def maxPathSum(self, root: Optional[TreeNode]) -> int:
    ans = -math.inf

    def maxPathSumDownFrom(root: Optional[TreeNode]) -> int:
      """
      Returns the maximum path sum starting from the current root, where
      root.val is always included.
      """
      nonlocal ans
      if not root:
        return 0

      l = max(0, maxPathSumDownFrom(root.left))
      r = max(0, maxPathSumDownFrom(root.right))
      ans = max(ans, root.val + l + r)
      return root.val + max(l, r)

    maxPathSumDownFrom(root)
    return ans

```

## 128. Longest Consecutive Sequence_128.py

```python
class Solution:
  def longestConsecutive(self, nums: List[int]) -> int:
    ans = 0
    seen = set(nums)

    for num in nums:
      # `num` is the start of a sequence.
      if num - 1 in seen:
        continue
      length = 0
      while num in seen:
        num += 1
        length += 1
      ans = max(ans, length)

    return ans

```

## 2435. Paths in Matrix Whose Sum Is Divisible by K_2435-2.py

```python
class Solution:
  def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
    kMod = 1_000_000_007
    m = len(grid)
    n = len(grid[0])
    # dp[i][j][sum] := the number of paths to (i, j), where the sum / k == sum
    dp = [[[0] * k for j in range(n)] for i in range(m)]
    dp[0][0][grid[0][0] % k] = 1

    for i in range(m):
      for j in range(n):
        for summ in range(k):
          newSum = (summ + grid[i][j]) % k
          if i > 0:
            dp[i][j][newSum] += dp[i - 1][j][summ]
          if j > 0:
            dp[i][j][newSum] += dp[i][j - 1][summ]
          dp[i][j][newSum] %= kMod

    return dp[m - 1][n - 1][0]

```

## 2008. Maximum Earnings From Taxi_2008.py

```python
class Solution:
  def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -> int:
    startToEndAndEarns = [[] for _ in range(n)]
    # dp[i] := the maximum dollars you can earn starting at i
    dp = [0] * (n + 1)

    for start, end, tip in rides:
      earn = end - start + tip
      startToEndAndEarns[start].append((end, earn))

    for i in range(n - 1, 0, -1):
      dp[i] = dp[i + 1]
      for end, earn in startToEndAndEarns[i]:
        dp[i] = max(dp[i], dp[end] + earn)

    return dp[1]

```

## 2321. Maximum Score Of Spliced Array_2321.py

```python
class Solution:
  def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:
    def kadane(nums1: List[int], nums2: List[int]) -> int:
      """
      Returns the maximum gain of swapping some numbers in `nums1` with some
      numbers in `nums2`.
      """
      gain = 0
      maxGain = 0

      for num1, num2 in zip(nums1, nums2):
        gain = max(0, gain + num2 - num1)
        maxGain = max(maxGain, gain)

      return maxGain + sum(nums1)

    return max(kadane(nums1, nums2), kadane(nums2, nums1))

```

## 632. Smallest Range Covering Elements from K Lists_632.py

```python
class Solution:
  def smallestRange(self, nums: List[List[int]]) -> List[int]:
    minHeap = [(row[0], i, 0) for i, row in enumerate(nums)]
    heapq.heapify(minHeap)

    maxRange = max(row[0] for row in nums)
    minRange = heapq.nsmallest(1, minHeap)[0][0]
    ans = [minRange, maxRange]

    while len(minHeap) == len(nums):
      num, r, c = heapq.heappop(minHeap)
      if c + 1 < len(nums[r]):
        heapq.heappush(minHeap, (nums[r][c + 1], r, c + 1))
        maxRange = max(maxRange, nums[r][c + 1])
        minRange = heapq.nsmallest(1, minHeap)[0][0]
        if maxRange - minRange < ans[1] - ans[0]:
          ans[0], ans[1] = minRange, maxRange

    return ans

```

## 2484. Count Palindromic Subsequences_2484.py

```python
class Solution:
  def countPalindromes(self, s: str) -> int:
    kMod = 1_000_000_007
    ans = 0

    for a in range(10):
      for b in range(10):
        pattern = f'{a}{b}.{b}{a}'
        # dp[i] := the number of subsequences of pattern[i..n) in s, where
        # pattern[2] can be any character
        dp = [0] * 5 + [1]
        for c in s:
          for i, p in enumerate(pattern):
            if p == '.' or p == c:
              dp[i] += dp[i + 1]
        ans += dp[0]
        ans %= kMod

    return ans

```

## 2012. Sum of Beauty in the Array_2012.py

```python
class Solution:
  def sumOfBeauties(self, nums: List[int]) -> int:
    n = len(nums)
    ans = 0
    minOfRight = [0] * (n - 1) + [nums[-1]]

    for i in range(n - 2, 1, -1):
      minOfRight[i] = min(nums[i], minOfRight[i + 1])

    maxOfLeft = nums[0]

    for i in range(1, n - 1):
      if maxOfLeft < nums[i] < minOfRight[i + 1]:
        ans += 2
      elif nums[i - 1] < nums[i] < nums[i + 1]:
        ans += 1
      maxOfLeft = max(maxOfLeft, nums[i])

    return ans

```

## 2555. Maximize Win From Two Segments_2555.py

```python
class Solution:
  def maximizeWin(self, prizePositions: List[int], k: int) -> int:
    ans = 0
    # dp[i] := the maximum number of prizes to choose the first i
    # `prizePositions`
    dp = [0] * (len(prizePositions) + 1)

    j = 0
    for i, prizePosition in enumerate(prizePositions):
      while prizePosition - prizePositions[j] > k:
        j += 1
      covered = i - j + 1
      dp[i + 1] = max(dp[i], covered)
      ans = max(ans, dp[j] + covered)

    return ans

```

## 102. Binary Tree Level Order Traversal_102.py

```python
class Solution:
  def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
    if not root:
      return []

    ans = []
    q = collections.deque([root])

    while q:
      currLevel = []
      for _ in range(len(q)):
        node = q.popleft()
        currLevel.append(node.val)
        if node.left:
          q.append(node.left)
        if node.right:
          q.append(node.right)
      ans.append(currLevel)

    return ans

```

## 2930. Number of Strings Which Can Be Rearranged to Contain Substring_2930.py

```python
class Solution:
  def stringCount(self, n: int) -> int:
    # There're three invalid conditions:
    #   a. count('l') == 0
    #   b. count('e') < 2
    #   c. count('t') == 0
    #
    # By Principle of Inclusion-Exclusion (PIE):
    #   ans = allCount - a - b - c + ab + ac + bc - abc
    kMod = 1_000_000_007
    allCount = pow(26, n, kMod)
    a = pow(25, n, kMod)
    b = pow(25, n, kMod)
    c = pow(25, n, kMod) + n * pow(25, n - 1, kMod)
    ab = pow(24, n, kMod) + n * pow(24, n - 1, kMod)
    ac = pow(24, n, kMod)
    bc = pow(24, n, kMod) + n * pow(24, n - 1, kMod)
    abc = pow(23, n, kMod) + n * pow(23, n - 1, kMod)
    return (allCount - a - b - c + ab + ac + bc - abc) % kMod

```

## 1011. Capacity To Ship Packages Within D Days_1011.py

```python
class Solution:
  def shipWithinDays(self, weights: List[int], days: int) -> int:
    def canShip(shipCapacity: int) -> bool:
      shipDays = 1
      capacity = 0
      for weight in weights:
        if capacity + weight > shipCapacity:
          shipDays += 1
          capacity = weight
        else:
          capacity += weight
      return shipDays <= days

    l = max(weights)
    r = sum(weights)
    return bisect.bisect_left(range(l, r), True,
                              key=lambda m: canShip(m)) + l

```

## 491. Increasing Subsequences_491.py

```python
class Solution:
  def findSubsequences(self, nums: List[int]) -> List[List[int]]:
    ans = []

    def dfs(s: int, path: List[int]) -> None:
      if len(path) > 1:
        ans.append(path)

      used = set()

      for i in range(s, len(nums)):
        if nums[i] in used:
          continue
        if not path or nums[i] >= path[-1]:
          used.add(nums[i])
          dfs(i + 1, path + [nums[i]])

    dfs(0, [])
    return ans

```

## 881. Boats to Save People_881.py

```python
class Solution:
  def numRescueBoats(self, people: List[int], limit: int) -> int:
    ans = 0
    i = 0
    j = len(people) - 1

    people.sort()

    while i <= j:
      remain = limit - people[j]
      j -= 1
      if people[i] <= remain:
        i += 1
      ans += 1

    return ans

```

## 1813. Sentence Similarity III_1813.py

```python
class Solution:
  def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:
    if len(sentence1) == len(sentence2):
      return sentence1 == sentence2

    words1 = sentence1.split()
    words2 = sentence2.split()
    m, n = map(len, (words1, words2))
    if m > n:
      return self.areSentencesSimilar(sentence2, sentence1)

    i = 0  # words1's index
    while i < m and words1[i] == words2[i]:
      i += 1
    while i < m and words1[i] == words2[i + n - m]:
      i += 1

    return i == m

```

## 2684. Maximum Number of Moves in a Grid_2684.py

```python
class Solution:
  def maxMoves(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    # dp[i][j] := the maximum number of moves you can perform from (i, j)
    dp = [[0] * n for _ in range(m)]

    for j in range(n - 2, -1, -1):
      for i in range(m):
        if grid[i][j + 1] > grid[i][j]:
          dp[i][j] = 1 + dp[i][j + 1]
        if i > 0 and grid[i - 1][j + 1] > grid[i][j]:
          dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])
        if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:
          dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])

    return max(dp[i][0] for i in range(m))

```

## 2300. Successful Pairs of Spells and Potions_2300.py

```python
class Solution:
  def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:
    potions.sort()

    def firstIndexSuccess(spell: int):
      """Returns the first index i s.t. spell * potions[i] >= success."""
      l = 0
      r = len(potions)
      while l < r:
        m = (l + r) // 2
        if spell * potions[m] >= success:
          r = m
        else:
          l = m + 1
      return l

    return [len(potions) - firstIndexSuccess(spell) for spell in spells]

```

## 150. Evaluate Reverse Polish Notation_150.py

```python
class Solution:
  def evalRPN(self, tokens: List[str]) -> int:
    stack = []
    op = {
        '+': lambda a, b: a + b,
        '-': lambda a, b: a - b,
        '*': lambda a, b: a * b,
        '/': lambda a, b: int(a / b),
    }

    for token in tokens:
      if token in op:
        b = stack.pop()
        a = stack.pop()
        stack.append(op[token](a, b))
      else:
        stack.append(int(token))

    return stack.pop()

```

## 982. Triples with Bitwise AND Equal To Zero_982.py

```python
class Solution:
  def countTriplets(self, nums: List[int]) -> int:
    kMax = 1 << 16
    ans = 0
    count = [0] * kMax  # {nums[i] & nums[j]: times}

    for a in nums:
      for b in nums:
        count[a & b] += 1

    for num in nums:
      for i in range(kMax):
        if (num & i) == 0:
          ans += count[i]

    return ans

```

## 404. Sum of Left Leaves_404-2.py

```python
class Solution:
  def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
    if not root:
      return 0

    ans = 0
    stack = [root]

    while stack:
      root = stack.pop()
      if root.left:
        if not root.left.left and not root.left.right:
          ans += root.left.val
        else:
          stack.append(root.left)
      if root.right:
        stack.append(root.right)

    return ans

```

## 139. Word Break_139-3.py

```python
class Solution:
  def wordBreak(self, s: str, wordDict: List[str]) -> bool:
    n = len(s)
    wordSet = set(wordDict)
    # dp[i] := True if s[0..i) can be segmented
    dp = [True] + [False] * n

    for i in range(1, n + 1):
      for j in range(i):
        # s[0..j) can be segmented and s[j..i) is in `wordSet`, so s[0..i) can
        # be segmented.
        if dp[j] and s[j:i] in wordSet:
          dp[i] = True
          break

    return dp[n]

```

## 228. Summary Ranges_228.py

```python
class Solution:
  def summaryRanges(self, nums: List[int]) -> List[str]:
    ans = []

    i = 0
    while i < len(nums):
      begin = nums[i]
      while i < len(nums) - 1 and nums[i] == nums[i + 1] - 1:
        i += 1
      end = nums[i]
      if begin == end:
        ans.append(str(begin))
      else:
        ans.append(str(begin) + "->" + str(end))
      i += 1

    return ans

```

## 2919. Minimum Increment Operations to Make Array Beautiful_2919.py

```python
class Solution:
  def minIncrementOperations(self, nums: List[int], k: int) -> int:
    # the minimum operations to increase nums[i - 3] and nums[0..i - 3)
    prev3 = 0
    # the minimum operations to increase nums[i - 2] and nums[0..i - 2)
    prev2 = 0
    # the minimum operations to increase nums[i - 1] and nums[0..i - 1)
    prev1 = 0

    for num in nums:
      dp = min(prev1, prev2, prev3) + max(0, k - num)
      prev3 = prev2
      prev2 = prev1
      prev1 = dp

    return min(prev1, prev2, prev3)

```

## 2305. Fair Distribution of Cookies_2305.py

```python
class Solution:
  def distributeCookies(self, cookies: List[int], k: int) -> int:
    ans = math.inf

    def dfs(s: int, children: List[int]) -> None:
      nonlocal ans
      if s == len(cookies):
        ans = min(ans, max(children))
        return

      for i in range(k):
        children[i] += cookies[s]
        dfs(s + 1, children)
        children[i] -= cookies[s]

    dfs(0, [0] * k)
    return ans

```

## 2054. Two Best Non-Overlapping Events_2054.py

```python
class Solution:
  def maxTwoEvents(self, events: List[List[int]]) -> int:
    ans = 0
    maxValue = 0
    evts = []  # (time, isStart, value)

    for s, e, v in events:
      evts.append((s, 1, v))
      evts.append((e + 1, 0, v))

    # When two events have the same time, the one is not start will be in the front
    evts.sort()

    for _, isStart, value in evts:
      if isStart:
        ans = max(ans, value + maxValue)
      else:
        maxValue = max(maxValue, value)

    return ans

```

## 3211. Generate Binary Strings Without Adjacent Zeros_3211.py

```python
class Solution:
  def validStrings(self, n: int) -> List[str]:
    ans = []

    def dfs(n: int, s: List[str]) -> None:
      if n == 0:
        ans.append(''.join(s))
        return
      if not s or s[-1] == '1':
        s.append('0')
        dfs(n - 1, s)
        s.pop()
      s.append('1')
      dfs(n - 1, s)
      s.pop()

    dfs(n, [])
    return ans

```

## 430. Flatten a Multilevel Doubly Linked List_430-2.py

```python
class Solution:
  def flatten(self, head: 'Node') -> 'Node':
    curr = head

    while curr:
      if curr.child:
        cachedNext = curr.next
        curr.next = curr.child
        curr.child.prev = curr
        curr.child = None
        tail = curr.next
        while tail.next:
          tail = tail.next
        tail.next = cachedNext
        if cachedNext:
          cachedNext.prev = tail
      curr = curr.next

    return head

```

## 1727. Largest Submatrix With Rearrangements_1727.py

```python
class Solution:
  def largestSubmatrix(self, matrix: List[List[int]]) -> int:
    ans = 0
    hist = [0] * len(matrix[0])

    for row in matrix:
      # Accumulate the histogram if possible.
      for i, num in enumerate(row):
        hist[i] = 0 if num == 0 else hist[i] + 1

      # Get the sorted histogram.
      sortedHist = sorted(hist)

      # Greedily calculate the answer.
      for i, h in enumerate(sortedHist):
        ans = max(ans, h * (len(row) - i))

    return ans

```

## 2284. Sender With Largest Word Count_2284.py

```python
class Solution:
  def largestWordCount(self, messages: List[str], senders: List[str]) -> str:
    n = len(messages)
    ans = ''
    maxWordsSent = 0
    count = collections.Counter()  # [sender, # Words sent]

    for message, sender in zip(messages, senders):
      wordsCount = message.count(' ') + 1
      count[sender] += wordsCount
      numWordsSent = count[sender]
      if numWordsSent > maxWordsSent:
        ans = sender
        maxWordsSent = numWordsSent
      elif numWordsSent == maxWordsSent and sender > ans:
        ans = sender

    return ans

```

## 1252. Cells with Odd Values in a Matrix_1252-2.py

```python
class Solution:
  def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:
    # rows[i] and cols[i] :=
    #   1. True (flipped even times)
    #   2. False (flipped odd times)
    rows = [False] * m
    cols = [False] * n

    for r, c in indices:
      rows[r] ^= True
      cols[c] ^= True

    oddRowsCount = rows.count(True)
    oddColsCount = cols.count(True)
    evenRowsCount = m - oddRowsCount
    evenColsCount = n - oddColsCount
    return oddRowsCount * evenColsCount + oddColsCount * evenRowsCount

```

## 2046. Sort Linked List Already Sorted Using Absolute Values_2046.py

```python
class Solution:
  def sortLinkedList(self, head: Optional[ListNode]) -> Optional[ListNode]:
    prev = head
    curr = head.next

    while curr:
      if curr.val < 0:
        prev.next = curr.next
        curr.next = head
        head = curr
        curr = prev.next
      else:
        prev = curr
        curr = curr.next

    return head

```

## 1437. Check If All 1's Are at Least Length K Places Away_1437.py

```python
class Solution:
  def kLengthApart(self, nums: List[int], k: int) -> bool:
    if k == 0:
      return True

    n = len(nums)

    curr = 0
    next = 1

    while curr < n and next < n:
      if nums[next] == 1:
        if nums[curr] == 1 and next - curr <= k:
          return False
        curr = next
      next += 1

    return True

```

## 106. Construct Binary Tree from Inorder and Postorder Traversal_106.py

```python
class Solution:
  def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
    inToIndex = {num: i for i, num in enumerate(inorder)}

    def build(inStart: int, inEnd: int, postStart: int, postEnd: int) -> Optional[TreeNode]:
      if inStart > inEnd:
        return None

      rootVal = postorder[postEnd]
      rootInIndex = inToIndex[rootVal]
      leftSize = rootInIndex - inStart

      root = TreeNode(rootVal)
      root.left = build(inStart, rootInIndex - 1,  postStart,
                        postStart + leftSize - 1)
      root.right = build(rootInIndex + 1, inEnd,  postStart + leftSize,
                         postEnd - 1)
      return root

    return build(0, len(inorder) - 1, 0, len(postorder) - 1)

```

## 2933. High-Access Employees_2933.py

```python
class Solution:
  def findHighAccessEmployees(self, access_times: List[List[str]]) -> List[str]:
    ans = set()

    access_times.sort()

    for i in range(len(access_times) - 2):
      name = access_times[i][0]
      if name in ans:
        continue
      if name != access_times[i + 2][0]:
        continue
      if int(access_times[i + 2][1]) - int(access_times[i][1]) < 100:
        ans.add(name)

    return list(ans)

```

## 67. Add Binary_67.py

```python
class Solution:
  def addBinary(self, a: str, b: str) -> str:
    ans = []
    carry = 0
    i = len(a) - 1
    j = len(b) - 1

    while i >= 0 or j >= 0 or carry:
      if i >= 0:
        carry += int(a[i])
        i -= 1
      if j >= 0:
        carry += int(b[j])
        j -= 1
      ans.append(str(carry % 2))
      carry //= 2

    return ''.join(reversed(ans))

```

## 748. Shortest Completing Word_748.py

```python
class Solution:
  def shortestCompletingWord(self, licensePlate: str, words: List[str]) -> str:
    def isMatch(word: str) -> bool:
      wordCount = collections.Counter(word)
      return False if any(wordCount[i] < count[i] for i in string.ascii_letters) else True

    ans = '*' * 16
    count = collections.defaultdict(int)

    for c in licensePlate:
      if c.isalpha():
        count[c.lower()] += 1

    for word in words:
      if len(word) < len(ans) and isMatch(word):
        ans = word

    return ans

```

## 576. Out of Boundary Paths_576.py

```python
class Solution:
  def findPaths(self, m, n, maxMove, startRow, startColumn):
    kMod = 1000000007

    @functools.lru_cache(None)
    def dp(k: int, i: int, j: int) -> int:
      """
      Returns the number of paths to move the ball at (i, j) out-of-bounds with
      k moves.
      """
      if i < 0 or i == m or j < 0 or j == n:
        return 1
      if k == 0:
        return 0
      return (dp(k - 1, i + 1, j) + dp(k - 1, i - 1, j) +
              dp(k - 1, i, j + 1) + dp(k - 1, i, j - 1)) % kMod

    return dp(maxMove, startRow, startColumn)

```

## 313. Super Ugly Number_313.py

```python
class Solution:
  def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:
    k = len(primes)
    nums = [1]
    indices = [0] * k

    while len(nums) < n:
      nexts = [0] * k
      for i in range(k):
        nexts[i] = nums[indices[i]] * primes[i]
      next = min(nexts)
      for i in range(k):
        if next == nexts[i]:
          indices[i] += 1
      nums.append(next)

    return nums[-1]

```

## 1235. Maximum Profit in Job Scheduling_1235-3.py

```python
class Solution:
  def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:
    maxProfit = 0
    jobs = sorted([(s, e, p) for s, e, p in zip(startTime, endTime, profit)])
    minHeap = []  # (endTime, profit)

    # Will use binary search to find the first available startTime
    for i in range(len(startTime)):
      startTime[i] = jobs[i][0]

    for s, e, p in jobs:
      while minHeap and s >= minHeap[0][0]:
        maxProfit = max(maxProfit, heapq.heappop(minHeap)[1])
      heapq.heappush(minHeap, (e, p + maxProfit))

    return max(maxProfit, max(p for _, p in minHeap))

```

## 794. Valid Tic-Tac-Toe State_794.py

```python
class Solution:
  def validTicTacToe(self, board: List[str]) -> bool:
    def isWin(c: str) -> bool:
      return any(row.count(c) == 3 for row in board) or \
          any(row.count(c) == 3 for row in list(zip(*board))) or \
          all(board[i][i] == c for i in range(3)) or \
          all(board[i][2 - i] == c for i in range(3))

    countX = sum(row.count('X') for row in board)
    countO = sum(row.count('O') for row in board)

    if countX < countO or countX - countO > 1:
      return False
    if isWin('X') and countX == countO or isWin('O') and countX != countO:
      return False

    return True

```

## 86. Partition List_86.py

```python
class Solution:
  def partition(self, head: ListNode, x: int) -> ListNode:
    beforeHead = ListNode(0)
    afterHead = ListNode(0)
    before = beforeHead
    after = afterHead

    while head:
      if head.val < x:
        before.next = head
        before = head
      else:
        after.next = head
        after = head
      head = head.next

    after.next = None
    before.next = afterHead.next

    return beforeHead.next

```

## 1930. Unique Length-3 Palindromic Subsequences_1930.py

```python
class Solution:
  def countPalindromicSubsequence(self, s: str) -> int:
    ans = 0
    first = [len(s)] * 26
    last = [0] * 26

    for i, c in enumerate(s):
      index = ord(c) - ord('a')
      first[index] = min(first[index], i)
      last[index] = i

    for f, l in zip(first, last):
      if f < l:
        ans += len(set(s[f + 1:l]))

    return ans

```

## 276. Paint Fence_276.py

```python
class Solution:
  def numWays(self, n: int, k: int) -> int:
    if n == 0:
      return 0
    if n == 1:
      return k
    if n == 2:
      return k * k

    # dp[i] := the number of ways to pan posts with k colors
    dp = [0] * (n + 1)
    dp[0] = 0
    dp[1] = k
    dp[2] = k * k

    for i in range(3, n + 1):
      dp[i] = (dp[i - 1] + dp[i - 2]) * (k - 1)

    return dp[n]

```

## 329. Longest Increasing Path in a Matrix_329.py

```python
class Solution:
  def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
    m = len(matrix)
    n = len(matrix[0])

    @functools.lru_cache(None)
    def dfs(i: int, j: int, prev: int) -> int:
      if i < 0 or i == m or j < 0 or j == n:
        return 0
      if matrix[i][j] <= prev:
        return 0

      curr = matrix[i][j]
      return 1 + max(dfs(i + 1, j, curr),
                     dfs(i - 1, j, curr),
                     dfs(i, j + 1, curr),
                     dfs(i, j - 1, curr))

    return max(dfs(i, j, -math.inf) for i in range(m) for j in range(n))

```

## 424. Longest Repeating Character Replacement_424.py

```python
class Solution:
  def characterReplacement(self, s: str, k: int) -> int:
    ans = 0
    maxCount = 0
    count = collections.Counter()

    l = 0
    for r, c in enumerate(s):
      count[c] += 1
      maxCount = max(maxCount, count[c])
      while maxCount + k < r - l + 1:
        count[s[l]] -= 1
        l += 1
      ans = max(ans, r - l + 1)

    return ans

```

## 2135. Count Words Obtained After Adding a Letter_2135.py

```python
class Solution:
  def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:
    def getMask(s: str) -> int:
      mask = 0
      for c in s:
        mask ^= 1 << ord(c) - ord('a')
      return mask

    ans = 0
    seen = set(getMask(w) for w in startWords)

    for targetWord in targetWords:
      mask = getMask(targetWord)
      for c in targetWord:
        # Toggle one character.
        if mask ^ 1 << ord(c) - ord('a') in seen:
          ans += 1
          break

    return ans

```

## 2574. Left and Right Sum Differences_2574.py

```python
class Solution:
  def leftRigthDifference(self, nums: List[int]) -> List[int]:
    n = len(nums)
    leftSum = [0] * n
    rightSum = [0] * n
    prefix = 0
    suffix = 0

    for i in range(n):
      if i > 0:
        prefix += nums[i - 1]
      leftSum[i] = prefix

    for i in range(n - 1, -1, -1):
      if i + 1 < n:
        suffix += nums[i + 1]
      rightSum[i] = suffix

    return [abs(l - r) for l, r in zip(leftSum, rightSum)]

```

## 213. House Robber II_213.py

```python
class Solution:
  def rob(self, nums: List[int]) -> int:
    if not nums:
      return 0
    if len(nums) < 2:
      return nums[0]

    def rob(l: int, r: int) -> int:
      dp1 = 0
      dp2 = 0

      for i in range(l, r + 1):
        temp = dp1
        dp1 = max(dp1, dp2 + nums[i])
        dp2 = temp

      return dp1

    return max(rob(0, len(nums) - 2),
               rob(1, len(nums) - 1))

```

## 2768. Number of Black Blocks_2768.py

```python
class Solution:
  def countBlackBlocks(self, m: int, n: int, coordinates: List[List[int]]) -> List[int]:
    ans = [0] * 5
    # count[i * n + j] := the number of black cells in
    # (i - 1, j - 1), (i - 1, j), (i, j - 1), (i, j)
    count = collections.Counter()

    for x, y in coordinates:
      for i in range(x, x + 2):
        for j in range(y, y + 2):
          # 2 x 2 submatrix with right-bottom conner being (i, j) contains the
          # current black cell (x, y).
          if 0 < i < m and 0 < j < n:
            count[(i, j)] += 1

    for freq in count.values():
      ans[freq] += 1

    ans[0] = (m - 1) * (n - 1) - sum(ans)
    return ans

```

## 902. Numbers At Most N Given Digit Set_902.py

```python
class Solution:
  def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:
    ans = 0
    num = str(n)

    for i in range(1, len(num)):
      ans += pow(len(digits), i)

    for i, c in enumerate(num):
      dHasSameNum = False
      for digit in digits:
        if digit[0] < c:
          ans += pow(len(digits), len(num) - i - 1)
        elif digit[0] == c:
          dHasSameNum = True
      if not dHasSameNum:
        return ans

    return ans + 1

```

## 1997. First Day Where You Have Been in All the Rooms_1997.py

```python
class Solution:
  def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:
    kMod = 1_000_000_007
    n = len(nextVisit)
    # dp[i] := the number of days to visit room i for the first time
    dp = [0] * n

    # Whenever we visit i, visit times of room[0..i - 1] are all even.
    # Therefore, the rooms before i can be seen as reset and we can safely
    # reuse dp[0..i - 1] as first-time visit to get second-time visit.
    for i in range(1, n):
      # The total days to visit room[i] is the sum of
      #   * dp[i - 1]: 1st-time visit room[i - 1]
      #   * 1: visit room[nextVisit[i - 1]]
      #   * dp[i - 1] - dp[nextVisit[i - 1]]: 2-time visit room[i - 1]
      #   * 1: visit room[i]
      dp[i] = (2 * dp[i - 1] - dp[nextVisit[i - 1]] + 2) % kMod

    return dp[-1]

```

## 2222. Number of Ways to Select Buildings_2222.py

```python
class Solution:
  def numberOfWays(self, s: str) -> int:
    ans = 0
    # before[i] := the number of i before the current digit
    before = [0] * 2
    # after[i] := the number of i after the current digit
    after = [0] * 2
    after[0] = s.count('0')
    after[1] = len(s) - after[0]

    for c in s:
      num = ord(c) - ord('0')
      after[num] -= 1
      if num == 0:
        ans += before[1] * after[1]
      else:
        ans += before[0] * after[0]
      before[num] += 1

    return ans

```

## 1326. Minimum Number of Taps to Open to Water a Garden_1326.py

```python
class Solution:
  def minTaps(self, n: int, ranges: List[int]) -> int:
    nums = [0] * (n + 1)

    for i, range_ in enumerate(ranges):
      l = max(0, i - range_)
      r = min(n, range_ + i)
      nums[l] = max(nums[l], r - l)

    ans = 0
    end = 0
    farthest = 0

    for i in range(n):
      farthest = max(farthest, i + nums[i])
      if i == end:
        ans += 1
        end = farthest

    return ans if end == n else -1

```

## 336. Palindrome Pairs_336.py

```python
class Solution:
  def palindromePairs(self, words: List[str]) -> List[List[int]]:
    ans = []
    dict = {word[::-1]: i for i, word in enumerate(words)}

    for i, word in enumerate(words):
      if "" in dict and dict[""] != i and word == word[::-1]:
        ans.append([i, dict[""]])

      for j in range(1, len(word) + 1):
        l = word[:j]
        r = word[j:]
        if l in dict and dict[l] != i and r == r[::-1]:
          ans.append([i, dict[l]])
        if r in dict and dict[r] != i and l == l[::-1]:
          ans.append([dict[r], i])

    return ans

```

## 1865. Finding Pairs With a Certain Sum_1865.py

```python
class FindSumPairs:
  def __init__(self, nums1: List[int], nums2: List[int]):
    self.nums1 = nums1
    self.nums2 = nums2
    self.count2 = collections.Counter(nums2)

  def add(self, index: int, val: int) -> None:
    self.count2[self.nums2[index]] -= 1
    self.nums2[index] += val
    self.count2[self.nums2[index]] += 1

  def count(self, tot: int) -> int:
    ans = 0
    for num in self.nums1:
      ans += self.count2[tot - num]
    return ans

```

## 1509. Minimum Difference Between Largest and Smallest Value in Three Moves_1509.py

```python
class Solution:
  def minDifference(self, nums: List[int]) -> int:
    n = len(nums)
    if n < 5:
      return 0

    ans = math.inf

    nums.sort()

    # 1. Change nums[0..i) to nums[i].
    # 2. Change nums[n - 3 + i..n) to nums[n - 4 + i].
    for i in range(4):
      ans = min(ans, nums[n - 4 + i] - nums[i])

    return ans

```

## 611. Valid Triangle Number_611.py

```python
class Solution:
  def triangleNumber(self, nums: List[int]) -> int:
    ans = 0

    nums.sort()

    for k in range(len(nums) - 1, 1, -1):
      i = 0
      j = k - 1
      while i < j:
        if nums[i] + nums[j] > nums[k]:
          ans += j - i
          j -= 1
        else:
          i += 1

    return ans

```

## 2923. Find Champion I_2923.py

```python
class Solution:
  def findChampion(self, grid: List[List[int]]) -> int:
    n = len(grid)
    inDegrees = [0] * n

    for i in range(n):
      for j in range(n):
        if i == j:
          continue
        if grid[i][j] == 1:
          inDegrees[j] += 1
        else:
          inDegrees[i] += 1

    return -1 if inDegrees.count(0) > 1 \
        else inDegrees.index(0)

```

## 687. Longest Univalue Path_687.py

```python
class Solution:
  def longestUnivaluePath(self, root: Optional[TreeNode]) -> int:
    ans = 0

    def longestUnivaluePathDownFrom(root: Optional[TreeNode]) -> int:
      nonlocal ans
      if not root:
        return 0

      l = longestUnivaluePathDownFrom(root.left)
      r = longestUnivaluePathDownFrom(root.right)
      arrowLeft = l + 1 if root.left and root.left.val == root.val else 0
      arrowRight = r + 1 if root.right and root.right.val == root.val else 0
      ans = max(ans, arrowLeft + arrowRight)
      return max(arrowLeft, arrowRight)

    longestUnivaluePathDownFrom(root)
    return ans

```

## 2267. Check if There Is a Valid Parentheses String Path_2267.py

```python
class Solution:
  def hasValidPath(self, grid: List[List[str]]) -> bool:
    @functools.lru_cache(None)
    def dp(i: int, j: int, k: int) -> bool:
      """
      Returns True if there's a path from grid[i][j] to grid[m - 1][n - 1],
      where the number of '(' - the number of ')' == k.
      """
      if i == len(grid) or j == len(grid[0]):
        return False
      k += 1 if grid[i][j] == '(' else -1
      if k < 0:
        return False
      if i == len(grid) - 1 and j == len(grid[0]) - 1:
        return k == 0
      return dp(i + 1, j, k) | dp(i, j + 1, k)

    return dp(0, 0, 0)

```

## 1235. Maximum Profit in Job Scheduling_1235.py

```python
class Solution:
  def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:
    jobs = sorted([(s, e, p) for s, e, p in zip(startTime, endTime, profit)])

    # Will use binary search to find the first available startTime
    for i in range(len(startTime)):
      startTime[i] = jobs[i][0]

    @functools.lru_cache(None)
    def dp(i: int) -> int:
      """Returns the maximum profit to schedule jobs[i..n)."""
      if i == len(startTime):
        return 0
      j = bisect.bisect_left(startTime, jobs[i][1])
      return max(jobs[i][2] + dp(j), dp(i + 1))

    return dp(0)

```

## 1249. Minimum Remove to Make Valid Parentheses_1249.py

```python
class Solution:
  def minRemoveToMakeValid(self, s: str) -> str:
    stack = []  # unpaired '(' indices
    chars = list(s)

    for i, c in enumerate(chars):
      if c == '(':
        stack.append(i)  # Record the unpaired '(' index.
      elif c == ')':
        if stack:
          stack.pop()  # Find a pair
        else:
          chars[i] = '*'  # Mark the unpaired ')' as '*'.

    # Mark the unpaired '(' as '*'.
    while stack:
      chars[stack.pop()] = '*'

    return ''.join(chars).replace('*', '')

```

## 2430. Maximum Deletions on a String_2430.py

```python
class Solution:
  def deleteString(self, s: str) -> int:
    n = len(s)
    # lcs[i][j] := the number of the same letters of s[i..n) and s[j..n)
    lcs = [[0] * (n + 1) for _ in range(n + 1)]
    # dp[i] := the maximum number of operations needed to delete s[i..n)
    dp = [1] * n

    for i in reversed(range(n)):
      for j in range(i + 1, n):
        if s[i] == s[j]:
          lcs[i][j] = lcs[i + 1][j + 1] + 1
        if lcs[i][j] >= j - i:
          dp[i] = max(dp[i], dp[j] + 1)

    return dp[0]

```

## 2927. Distribute Candies Among Children III_2927.py

```python
class Solution:
  def distributeCandies(self, n: int, limit: int) -> int:
    def ways(n: int) -> int:
      """Returns the number of ways to distribute n candies to 3 children."""
      if n < 0:
        return 0
      # Stars and bars method:
      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where
      # stars (*) := candies and bars (|) := dividers between children.
      return math.comb(n + 2, 2)

    limitPlusOne = limit + 1
    oneChildExceedsLimit = ways(n - limitPlusOne)
    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)
    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)
    # Principle of Inclusion-Exclusion (PIE)
    return ways(n) \
        - 3 * oneChildExceedsLimit \
        + 3 * twoChildrenExceedLimit \
        - threeChildrenExceedLimit

```

## 1669. Merge In Between Linked Lists_1669.py

```python
class Solution:
  def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:
    nodeBeforeA = list1
    for i in range(a - 1):
      nodeBeforeA = nodeBeforeA.next

    nodeB = nodeBeforeA.next
    for i in range(b - a):
      nodeB = nodeB.next

    nodeBeforeA.next = list2
    lastNodeInList2 = list2

    while lastNodeInList2.next:
      lastNodeInList2 = lastNodeInList2.next

    lastNodeInList2.next = nodeB.next
    nodeB.next = None
    return list1

```

## 173. Binary Search Tree Iterator_173-2.py

```python
class BSTIterator:
  def __init__(self, root: Optional[TreeNode]):
    self.stack = []
    self._pushLeftsUntilNull(root)

  def next(self) -> int:
    root = self.stack.pop()
    self._pushLeftsUntilNull(root.right)
    return root.val

  def hasNext(self) -> bool:
    return self.stack

  def _pushLeftsUntilNull(self, root: Optional[TreeNode]) -> None:
    while root:
      self.stack.append(root)
      root = root.left

```

## 768. Max Chunks To Make Sorted II_768.py

```python
class Solution:
  def maxChunksToSorted(self, arr: List[int]) -> int:
    n = len(arr)
    ans = 0
    mx = -math.inf
    mn = [arr[-1]] * n

    for i in reversed(range(n - 1)):
      mn[i] = min(mn[i + 1], arr[i])

    for i in range(n - 1):
      mx = max(mx, arr[i])
      if mx <= mn[i + 1]:
        ans += 1

    return ans + 1

```

## 1714. Sum Of Special Evenly-Spaced Elements In Array_1714.py

```python
class Solution:
  def solve(self, nums: List[int], queries: List[List[int]]) -> List[int]:
    kMod = 10**9 + 7
    n = len(nums)
    sqrtN = int(n**0.5)
    # prefix[x][y] = sum(nums[x + ay]), where a >= 0 and x + ay < n
    # Set prefix[i][j] to nums[i] to indicate the sequence starts with nums[i].
    prefix = [[num] * sqrtN for num in nums]

    for x in range(n - 1, -1, -1):
      for y in range(1, sqrtN):
        if x + y < n:
          prefix[x][y] += prefix[x + y][y]
          prefix[x][y] %= kMod

    return [prefix[x][y] if y < sqrtN
            else sum(nums[x::y]) % kMod
            for x, y in queries]

```

## 343. Integer Break_343.py

```python
class Solution:
  def integerBreak(self, n: int) -> int:
    # If an optimal product contains a factor f >= 4, then we can replace it
    # with 2 and f - 2 without losing optimality. As 2(f - 2) = 2f - 4 >= f,
    # we never need a factor >= 4, meaning we only need factors 1, 2, and 3
    # (and 1 is wasteful).
    # Also, 3 * 3 is better than 2 * 2 * 2, so we never use 2 more than twice.
    if n == 2:  # 1 * 1
      return 1
    if n == 3:  # 1 * 2
      return 2

    ans = 1

    while n > 4:
      n -= 3
      ans *= 3
    ans *= n

    return ans

```

## 1157. Online Majority Element In Subarray_1157.py

```python
class MajorityChecker:
  def __init__(self, arr: List[int]):
    self.arr = arr
    self.kTimes = 20  # 2^kTimes >> |arr|
    self.numToIndices = collections.defaultdict(list)

    for i, a in enumerate(self.arr):
      self.numToIndices[a].append(i)

  def query(self, left: int, right: int, threshold: int) -> int:
    for _ in range(self.kTimes):
      randIndex = random.randint(left, right)
      num = self.arr[randIndex]
      indices = self.numToIndices[num]
      l = bisect.bisect_left(indices, left)
      r = bisect.bisect_right(indices, right)
      if r - l >= threshold:
        return num

    return -1

```

## 3175. Find The First Player to win K Games in a Row_3175.py

```python
class Solution:
  # Similar to 1535. Find the Winner of an Array Game
  def findWinningPlayer(self, skills: List[int], k: int) -> int:
    ans = 0
    wins = 0

    i = 1
    while i < len(skills) and wins < k:
      if skills[i] > skills[ans]:
        ans = i
        wins = 1
      else:
        wins += 1
      i += 1

    return ans

```

## 629. K Inverse Pairs Array_629.py

```python
class Solution:
  def kInversePairs(self, n: int, k: int) -> int:
    kMod = 1_000_000_007
    # dp[i][j] := the number of permutations of numbers 1..i with j inverse pairs
    dp = [[0] * (k + 1) for _ in range(n + 1)]

    # If there's no inverse pair, the permutation is unique '123..i'
    for i in range(n + 1):
      dp[i][0] = 1

    for i in range(1, n + 1):
      for j in range(1, k + 1):
        dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % kMod
        if j - i >= 0:
          dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + kMod) % kMod

    return dp[n][k]

```

## 1015. Smallest Integer Divisible by K_1015.py

```python
class Solution:
  def smallestRepunitDivByK(self, k: int) -> int:
    if k % 10 not in {1, 3, 7, 9}:
      return -1

    seen = set()
    n = 0

    for length in range(1, k + 1):
      n = (n * 10 + 1) % k
      if n == 0:
        return length
      if n in seen:
        return -1
      seen.add(n)

    return -1

```

## 2516. Take K of Each Character From Left and Right_2516.py

```python
class Solution:
  def takeCharacters(self, s: str, k: int) -> int:
    n = len(s)
    ans = n
    count = collections.Counter(s)
    if any(count[c] < k for c in 'abc'):
      return -1

    l = 0
    for r, c in enumerate(s):
      count[c] -= 1
      while count[c] < k:
        count[s[l]] += 1
        l += 1
      ans = min(ans, n - (r - l + 1))

    return ans

```

## 281. Zigzag Iterator_281.py

```python
class ZigzagIterator:
  def __init__(self, v1: List[int], v2: List[int]):
    def vals():
      for i in itertools.count():
        for v in v1, v2:
          if i < len(v):
            yield v[i]
    self.vals = vals()
    self.n = len(v1) + len(v2)

  def next(self):
    self.n -= 1
    return next(self.vals)

  def hasNext(self):
    return self.n > 0

```

## 1499. Max Value of Equation_1499-2.py

```python
class Solution:
  def findMaxValueOfEquation(self, points: List[List[int]], k: int) -> int:
    ans = -math.inf
    maxQ = collections.deque()  # (y - x, x)

    for x, y in points:
      # Remove the invalid points, xj - xi > k
      while maxQ and x - maxQ[0][1] > k:
        maxQ.popleft()
      if maxQ:
        ans = max(ans, x + y + maxQ[0][0])
      # Remove the points that contribute less value and have a bigger x.
      while maxQ and y - x >= maxQ[-1][0]:
        maxQ.pop()
      maxQ.append((y - x, x))

    return ans

```

## 1081. Smallest Subsequence of Distinct Characters_1081.py

```python
class Solution:
  def smallestSubsequence(self, text: str) -> str:
    ans = []
    count = collections.Counter(text)
    used = [False] * 26

    for c in text:
      count[c] -= 1
      if used[ord(c) - ord('a')]:
        continue
      while ans and ans[-1] > c and count[ans[-1]] > 0:
        used[ord(ans[-1]) - ord('a')] = False
        ans.pop()
      ans.append(c)
      used[ord(ans[-1]) - ord('a')] = True

    return ''.join(ans)

```

## 316. Remove Duplicate Letters_316.py

```python
class Solution:
  def removeDuplicateLetters(self, s: str) -> str:
    ans = []
    count = collections.Counter(s)
    used = [False] * 26

    for c in s:
      count[c] -= 1
      if used[ord(c) - ord('a')]:
        continue
      while ans and ans[-1] > c and count[ans[-1]] > 0:
        used[ord(ans[-1]) - ord('a')] = False
        ans.pop()
      ans.append(c)
      used[ord(ans[-1]) - ord('a')] = True

    return ''.join(ans)

```

## 650. 2 Keys Keyboard_650.py

```python
class Solution:
  def minSteps(self, n: int) -> int:
    if n <= 1:
      return 0

    # dp[i] := the minimum steps to get i 'A's
    # Copy 'A', then paste 'A' i - 1 times.
    dp = [i for i in range(n + 1)]

    for i in range(2, n + 1):
      for j in range(i // 2, 2, -1):
        if i % j == 0:
          dp[i] = dp[j] + i // j  # Paste dp[j] i / j times.
          break

    return dp[n]

```

## 2786. Visit Array Positions to Maximize Score_2786.py

```python
class Solution:
  def maxScore(self, nums: List[int], x: int) -> int:
    # Note that we always need to take nums[0], so the initial definition might
    # not hold true.

    # dp0 := the maximum score so far with `nums` ending in an even number
    dp0 = nums[0] - (x if nums[0] % 2 == 1 else 0)
    # dp0 := the maximum score so far with `nums` ending in an odd number
    dp1 = nums[0] - (x if nums[0] % 2 == 0 else 0)

    for i in range(1, len(nums)):
      if nums[i] % 2 == 0:
        dp0 = nums[i] + max(dp0, dp1 - x)
      else:
        dp1 = nums[i] + max(dp1, dp0 - x)

    return max(dp0, dp1)

```

## 1861. Rotating the Box_1861.py

```python
class Solution:
  def rotateTheBox(self, box: List[List[str]]) -> List[List[str]]:
    m = len(box)
    n = len(box[0])
    rotated = [['.'] * m for _ in range(n)]

    for i in range(m):
      k = n - 1
      for j in reversed(range(n)):
        if box[i][j] != '.':
          if box[i][j] == '*':
            k = j
          rotated[k][m - i - 1] = box[i][j]
          k -= 1

    return [''.join(row) for row in rotated]

```

## 2231. Largest Number After Digit Swaps by Parity_2231.py

```python
class Solution:
  def largestInteger(self, num: int) -> int:
    s = str(num)
    ans = 0
    # maxHeap[0] := the odd digits
    # maxHeap[1] := the even digits
    maxHeap = [[] for _ in range(2)]

    for c in s:
      digit = ord(c) - ord('0')
      heapq.heappush(maxHeap[digit % 2], -digit)

    for c in s:
      i = ord(c) - ord('0') & 1
      ans = (ans * 10 - heapq.heappop(maxHeap[i]))

    return ans

```

## 2361. Minimum Costs Using the Train Line_2361.py

```python
class Solution:
  def minimumCosts(self, regular: List[int], express: List[int], expressCost: int) -> List[int]:
    n = len(regular)
    ans = [0] * n
    # the minimum cost to reach the current stop in a regular route
    dpReg = 0
    # the minimum cost to reach the current stop in an express route
    dpExp = expressCost

    for i in range(n):
      prevReg = dpReg
      prevExp = dpExp
      dpReg = min(prevReg + regular[i], prevExp + 0 + regular[i])
      dpExp = min(prevReg + expressCost + express[i], prevExp + express[i])
      ans[i] = min(dpReg, dpExp)

    return ans

```

## 2207. Maximize Number of Subsequences in a String_2207.py

```python
class Solution:
  def maximumSubsequenceCount(self, text: str, pattern: str) -> int:
    ans = 0
    count0 = 0  # the count of the letter pattern[0]
    count1 = 0  # the count of the letter pattern[1]

    for c in text:
      if c == pattern[1]:
        ans += count0
        count1 += 1
      if c == pattern[0]:
        count0 += 1

    # It is optimal to add pattern[0] at the beginning or add pattern[1] at the
    # end of the text.
    return ans + max(count0, count1)

```

## 1367. Linked List in Binary Tree_1367.py

```python
class Solution:
  def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:
    if not root:
      return False
    return self._isContinuousSubPath(head, root) or \
        self.isSubPath(head, root.left) or \
        self.isSubPath(head, root.right)

  def _isContinuousSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:
    if not head:
      return True
    if not root:
      return False
    return head.val == root.val and \
        (self._isContinuousSubPath(head.next, root.left)
         or self._isContinuousSubPath(head.next, root.right))

```

## 2734. Lexicographically Smallest String After Substring Operation_2734.py

```python
class Solution:
  def smallestString(self, s: str) -> str:
    chars = list(s)
    n = len(s)
    i = 0

    while i < n and chars[i] == 'a':
      i += 1
    if i == n:
      chars[-1] = 'z'
      return ''.join(chars)

    while i < n and s[i] != 'a':
      chars[i] = chr(ord(chars[i]) - 1)
      i += 1

    return ''.join(chars)

```

## 415. Add Strings_415.py

```python
class Solution:
  def addStrings(self, num1: str, num2: str) -> str:
    ans = []
    carry = 0
    i = len(num1) - 1
    j = len(num2) - 1

    while i >= 0 or j >= 0 or carry:
      if i >= 0:
        carry += int(num1[i])
      if j >= 0:
        carry += int(num2[j])
      ans.append(str(carry % 10))
      carry //= 10
      i -= 1
      j -= 1

    return ''.join(reversed(ans))

```

## 1864. Minimum Number of Swaps to Make the Binary String Alternating_1864.py

```python
class Solution:
  def minSwaps(self, s: str) -> int:
    ones = s.count('1')
    zeros = len(s) - ones
    if abs(ones - zeros) > 1:
      return -1

    def countSwaps(curr: str) -> int:
      swaps = 0
      for c in s:
        if c != curr:
          swaps += 1
        curr = chr(ord(curr) ^ 1)
      return swaps // 2

    if ones > zeros:
      return countSwaps('1')
    if zeros > ones:
      return countSwaps('0')
    return min(countSwaps('1'), countSwaps('0'))

```

## 3001. Minimum Moves to Capture The Queen_3001.py

```python
class Solution:
  def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:
    # The rook is in the same row as the queen.
    if a == e:
      # The bishop blocks the rook or not.
      return 2 if c == a and (b < d < f or b > d > f) else 1
    # The rook is in the same column as the queen.
    if b == f:
      # The bishop blocks the rook or not.
      return 2 if d == f and (a < c < e or a > c > e) else 1
    # The bishop is in the same up-diagonal as the queen.
    if c + d == e + f:
      # The rook blocks the bishop or not.
      return 2 if a + b == c + d and (c < a < e or c > a > e) else 1
    # The bishop is in the same down-diagonal as the queen.
    if c - d == e - f:
      # The rook blocks the bishop or not.
      return 2 if a - b == c - d and (c < a < e or c > a > e) else 1
    # The rook can always get the green in two steps.
    return 2

```

## 3163. String Compression III_3163.py

```python
class Solution:
  def compressedString(self, word: str) -> str:
    n = len(word)
    ans = []
    i = 0
    j = 0

    while i < n:
      count = 0
      while j < n and word[j] == word[i] and count < 9:
        j += 1
        count += 1
      ans.append(str(count) + word[i])
      i = j

    return ''.join(ans)

```

## 599. Minimum Index Sum of Two Lists_599.py

```python
class Solution:
  def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
    ans = []
    restaurantToIndex = {restaurant: i for i,
                         restaurant in enumerate(list1)}
    minSum = math.inf

    for i, restaurant in enumerate(list2):
      if restaurant in restaurantToIndex:
        summ = restaurantToIndex[restaurant] + i
        if summ < minSum:
          ans.clear()
        if summ <= minSum:
          ans.append(restaurant)
          minSum = summ

    return ans

```

## 3133. Minimum Array End_3133.py

```python
class Solution:
  def minEnd(self, n: int, x: int) -> int:
    # Set x's 0s with (n - 1)'s LSb-to-MSb bits, preserving x's 1s. This
    # operation increase x for (n - 1) iterations while preserving x's 1s.
    kMaxBit = n.bit_length() + x.bit_length()
    k = n - 1
    kBinaryIndex = 0

    for i in range(kMaxBit):
      if x >> i & 1 == 0:
        # Set x's 0 with k's bit if the running bit of k is 1.
        if k >> kBinaryIndex & 1:
          x |= 1 << i
        kBinaryIndex += 1

    return x

```

## 1590. Make Sum Divisible by P_1590.py

```python
class Solution:
  def minSubarray(self, nums: List[int], p: int) -> int:
    summ = sum(nums)
    remainder = summ % p
    if remainder == 0:
      return 0

    ans = len(nums)
    prefix = 0
    prefixToIndex = {0: -1}

    for i, num in enumerate(nums):
      prefix += num
      prefix %= p
      target = (prefix - remainder + p) % p
      if target in prefixToIndex:
        ans = min(ans, i - prefixToIndex[target])
      prefixToIndex[prefix] = i

    return -1 if ans == len(nums) else ans

```

## 3026. Maximum Good Subarray Sum_3026.py

```python
class Solution:
  def maximumSubarraySum(self, nums: List[int], k: int) -> int:
    ans = -math.inf
    prefix = 0
    numToMinPrefix = {}

    for num in nums:
      if num not in numToMinPrefix or numToMinPrefix[num] > prefix:
        numToMinPrefix[num] = prefix
      prefix += num
      if num + k in numToMinPrefix:
        ans = max(ans, prefix - numToMinPrefix[num + k])
      if num - k in numToMinPrefix:
        ans = max(ans, prefix - numToMinPrefix[num - k])

    return 0 if ans == -math.inf else ans

```

## 2799. Count Complete Subarrays in an Array_2799.py

```python
class Solution:
  def countCompleteSubarrays(self, nums: List[int]) -> int:
    ans = 0
    distinct = len(set(nums))
    count = collections.Counter()

    l = 0
    for num in nums:
      count[num] += 1
      while len(count) == distinct:
        count[nums[l]] -= 1
        if count[nums[l]] == 0:
          del count[nums[l]]
        l += 1
      # Assume nums[r] = num,
      # nums[0..r], nums[1..r], ..., nums[l - 1..r] have k different values.
      ans += l

    return ans

```

## 230. Kth Smallest Element in a BST_230-2.py

```python
class Solution:
  def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
    rank = 0
    ans = 0

    def traverse(root: Optional[TreeNode]) -> None:
      nonlocal rank
      nonlocal ans
      if not root:
        return

      traverse(root.left)
      rank += 1
      if rank == k:
        ans = root.val
        return
      traverse(root.right)

    traverse(root)
    return ans

```

## 2765. Longest Alternating Subarray_2765.py

```python
class Solution:
  def alternatingSubarray(self, nums: List[int]) -> int:
    ans = 1
    dp = 1

    for i in range(1, len(nums)):
      targetDiff = -1 if dp % 2 == 0 else 1
      # Append nums[i] to the current alternating subarray.
      if nums[i] - nums[i - 1] == targetDiff:
        dp += 1
      # Reset the alternating subarray to nums[i - 1..i].
      elif nums[i] - nums[i - 1] == 1:
        dp = 2
      # Reset the alternating subarray to nums[i].
      else:
        dp = 1
      ans = max(ans, dp)

    return -1 if ans == 1 else ans

```

## 1171. Remove Zero Sum Consecutive Nodes from Linked List_1171.py

```python
class Solution:
  def removeZeroSumSublists(self, head: ListNode) -> ListNode:
    dummy = ListNode(0, head)
    prefix = 0
    prefixToNode = {0: dummy}

    while head:
      prefix += head.val
      prefixToNode[prefix] = head
      head = head.next

    prefix = 0
    head = dummy

    while head:
      prefix += head.val
      head.next = prefixToNode[prefix].next
      head = head.next

    return dummy.next

```

## 414. Third Maximum Number_414.py

```python
class Solution:
  def thirdMax(self, nums: List[int]) -> int:
    max1 = -math.inf  # the maximum
    max2 = -math.inf  # the second maximum
    max3 = -math.inf  # the third maximum

    for num in nums:
      if num > max1:
        max3 = max2
        max2 = max1
        max1 = num
      elif max1 > num and num > max2:
        max3 = max2
        max2 = num
      elif max2 > num and num > max3:
        max3 = num

    return max1 if max3 == -math.inf else max3

```

## 2969. Minimum Number of Coins for Fruits II_2969-2.py

```python
class Solution:
  # Same as 2944. Minimum Number of Coins for Fruits
  def minimumCoins(self, prices: List[int]) -> int:
    n = len(prices)
    # Stores (dp[i], i), where dp[i] is the minimum number of coins to acquire
    # fruits[i:] (0-indexed).
    minHeap = [(0, n)]
    ans = 0

    for i in range(n - 1, -1, -1):
      while minHeap and minHeap[0][1] > (i + 1) * 2:
        heapq.heappop(minHeap)
      ans = prices[i] + minHeap[0][0]
      heapq.heappush(minHeap, (ans, i))

    return ans

```

## 2398. Maximum Number of Robots Within Budget_2398.py

```python
class Solution:
  def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:
    cost = 0
    maxQ = collections.deque()  # Stores `chargeTimes[i]`.

    j = 0  # window's range := [i..j], so k = i - j + 1
    for i, (chargeTime, runningCost) in enumerate(zip(chargeTimes, runningCosts)):
      cost += runningCost
      while maxQ and maxQ[-1] < chargeTime:
        maxQ.pop()
      maxQ.append(chargeTime)
      if maxQ[0] + (i - j + 1) * cost > budget:
        if maxQ[0] == chargeTimes[j]:
          maxQ.popleft()
        cost -= runningCosts[j]
        j += 1

    return len(chargeTimes) - j

```

## 1770. Maximum Score from Performing Multiplication Operations_1770.py

```python
class Solution:
  def maximumScore(self, nums: List[int], multipliers: List[int]) -> int:
    @functools.lru_cache(2000)
    def dp(s: int, i: int) -> int:
      """Returns the maximum score of nums[s..e] and multipliers[i]."""
      if i == len(multipliers):
        return 0

      # The number of nums picked on the start side is s.
      # The number of nums picked on the end side is i - s.
      # So, e = n - (i - s) - 1.
      e = len(nums) - (i - s) - 1
      pickStart = nums[s] * multipliers[i] + dp(s + 1, i + 1)
      pickEnd = nums[e] * multipliers[i] + dp(s, i + 1)
      return max(pickStart, pickEnd)

    return dp(0, 0)

```

## 2313. Minimum Flips in Binary Tree to Get Result_2313.py

```python
class Solution:
  def minimumFlips(self, root: Optional[TreeNode], result: bool) -> int:
    @functools.lru_cache(None)
    def dp(root: Optional[TreeNode], target: bool) -> int:
      """Returns the minimum flips to make the subtree root become target."""
      if root.val in (0, 1):  # the leaf
        return 0 if root.val == target else 1
      if root.val == 5:  # NOT
        return dp(root.left or root.right, not target)
      if root.val == 2:  # OR
        nextTargets = [(0, 1), (1, 0), (1, 1)] if target else [[0, 0]]
      elif root.val == 3:  # AND
        nextTargets = [(1, 1)] if target else [(0, 0), (0, 1), (1, 0)]
      else:  # root.val == 4 XOR
        nextTargets = [(0, 1), (1, 0)] if target else [(0, 0), (1, 1)]
      return min(dp(root.left, leftTarget) + dp(root.right, rightTarget)
                 for leftTarget, rightTarget in nextTargets)

    return dp(root, result)

```

## 939. Minimum Area Rectangle_939.py

```python
class Solution:
  def minAreaRect(self, points: List[List[int]]) -> int:
    ans = math.inf
    xToYs = collections.defaultdict(set)

    for x, y in points:
      xToYs[x].add(y)

    for i in range(len(points)):
      for j in range(i):
        x1, y1 = points[i]
        x2, y2 = points[j]
        if x1 == x2 or y1 == y2:
          continue
        if y2 in xToYs[x1] and y1 in xToYs[x2]:
          ans = min(ans, abs(x1 - x2) * abs(y1 - y2))

    return ans if ans < math.inf else 0

```

## 2506. Count Pairs Of Similar Strings_2506.py

```python
class Solution:
  def similarPairs(self, words: List[str]) -> int:
    ans = 0

    def getMask(word: str) -> int:
      mask = 0
      for c in word:
        mask |= 1 << ord(c) - ord('a')
      return mask

    masks = [getMask(word) for word in words]

    for i in range(len(masks)):
      for j in range(i + 1, len(masks)):
        if masks[i] == masks[j]:
          ans += 1

    return ans

```

## 1452. People Whose List of Favorite Companies Is Not a Subset of Another List_1452.py

```python
class Solution:
  def peopleIndexes(self, favoriteCompanies: List[List[str]]) -> List[int]:
    ans = []
    n = len(favoriteCompanies)
    companies = [set(comp) for comp in favoriteCompanies]

    for i in range(n):
      find = False
      for j in range(n):
        if i == j:
          continue
        if companies[i].issubset(companies[j]):
          find = True
          break
      if not find:
        ans.append(i)

    return ans

```

## 873. Length of Longest Fibonacci Subsequence_873.py

```python
class Solution:
  def lenLongestFibSubseq(self, arr: List[int]) -> int:
    n = len(arr)
    ans = 0
    numToIndex = {a: i for i, a in enumerate(arr)}
    dp = [[2] * n for _ in range(n)]

    for j in range(n):
      for k in range(j + 1, n):
        ai = arr[k] - arr[j]
        if ai < arr[j] and ai in numToIndex:
          i = numToIndex[ai]
          dp[j][k] = dp[i][j] + 1
          ans = max(ans, dp[j][k])

    return ans

```

## 2564. Substring XOR Queries_2564.py

```python
class Solution:
  def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:
    kMaxBit = 30
    # {val: [left, right]} := s[left..right]'s decimal value = val
    valToLeftAndRight = collections.defaultdict(lambda: [-1, -1])

    for left, c in enumerate(s):
      val = 0
      if c == '0':
        # edge case: Save the index of the first 0.
        if 0 not in valToLeftAndRight:
          valToLeftAndRight[0] = [left, left]
        continue
      for right in range(left, min(len(s), left + kMaxBit)):
        val = val * 2 + int(s[right])
        if val not in valToLeftAndRight:
          valToLeftAndRight[val] = [left, right]

    return [valToLeftAndRight[first, right]
            for first, right in queries]

```

## 145. Binary Tree Postorder Traversal_145-2.py

```python
class Solution:
  def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
    if not root:
      return []

    ans = []
    stack = [root]

    while stack:
      node = stack.pop()
      ans.append(node.val)
      if node.left:
        stack.append(node.left)
      if node.right:
        stack.append(node.right)

    return ans[::-1]

```

## 1425. Constrained Subsequence Sum_1425.py

```python
class Solution:
  def constrainedSubsetSum(self, nums: List[int], k: int) -> int:
    # dp[i] := the maximum the sum of non-empty subsequences in nums[0..i]
    dp = [0] * len(nums)
    # dq stores dp[i - k], dp[i - k + 1], ..., dp[i - 1] whose values are > 0
    # in decreasing order.
    dq = collections.deque()

    for i, num in enumerate(nums):
      if dq:
        dp[i] = max(dq[0], 0) + num
      else:
        dp[i] = num
      while dq and dq[-1] < dp[i]:
        dq.pop()
      dq.append(dp[i])
      if i >= k and dp[i - k] == dq[0]:
        dq.popleft()

    return max(dp)

```

## 2345. Finding the Number of Visible Mountains_2345.py

```python
class Solution:
  def visibleMountains(self, peaks: List[List[int]]) -> int:
    count = collections.Counter((x, y) for x, y in peaks)
    peaks = sorted([k for k, v in count.items() if v == 1])
    stack = []

    # Returns True if `peak1` is hidden by `peak2`
    def isHidden(peak1: List[int], peak2: List[int]) -> bool:
      x1, y1 = peak1
      x2, y2 = peak2
      return x1 - y1 >= x2 - y2 and x1 + y1 <= x2 + y2

    for i, peak in enumerate(peaks):
      while stack and isHidden(peaks[stack[-1]], peak):
        stack.pop()
      if stack and isHidden(peak, peaks[stack[-1]]):
        continue
      stack.append(i)

    return len(stack)

```

## 357. Count Numbers with Unique Digits_357.py

```python
class Solution:
  def countNumbersWithUniqueDigits(self, n: int) -> int:
    if n == 0:
      return 1

    ans = 10
    uniqueDigits = 9
    availableNum = 9

    while n > 1 and availableNum > 0:
      uniqueDigits *= availableNum
      ans += uniqueDigits
      n -= 1
      availableNum -= 1

    return ans

```

## 3167. Better Compression of String_3167.py

```python
class Solution:
  def betterCompression(self, compressed: str) -> str:
    count = collections.Counter()
    i = 0

    while i < len(compressed):
      c = compressed[i]
      i += 1
      freq = 0
      while i < len(compressed) and compressed[i].isdigit():
        freq = freq * 10 + int(compressed[i])
        i += 1
      count[c] += freq

    return ''.join([c + str(count[c])
                    for c in sorted(count.keys())])

```

## 1366. Rank Teams by Votes_1366.py

```python
class Team:
  def __init__(self, name: str, teamSize: int):
    self.name = name
    self.rank = [0] * teamSize


class Solution:
  def rankTeams(self, votes: List[str]) -> str:
    teamSize = len(votes[0])
    teams = [Team(chr(ord('A') + i), teamSize) for i in range(26)]

    for vote in votes:
      for i in range(teamSize):
        teams[ord(vote[i]) - ord('A')].rank[i] += 1

    teams.sort(key=lambda x: (x.rank, -ord(x.name)), reverse=True)
    return ''.join(team.name for team in teams[:teamSize])

```

## 2585. Number of Ways to Earn Points_2585.py

```python
class Solution:
  def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:
    kMod = 1_000_000_007
    # dp[i][j] := the number of ways to earn j points with the first i types
    dp = [[0] * (target + 1) for _ in range(len(types) + 1)]
    dp[0][0] = 1

    for i in range(1, len(types) + 1):
      count = types[i - 1][0]
      mark = types[i - 1][1]
      for j in range(target + 1):
        for solved in range(count + 1):
          if j - solved * mark >= 0:
            dp[i][j] += dp[i - 1][j - solved * mark]
            dp[i][j] %= kMod

    return dp[len(types)][target]

```

## 1036. Escape a Large Maze_1036.py

```python
class Solution:
  def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:
    def dfs(i: int, j: int, target: List[int], visited: set) -> bool:
      if not 0 <= i < 10**6 or not 0 <= j < 10**6 or (i, j) in blocked or (i, j) in visited:
        return False

      visited.add((i, j))
      if len(visited) > (1 + 199) * 199 // 2 or [i, j] == target:
        return True
      return dfs(i + 1, j, target, visited) or \
          dfs(i - 1, j, target, visited) or \
          dfs(i, j + 1, target, visited) or \
          dfs(i, j - 1, target, visited)

    blocked = set(tuple(b) for b in blocked)
    return dfs(source[0], source[1], target, set()) and dfs(target[0], target[1], source, set())

```

## 2589. Minimum Time to Complete All Tasks_2589.py

```python
class Solution:
  def findMinimumTime(self, tasks: List[List[int]]) -> int:
    kMax = 2000
    running = [False] * (kMax + 1)

    # Sort tasks by end.
    for start, end, duration in sorted(tasks, key=lambda x: x[1]):
      neededDuration = duration - \
          sum(running[i] for i in range(start, end + 1))
      # Greedily run the task as late as possible so that later tasks can run
      # simultaneously.
      i = end
      while neededDuration > 0:
        if not running[i]:
          running[i] = True
          neededDuration -= 1
        i -= 1

    return sum(running)

```

## 3141. Maximum Hamming Distances_3141.py

```python
class Solution:
  def maxHammingDistances(self, nums: List[int], m: int) -> List[int]:
    kMaxMask = 1 << m
    # dp[i] := the maximum hamming distance from i to any number in `nums`
    dp = [-math.inf] * kMaxMask

    for num in nums:
      dp[num] = 0

    for bit in range(m):
      newDp = [0] * kMaxMask
      for mask in range(kMaxMask):
        newDp[mask] = max(dp[mask], dp[mask ^ (1 << bit)] + 1)
      dp = newDp

    return [dp[num] for num in nums]

```

## 287. Find the Duplicate Number_287.py

```python
class Solution:
  def findDuplicate(self, nums: List[int]) -> int:
    slow = nums[nums[0]]
    fast = nums[nums[nums[0]]]

    while slow != fast:
      slow = nums[slow]
      fast = nums[nums[fast]]

    slow = nums[0]

    while slow != fast:
      slow = nums[slow]
      fast = nums[fast]

    return slow

```

## 1824. Minimum Sideway Jumps_1824.py

```python
class Solution:
  def minSideJumps(self, obstacles: List[int]) -> int:
    kInf = 1e6
    # dp[i] := the minimum jump to reach the i-th lane
    dp = [kInf, 1, 0, 1]

    for obstacle in obstacles:
      print(dp)
      if obstacle > 0:
        dp[obstacle] = kInf
      for i in range(1, 4):  # the current
        if i != obstacle:
          for j in range(1, 4):  # the previous
            dp[i] = min(dp[i], dp[j] + (0 if i == j else 1))

    return min(dp)

```

## 1291. Sequential Digits_1291.py

```python
class Solution:
  def sequentialDigits(self, low: int, high: int) -> List[int]:
    ans = []
    q = collections.deque([num for num in range(1, 10)])

    while q:
      num = q.popleft()
      if num > high:
        return ans
      if low <= num and num <= high:
        ans.append(num)
      lastDigit = num % 10
      if lastDigit < 9:
        q.append(num * 10 + lastDigit + 1)

    return ans

```

## 735. Asteroid Collision_735.py

```python
class Solution:
  def asteroidCollision(self, asteroids: List[int]) -> List[int]:
    stack = []

    for a in asteroids:
      if a > 0:
        stack.append(a)
      else:  # a < 0
        # Destroy the previous positive one(s).
        while stack and stack[-1] > 0 and stack[-1] < -a:
          stack.pop()
        if not stack or stack[-1] < 0:
          stack.append(a)
        elif stack[-1] == -a:
          stack.pop()  # Both asteroids explode.
        else:  # stack[-1] > the current asteroid.
          pass  # Destroy the current asteroid, so do nothing.

    return stack

```

## 1051. Height Checker_1051.py

```python
class Solution:
  def heightChecker(self, heights: List[int]) -> int:
    ans = 0
    currentHeight = 1
    count = [0] * 101

    for height in heights:
      count[height] += 1

    for height in heights:
      while count[currentHeight] == 0:
        currentHeight += 1
      if height != currentHeight:
        ans += 1
      count[currentHeight] -= 1

    return ans

```

## 2181. Merge Nodes in Between Zeros_2181-2.py

```python
class Solution:
  def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:
    curr = head.next

    while curr:
      running = curr
      summ = 0
      while running.val:
        summ += running.val
        running = running.next

      curr.val = summ
      curr.next = running.next
      curr = running.next

    return head.next

```

## 2638. Count the Number of K-Free Subsets_2638.py

```python
class Solution:
  def countTheNumOfKFreeSubsets(self, nums: List[int], k: int) -> int:
    modToSubset = collections.defaultdict(set)

    for num in nums:
      modToSubset[num % k].add(num)

    prevNum = -k
    skip = 0
    pick = 0

    for subset in modToSubset.values():
      for num in sorted(subset):
        skip, pick = skip + pick, \
            1 + skip + (0 if num - prevNum == k else pick)
        prevNum = num

    return 1 + skip + pick

```
