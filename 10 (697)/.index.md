## 1736. Latest Time by Replacing Hidden Digits_1736.py
```python
class Solution:
  def maximumTime(self, time: str) -> str:
    ans = list(time)
    if time[0] == '?':
      ans[0] = '2' if time[1] == '?' or time[1] < '4' else '1'
    if time[1] == '?':
      ans[1] = '3' if ans[0] == '2' else '9'
    if time[3] == '?':
      ans[3] = '5'
    if time[4] == '?':
      ans[4] = '9'
    return ''.join(ans)

```

## 2411. Smallest Subarrays With Maximum Bitwise OR_2411.py
```python
class Solution:
  def smallestSubarrays(self, nums: List[int]) -> List[int]:
    kMaxBit = 30
    ans = [1] * len(nums)
    # closest[j] := the closest index i s.t. the j-th bit of nums[i] is 1
    closest = [0] * kMaxBit

    for i in reversed(range(len(nums))):
      for j in range(kMaxBit):
        if nums[i] >> j & 1:
          closest[j] = i
        ans[i] = max(ans[i], closest[j] - i + 1)

    return ans

```

## 144. Binary Tree Preorder Traversal_144.py
```python
class Solution:
  def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
    ans = []

    def preorder(root: Optional[TreeNode]) -> None:
      if not root:
        return

      ans.append(root.val)
      preorder(root.left)
      preorder(root.right)

    preorder(root)
    return ans

```

## 1199. Minimum Time to Build Blocks_1199.py
```python
class Solution:
  def minBuildTime(self, blocks: List[int], split: int) -> int:
    minHeap = blocks.copy()
    heapify(minHeap)

    while len(minHeap) > 1:
      heapq.heappop(minHeap)  # the minimum
      x = heapq.heappop(minHeap)  # the second minimum
      heapq.heappush(minHeap, x + split)

    return minHeap[0]

```

## 1177. Can Make Palindrome from Substring_1177.py
```python
class Solution:
  def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:
    dp = [0] * (len(s) + 1)

    for i in range(1, len(s) + 1):
      dp[i] = dp[i - 1] ^ 1 << ord(s[i - 1]) - ord('a')

    return [
        (dp[right + 1] ^ dp[left]).bit_count() // 2 <= k
        for left, right, k in queries
    ]

```

## 437. Path Sum III_437.py
```python
class Solution:
  def pathSum(self, root: TreeNode, summ: int) -> int:
    if not root:
      return 0

    def dfs(root: TreeNode, summ: int) -> int:
      if not root:
        return 0
      return (summ == root.val) + \
          dfs(root.left, summ - root.val) + \
          dfs(root.right, summ - root.val)

    return dfs(root, summ) + \
        self.pathSum(root.left, summ) + \
        self.pathSum(root.right, summ)

```

## 2023. Number of Pairs of Strings With Concatenation Equal to Target_2023.py
```python
class Solution:
  def numOfPairs(self, nums: List[str], target: str) -> int:
    ans = 0
    count = collections.Counter()

    for num in nums:
      k = len(num)
      if target[:k] == num:
        ans += count[target[k:]]
      if target[-k:] == num:
        ans += count[target[:-k]]
      count[num] += 1

    return ans

```

## 3038. Maximum Number of Operations With the Same Score I_3038.py
```python
class Solution:
  def maxOperations(self, nums: List[int]) -> int:
    ans = 1
    summ = nums[0] + nums[1]

    for i in range(2, len(nums) - 1, 2):
      if nums[i] + nums[i + 1] == summ:
        ans += 1
      else:
        break

    return ans

```

## 1781. Sum of Beauty of All Substrings_1781.py
```python
class Solution:
  def beautySum(self, s: str) -> int:
    ans = 0

    for i in range(len(s)):
      count = collections.Counter()
      for j in range(i, len(s)):
        count[s[j]] += 1
        ans += max(count.values()) - min(count.values())

    return ans

```

## 3111. Minimum Rectangles to Cover Points_3111.py
```python
class Solution:
  def minRectanglesToCoverPoints(self, points: List[List[int]], w: int) -> int:
    ans = 0
    prevX = -w - 1
    xs = sorted([x for x, _ in points])

    for x in xs:
      if x > prevX + w:
        ans += 1
        prevX = x

    return ans

```

## 2816. Double a Number Represented as a Linked List_2816-2.py
```python
class Solution:
  def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
    if head.val >= 5:
      head = ListNode(0, head)

    curr = head

    while curr:
      curr.val *= 2
      curr.val %= 10
      if curr.next and curr.next.val >= 5:
        curr.val += 1
      curr = curr.next

    return head

```

## 761. Special Binary String_761.py
```python
class Solution:
  def makeLargestSpecial(self, s: str) -> str:
    specials = []
    count = 0

    i = 0
    for j, c in enumerate(s):
      count += 1 if c == '1' else -1
      if count == 0:
        specials.append(
            '1' + self.makeLargestSpecial(s[i + 1:j]) + '0')
        i = j + 1

    return ''.join(sorted(specials)[::-1])

```

## 2566. Maximum Difference by Remapping a Digit_2566.py
```python
class Solution:
  def minMaxDifference(self, num: int) -> int:
    s = str(num)
    to9 = s[self._firstNotNineIndex(s)]
    to0 = s[0]
    return int(s.replace(to9, '9')) - int(s.replace(to0, '0'))

  def _firstNotNineIndex(self, s: str) -> int:
    for i, c in enumerate(s):
      if c != '9':
        return i
    return 0

```

## 274. H-Index_274.py
```python
class Solution:
  def hIndex(self, citations: List[int]) -> int:
    n = len(citations)
    accumulate = 0
    count = [0] * (n + 1)

    for citation in citations:
      count[min(citation, n)] += 1

    # To find the maximum h-index, loop from the back to the front.
    # i := the candidate's h-index
    for i, c in reversed(list(enumerate(count))):
      accumulate += c
      if accumulate >= i:
        return i

```

## 2894. Divisible and Non-divisible Sums Difference_2894.py
```python
class Solution:
  def differenceOfSums(self, n: int, m: int) -> int:
    summ = (1 + n) * n // 2
    num2 = self._getDivisibleSum(n, m)
    num1 = summ - num2
    return num1 - num2

  def _getDivisibleSum(self, n: int, m: int) -> int:
    """Returns the sum of all the integers in [1, n] that are divisible by m."""
    last = n // m * m
    if last == 0:
      return 0
    first = m
    count = (last - first) // m + 1
    return (first + last) * count // 2

```

## 1289. Minimum Falling Path Sum II_1289.py
```python
class Solution:
  def minFallingPathSum(self, grid: List[List[int]]) -> int:
    n = len(grid)

    for i in range(1, n):
      (firstMinNum, firstMinIndex), (secondMinNum, _) = sorted(
          {(a, i) for i, a in enumerate(grid[i - 1])})[:2]
      for j in range(n):
        if j == firstMinIndex:
          grid[i][j] += secondMinNum
        else:
          grid[i][j] += firstMinNum

    return min(grid[-1])

```

## 64. Minimum Path Sum_64.py
```python
class Solution:
  def minPathSum(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])

    for i in range(m):
      for j in range(n):
        if i > 0 and j > 0:
          grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])
        elif i > 0:
          grid[i][0] += grid[i - 1][0]
        elif j > 0:
          grid[0][j] += grid[0][j - 1]

    return grid[m - 1][n - 1]

```

## 1288. Remove Covered Intervals_1288.py
```python
class Solution:
  def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:
    ans = 0
    prevEnd = 0

    # If the two intervals have the same `start`, put the one with a larger
    # `end` first.
    for _, end in sorted(intervals, key=lambda x: (x[0], -x[1])):
      # Current interval is not covered by the previous one.
      if prevEnd < end:
        ans += 1
        prevEnd = end

    return ans

```

## 658. Find K Closest Elements_658.py
```python
class Solution:
  def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
    l = 0
    r = len(arr) - k

    while l < r:
      m = (l + r) // 2
      if x - arr[m] <= arr[m + k] - x:
        r = m
      else:
        l = m + 1

    return arr[l:l + k]

```

## 2900. Longest Unequal Adjacent Groups Subsequence I_2900.py
```python
class Solution:
  def getWordsInLongestSubsequence(self, n: int, words: List[str], groups: List[int]) -> List[str]:
    ans = []
    groupId = -1

    for word, group in zip(words, groups):
      if group != groupId:
        groupId = group
        ans.append(word)

    return ans

```

## 2009. Minimum Number of Operations to Make Array Continuous_2009.py
```python
class Solution:
  def minOperations(self, nums: List[int]) -> int:
    n = len(nums)
    ans = n
    nums = sorted(set(nums))

    for i, start in enumerate(nums):
      end = start + n - 1
      index = bisect_right(nums, end)
      uniqueLength = index - i
      ans = min(ans, n - uniqueLength)

    return ans

```

## 2094. Finding 3-Digit Even Numbers_2094.py
```python
class Solution:
  def findEvenNumbers(self, digits: List[int]) -> List[int]:
    ans = []
    count = collections.Counter(digits)

    # Try to construct `abc`.
    for a in range(1, 10):
      for b in range(0, 10):
        for c in range(0, 9, 2):
          if count[a] > 0 and count[b] > (b == a) and count[c] > (c == a) + (c == b):
            ans.append(a * 100 + b * 10 + c)

    return ans

```

## 755. Pour Water_755.py
```python
class Solution:
  def pourWater(self, heights: List[int], volume: int, k: int) -> List[int]:
    i = k

    while volume > 0:
      volume -= 1
      while i > 0 and heights[i] >= heights[i - 1]:
        i -= 1
      while i + 1 < len(heights) and heights[i] >= heights[i + 1]:
        i += 1
      while i > k and heights[i] == heights[i - 1]:
        i -= 1
      heights[i] += 1

    return heights

```

## 362. Design Hit Counter_362.py
```python
class HitCounter:
  def __init__(self):
    self.timestamps = [0] * 300
    self.hits = [0] * 300

  def hit(self, timestamp: int) -> None:
    i = timestamp % 300
    if self.timestamps[i] == timestamp:
      self.hits[i] += 1
    else:
      self.timestamps[i] = timestamp
      self.hits[i] = 1  # Reset the hit count to 1.

  def getHits(self, timestamp: int) -> int:
    return sum(h for t, h in zip(self.timestamps, self.hits) if timestamp - t < 300)

```

## 680. Valid Palindrome II_680.py
```python
class Solution:
  def validPalindrome(self, s: str) -> bool:
    def validPalindrome(l: int, r: int) -> bool:
      return all(s[i] == s[r - i + l] for i in range(l, (l + r) // 2 + 1))

    n = len(s)

    for i in range(n // 2):
      if s[i] != s[~i]:
        return validPalindrome(i + 1, n - 1 - i) or validPalindrome(i, n - 2 - i)

    return True

```

## 3085. Minimum Deletions to Make String K-Special_3085.py
```python
class Solution:
  def minimumDeletions(self, word: str, k: int) -> int:
    ans = math.inf
    count = collections.Counter(word)

    for minFreq in count.values():
      deletions = 0
      for freq in count.values():
        if freq < minFreq:
          deletions += freq
        else:
          deletions += max(0, freq - (minFreq + k))
      ans = min(ans, deletions)

    return ans

```

## 1375. Number of Times Binary String Is Prefix-Aligned_1375.py
```python
class Solution:
  def numTimesAllBlue(self, flips: List[int]) -> int:
    ans = 0
    rightmost = 0

    for i, flip in enumerate(flips):
      rightmost = max(rightmost, flip)
      # max(flips[0..i]) = rightmost = i + 1,
      # so flips[0..i] is a permutation of 1, 2, ..., i + 1.
      if rightmost == i + 1:
        ans += 1

    return ans

```

## 2358. Maximum Number of Groups Entering a Competition_2358.py
```python
class Solution:
  def maximumGroups(self, grades: List[int]) -> int:
    # Sort grades, then we can seperate the students into groups of sizes 1, 2,
    # 3, ..., k, s.t. the i-th group < the (i + 1)-th group for both sum and
    # size. So, we can rephrase the problem into:
    #   Find the maximum k s.t. 1 + 2 + 3 + ... + k <= n

    #  1 + 2 + 3 + ... + k <= n
    #         k(k + 1) // 2 <= n
    #              k^2 + k <= 2n
    #   (k + 0.5)^2 - 0.25 <= 2n
    #          (k + 0.5)^2 <= 2n + 0.25
    #                    k <= sqrt(2n + 0.25) - 0.5
    return int(math.sqrt(len(grades) * 2 + 0.25) - 0.5)

```

## 1027. Longest Arithmetic Subsequence_1027.py
```python
class Solution:
  def longestArithSeqLength(self, nums: List[int]) -> int:
    n = len(nums)
    ans = 0
    # dp[i][k] := the length of the longest arithmetic subsequence of nums[0..i]
    # with k = diff + 500
    dp = [[0] * 1001 for _ in range(n)]

    for i in range(n):
      for j in range(i):
        k = nums[i] - nums[j] + 500
        dp[i][k] = max(2, dp[j][k] + 1)
        ans = max(ans, dp[i][k])

    return ans

```

## 2001. Number of Pairs of Interchangeable Rectangles_2001-2.py
```python
class Solution:
  def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:
    ratioCount = collections.Counter()

    def gcd(a: int, b: int) -> int:
      return a if b == 0 else gcd(b, a % b)

    for width, height in rectangles:
      d = gcd(width, height)
      ratioCount[(width // d, height // d)] += 1

    return sum(c * (c - 1) // 2 for c in ratioCount.values())

```

## 2975. Maximum Square Area by Removing Fences From a Field_2975.py
```python
class Solution:
  def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:
    hFences = sorted(hFences + [1, m])
    vFences = sorted(vFences + [1, n])
    hGaps = {hFences[i] - hFences[j]
             for i in range(len(hFences))
             for j in range(i)}
    vGaps = {vFences[i] - vFences[j]
             for i in range(len(vFences))
             for j in range(i)}
    maxGap = next((hGap
                  for hGap in sorted(hGaps, reverse=True)
                  if hGap in vGaps), -1)
    return -1 if maxGap == -1 else maxGap**2 % (10**9 + 7)

```

## 42. Trapping Rain Water_42.py
```python
class Solution:
  def trap(self, height: List[int]) -> int:
    n = len(height)
    l = [0] * n  # l[i] := max(height[0..i])
    r = [0] * n  # r[i] := max(height[i..n))

    for i, h in enumerate(height):
      l[i] = h if i == 0 else max(h, l[i - 1])

    for i, h in reversed(list(enumerate(height))):
      r[i] = h if i == n - 1 else max(h, r[i + 1])

    return sum(min(l[i], r[i]) - h
               for i, h in enumerate(height))

```

## 2712. Minimum Cost to Make All Characters Equal_2712.py
```python
class Solution:
  def minimumCost(self, s: str) -> int:
    n = len(s)
    ans = 0

    for i in range(1, n):
      if s[i] != s[i - 1]:
        # Invert s[0..i - 1] or s[i..n - 1].
        ans += min(i, n - i)

    return ans

```

## 2455. Average Value of Even Numbers That Are Divisible by Three_2455.py
```python
class Solution:
  def averageValue(self, nums: List[int]) -> int:
    summ = 0
    count = 0

    for num in nums:
      if num % 6 == 0:
        summ += num
        count += 1

    return 0 if count == 0 else summ // count

```

## 1476. Subrectangle Queries_1476.py
```python
class SubrectangleQueries:
  def __init__(self, rectangle: List[List[int]]):
    self.rectangle = rectangle
    self.updates = []

  def updateSubrectangle(self, row1: int, col1: int, row2: int, col2: int, newValue: int) -> None:
    self.updates.append((row1, col1, row2, col2, newValue))

  def getValue(self, row: int, col: int) -> int:
    for r1, c1, r2, c2, v in reversed(self.updates):
      if r1 <= row <= r2 and c1 <= col <= c2:
        return v
    return self.rectangle[row][col]

```

## 870. Advantage Shuffle_870.py
```python
from sortedcontainers import SortedList


class Solution:
  def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:
    sl = SortedList(nums1)

    for i, num in enumerate(nums2):
      index = 0 if sl[-1] <= num else sl.bisect_right(num)
      nums1[i] = sl[index]
      del sl[index]

    return nums1

```

## 1750. Minimum Length of String After Deleting Similar Ends_1750.py
```python
class Solution:
  def minimumLength(self, s: str) -> int:
    i = 0
    j = len(s) - 1

    while i < j and s[i] == s[j]:
      c = s[i]
      while i <= j and s[i] == c:
        i += 1
      while i <= j and s[j] == c:
        j -= 1

    return j - i + 1

```

## 2319. Check if Matrix Is X-Matrix_2319.py
```python
class Solution:
  def checkXMatrix(self, grid: List[List[int]]) -> bool:
    n = len(grid)

    for i in range(n):
      for j in range(n):
        if i == j or i + j == n - 1:  # in diagonal
          if grid[i][j] == 0:
            return False
        elif grid[i][j]:   # not in diagonal
          return False

    return True

```

## 2167. Minimum Time to Remove All Cars Containing Illegal Goods_2167-2.py
```python
class Solution:
  def minimumTime(self, s: str) -> int:
    n = len(s)
    ans = n
    left = 0  # the minimum time to remove the illegal cars so far

    for i, c in enumerate(s):
      left = min(left + (ord(c) - ord('0')) * 2, i + 1)
      ans = min(ans, left + n - 1 - i)

    return ans

```

## 2871. Split Array Into Maximum Number of Subarrays_2871.py
```python
class Solution:
  def maxSubarrays(self, nums: List[int]) -> int:
    ans = 0
    score = 0

    for num in nums:
      score = num if score == 0 else score & num
      if score == 0:
        ans += 1

    return max(1, ans)

```

## 2317. Maximum XOR After Operations_2317.py
```python
class Solution:
  def maximumXOR(self, nums: List[int]) -> int:
    # 1. nums[i] & (nums[i] ^ x) enables you to turn 1-bit to 0-bit from
    #    nums[i] since x is arbitrary.
    # 2. The i-th bit of the XOR of all the elements is 1 if the i-th bit is 1
    #    for an odd number of elements.
    # 3. Therefore, the question is equivalent to: if you can convert any digit
    #    from 1 to 0 for any number, what is the maximum for XOR(nums[i]).
    # 4. The maximum we can get is of course to make every digit of the answer
    #    to be 1 if possible
    # 5. Therefore, OR(nums[i]) is an approach.
    return functools.reduce(operator.ior, nums)

```

## 2113. Elements in Array After Removing and Replacing Elements_2113.py
```python
class Solution:
  def elementInNums(self, nums: List[int], queries: List[List[int]]) -> List[int]:
    n = len(nums)

    def f(time: int, index: int) -> int:
      if time < n:  # [0, 1, 2] -> [1, 2] -> [2]
        index += time
        return -1 if index >= n else nums[index]
      else:  # [] -> [0] -> [0, 1]
        return -1 if index >= time - n else nums[index]

    return [f(time % (2 * n), index) for time, index in queries]

```

## 3227. Vowels Game in a String_3227.py
```python
class Solution:
  def doesAliceWin(self, s: str) -> bool:
    # Let k be the number of vowels in s.
    # 1. If k == 0, Bob wins since Alice has no vowels to pick.
    # 2. If k % 2 == 1, Alice wins since Alice can pick the entire string.
    # 3. If k % 2 == 0, Alice wins since Alice can pick (k - 1) vowels,
    # then Bob will either pick a substring containing 0 vowels, resulting in
    # Alice picking the remaining entire string, or Bob couldn't pick at all
    # (the last vowel).
    kVowels = 'aeiou'
    return any(c in kVowels for c in s)

```

## 2139. Minimum Moves to Reach Target Score_2139.py
```python
class Solution:
  def minMoves(self, target: int, maxDoubles: int) -> int:
    steps = 0

    while target > 1 and maxDoubles:
      if target % 2 == 1:
        target -= 1
      else:
        target //= 2
        maxDoubles -= 1
      steps += 1

    return steps + target - 1

```

## 1657. Determine if Two Strings Are Close_1657.py
```python
class Solution:
  def closeStrings(self, word1: str, word2: str) -> bool:
    if len(word1) != len(word2):
      return False

    count1 = collections.Counter(word1)
    count2 = collections.Counter(word2)
    if count1.keys() != count2.keys():
      return False

    return sorted(count1.values()) == sorted(count2.values())

```

## 3066. Minimum Operations to Exceed Threshold Value II_3066.py
```python
class Solution:
  def minOperations(self, nums: List[int], k: int) -> int:
    ans = 0
    minHeap = nums.copy()
    heapq.heapify(minHeap)

    while len(minHeap) > 1 and minHeap[0] < k:
      x = heapq.heappop(minHeap)
      y = heapq.heappop(minHeap)
      heapq.heappush(minHeap, min(x, y) * 2 + max(x, y))
      ans += 1

    return ans

```

## 3039. Apply Operations to Make String Empty_3039.py
```python
class Solution:
  def lastNonEmptyString(self, s: str) -> str:
    ans = []
    count = collections.Counter(s)
    maxFreq = max(count.values())

    for c in reversed(s):
      if count[c] == maxFreq:
        ans.append(c)
        count[c] -= 1

    return ''.join(reversed(ans))

```

## 1726. Tuple with Same Product_1726.py
```python
class Solution:
  def tupleSameProduct(self, nums: List[int]) -> int:
    # nums of ways to arrange (a, b) = 2
    # nums of ways to arrange (c, d) = 2
    # nums of ways to arrange (a, b), (c, d) = 2^3 = 8
    ans = 0
    count = collections.Counter()

    for i in range(len(nums)):
      for j in range(i):
        prod = nums[i] * nums[j]
        ans += count[prod] * 8
        count[prod] += 1

    return ans

```

## 1046. Last Stone Weight_1046.py
```python
class Solution:
  def lastStoneWeight(self, stones: List[int]) -> int:
    pq = [-stone for stone in stones]
    heapq.heapify(pq)

    while len(pq) >= 2:
      n1 = -heapq.heappop(pq)
      n2 = -heapq.heappop(pq)
      if n1 != n2:
        heapq.heappush(pq, -(n1 - n2))

    return 0 if not pq else -pq[0]

```

## 1792. Maximum Average Pass Ratio_1792.py
```python
class Solution:
  def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:
    def extraPassRatio(pas: int, total: int) -> float:
      """Returns the extra pass ratio if a brilliant student joins."""
      return (pas + 1) / (total + 1) - pas / total

    maxHeap = [(-extraPassRatio(pas, total), pas, total) for pas, total in classes]
    heapq.heapify(maxHeap)

    for _ in range(extraStudents):
      _, pas, total = heapq.heappop(maxHeap)
      heapq.heappush(
          maxHeap, (-extraPassRatio(pas + 1, total + 1), pas + 1, total + 1))

    return sum(pas / total for _, pas, total in maxHeap) / len(maxHeap)

```

## 3119. Maximum Number of Potholes That Can Be Fixed_3119.py
```python
class Solution:
  def maxPotholes(self, road: str, budget: int) -> int:
    ans = 0

    for length in sorted(map(len, road.split('.')), reverse=True):
      canRepair = max(0, budget - 1)
      if length > canRepair:
        return ans + canRepair
      ans += length
      budget -= length + 1

    return ans

```

## 2968. Apply Operations to Maximize Frequency Score_2968.py
```python
class Solution:
  def maxFrequencyScore(self, nums: List[int], k: int) -> int:
    nums.sort()
    ans = 0
    cost = 0

    l = 0
    for r, num in enumerate(nums):
      cost += num - nums[(l + r) // 2]
      while cost > k:
        cost -= nums[(l + r + 1) // 2] - nums[l]
        l += 1
      ans = max(ans, r - l + 1)

    return ans

```

## 32. Longest Valid Parentheses_32.py
```python
class Solution:
  def longestValidParentheses(self, s: str) -> int:
    s2 = ')' + s
    # dp[i] := the length of the longest valid parentheses in the substring
    # s2[1..i]
    dp = [0] * len(s2)

    for i in range(1, len(s2)):
      if s2[i] == ')' and s2[i - dp[i - 1] - 1] == '(':
        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2

    return max(dp)

```

## 1357. Apply Discount Every n Orders_1357.py
```python
class Cashier:
  def __init__(self, n: int, discount: int, products: List[int], prices: List[int]):
    self.n = n
    self.discount = discount
    self.productToPrice = dict(zip(products, prices))
    self.count = 0

  def getBill(self, product: List[int], amount: List[int]) -> float:
    self.count += 1
    total = sum(self.productToPrice[p] * amount[i]
                for i, p in enumerate(product))
    if self.count % self.n == 0:
      return total * (1 - self.discount / 100)
    return total

```

## 2077. Paths in Maze That Lead to Same Room_2077.py
```python
class Solution:
  def numberOfPaths(self, n: int, corridors: List[List[int]]) -> int:
    ans = 0
    graph = [[False] * 1001 for _ in range(n + 1)]

    for u, v in corridors:
      graph[u][v] = True
      graph[v][u] = True

    for u, v in corridors:
      for i in range(1, n + 1):
        if graph[u][i] and graph[i][v]:
          ans += 1

    return ans // 3

```

## 853. Car Fleet_853.py
```python
class Solution:
  def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:
    ans = 0
    times = [
        float(target - p) / s for p, s in sorted(zip(position, speed),
                                                 reverse=True)]
    maxTime = 0  # the time of the slowest car to reach the target

    for time in times:
      # A car needs more time to reach the target, so it becomes the slowest.
      if time > maxTime:
        maxTime = time
        ans += 1

    return ans

```

## 2575. Find the Divisibility Array of a String_2575.py
```python
class Solution:
  def divisibilityArray(self, word: str, m: int) -> List[int]:
    ans = []
    prevRemainder = 0

    for c in word:
      remainder = (prevRemainder * 10 + int(c)) % m
      ans.append(1 if remainder == 0 else 0)
      prevRemainder = remainder

    return ans

```

## 872. Leaf-Similar Trees_872.py
```python
class Solution:
  def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:
    def dfs(root: Optional[TreeNode]) -> None:
      if not root:
        return
      if not root.left and not root.right:
        yield root.val
        return

      yield from dfs(root.left)
      yield from dfs(root.right)

    return list(dfs(root1)) == list(dfs(root2))

```

## 108. Convert Sorted Array to Binary Search Tree_108.py
```python
class Solution:
  def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
    def build(l: int, r: int) -> Optional[TreeNode]:
      if l > r:
        return None
      m = (l + r) // 2
      return TreeNode(nums[m],
                      build(l, m - 1),
                      build(m + 1, r))

    return build(0, len(nums) - 1)

```

## 2269. Find the K-Beauty of a Number_2269.py
```python
class Solution:
  def divisorSubstrings(self, num: int, k: int) -> int:
    s = str(num)
    ans = 0

    for i in range(len(s) - k + 1):
      x = int(s[i:i + k])
      if x != 0 and num % x == 0:
        ans += 1

    return ans

```

## 2291. Maximum Profit From Trading Stocks_2291.py
```python
class Solution:
  def maximumProfit(self, present: List[int], future: List[int], budget: int) -> int:
    n = len(present)
    # dp[i][j] := the maximum profit of buying present[0..i) with j budget
    dp = [[0] * (budget + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
      profit = future[i - 1] - present[i - 1]
      for j in range(budget + 1):
        if j < present[i - 1]:
          dp[i][j] = dp[i - 1][j]
        else:
          dp[i][j] = max(dp[i - 1][j], profit + dp[i - 1][j - present[i - 1]])

    return dp[n][budget]

```

## 718. Maximum Length of Repeated Subarray_718-2.py
```python
class Solution:
  def findLength(self, nums1: List[int], nums2: List[int]) -> int:
    ans = 0
    dp = [0] * (len(nums2) + 1)

    for a in reversed(nums1):
      for j, b in enumerate(nums2):  # The order is important.
        dp[j] = dp[j + 1] + 1 if a == b else 0
        ans = max(ans, dp[j])

    return ans

```

## 1499. Max Value of Equation_1499.py
```python
class Solution:
  def findMaxValueOfEquation(self, points: List[List[int]], k: int) -> int:
    ans = -math.inf
    maxHeap = []  # (y - x, x)

    for x, y in points:
      while maxHeap and x + maxHeap[0][1] > k:
        heapq.heappop(maxHeap)
      if maxHeap:
        ans = max(ans, x + y - maxHeap[0][0])
      heapq.heappush(maxHeap, (x - y, -x))

    return ans

```

## 398. Random Pick Index_398.py
```python
class Solution:
  def __init__(self, nums: List[int]):
    self.nums = nums

  def pick(self, target: int) -> int:
    ans = -1
    rng = 0
    for i, num in enumerate(self.nums):
      if num == target:
        rng += 1
        if random.randint(0, rng - 1) == 0:
          ans = i
    return ans

```

## 624. Maximum Distance in Arrays_624-2.py
```python
class Solution:
  def maxDistance(self, arrays: List[List[int]]) -> int:
    min1, index_min1 = min((A[0], i) for i, A in enumerate(arrays))
    max1, index_max1 = max((A[-1], i) for i, A in enumerate(arrays))
    if index_min1 != index_max1:
      return max1 - min1

    min2, index_min2 = min((A[0], i)
                           for i, A in enumerate(arrays) if i != index_min1)
    max2, index_min2 = max((A[-1], i)
                           for i, A in enumerate(arrays) if i != index_max1)
    return max(max1 - min2, max2 - min1)

```

## 1521. Find a Value of a Mysterious Function Closest to Target_1521.py
```python
class Solution:
  def closestToTarget(self, arr: List[int], target: int) -> int:
    ans = math.inf
    dp = set()  # all the values of subarrays that end in the current number

    for num in arr:
      # Extend each subarray that ends in the dpious number. Due to
      # monotonicity of the AND operation, the size of `dp` will be at most
      # num.bit_count() + 1.
      dp = {num} | {val & num for val in dp}
      ans = min(ans, min(abs(target - val) for val in dp))

    return ans

```

## 861. Score After Flipping Matrix_861-2.py
```python
class Solution:
  def matrixScore(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    ans = m  # All the cells in the first column are 1.

    for j in range(1, n):
      # The best strategy is flipping the rows with a leading 0..
      onesCount = sum(grid[i][j] == grid[i][0] for i in range(m))
      ans = ans * 2 + max(onesCount, m - onesCount)

    return ans

```

## 1394. Find Lucky Integer in an Array_1394.py
```python
class Solution:
  def findLucky(self, arr: List[int]) -> int:
    count = [0] * (len(arr) + 1)

    for a in arr:
      if a <= len(arr):
        count[a] += 1

    for i in range(len(arr), 0, -1):
      if count[i] == i:
        return i

    return -1

```

## 849. Maximize Distance to Closest Person_849.py
```python
class Solution:
  def maxDistToClosest(self, seats: List[int]) -> int:
    n = len(seats)
    ans = 0
    j = -1

    for i in range(n):
      if seats[i] == 1:
        ans = i if j == -1 else max(ans, (i - j) // 2)
        j = i

    return max(ans, n - j - 1)

```

## 1234. Replace the Substring for Balanced String_1234.py
```python
class Solution:
  def balancedString(self, s: str) -> int:
    ans = len(s)
    count = collections.Counter(s)
    j = 0

    for i, c in enumerate(s):
      count[c] -= 1
      while j < len(s) and all(count[c] <= len(s) // 4 for c in 'QWER'):
        ans = min(ans, i - j + 1)
        count[s[j]] += 1
        j += 1

    return ans

```

## 1244. Design A Leaderboard_1244.py
```python
class Leaderboard:
  def __init__(self):
    self.idToScore = collections.Counter()

  def addScore(self, playerId: int, score: int) -> None:
    self.idToScore[playerId] += score

  def top(self, K: int) -> int:
    return sum(score for _, score in self.idToScore.most_common(K))

  def reset(self, playerId: int) -> None:
    del self.idToScore[playerId]

```

## 167. Two Sum II - Input array is sorted_167.py
```python
class Solution:
  def twoSum(self, numbers: List[int], target: int) -> List[int]:
    l = 0
    r = len(numbers) - 1

    while l < r:
      summ = numbers[l] + numbers[r]
      if summ == target:
        return [l + 1, r + 1]
      if summ < target:
        l += 1
      else:
        r -= 1

```

## 1167. Minimum Cost to Connect Sticks_1167.py
```python
class Solution:
  def connectSticks(self, sticks: List[int]) -> int:
    ans = 0
    heapq.heapify(sticks)

    while len(sticks) > 1:
      x = heapq.heappop(sticks)
      y = heapq.heappop(sticks)
      ans += x + y
      heapq.heappush(sticks, x + y)

    return ans

```

## 413. Arithmetic Slices_413.py
```python
class Solution:
  def numberOfArithmeticSlices(self, nums: List[int]) -> int:
    n = len(nums)
    if n < 3:
      return 0

    dp = [0] * n  # dp[i] := the number of arithmetic slices ending in index i

    for i in range(2, len(nums)):
      if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:
        dp[i] = dp[i - 1] + 1

    return sum(dp)

```

## 1209. Remove All Adjacent Duplicates in String II_1209.py
```python
class Solution:
  def removeDuplicates(self, s: str, k: int) -> str:
    stack = []

    for c in s:
      if not stack or stack[-1][0] != c:
        stack.append([c, 1])
      else:  # stack[-1][0] == c
        stack[-1][1] += 1
        if stack[-1][1] == k:
          stack.pop()

    return ''.join(c * count for c, count in stack)

```

## 797. All Paths From Source to Target_797.py
```python
class Solution:
  def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
    ans = []

    def dfs(u: int, path: List[int]) -> None:
      if u == len(graph) - 1:
        ans.append(path)
        return

      for v in graph[u]:
        dfs(v, path + [v])

    dfs(0, [0])
    return ans

```

## 3041. Maximize Consecutive Elements in an Array After Modification_3041.py
```python
class Solution:
  def maxSelectedElements(self, nums: List[int]) -> int:
    ans = 0
    # {num: the length of the longest consecutive elements ending in num}
    dp = {}

    for num in sorted(nums):
      dp[num + 1] = dp.get(num, 0) + 1
      dp[num] = dp.get(num - 1, 0) + 1
      ans = max(ans, dp[num], dp[num + 1])

    return ans

```

## 1887. Reduction Operations to Make the Array Elements Equal_1887.py
```python
class Solution:
  def reductionOperations(self, nums: List[int]) -> int:
    ans = 0

    nums.sort()

    for i in range(len(nums) - 1, 0, -1):
      if nums[i] != nums[i - 1]:
        ans += len(nums) - i

    return ans

```

## 1228. Missing Number In Arithmetic Progression_1228.py
```python
class Solution:
  def missingNumber(self, arr: List[int]) -> int:
    n = len(arr)
    delta = (arr[-1] - arr[0]) // n
    l = 0
    r = n - 1

    while l < r:
      m = (l + r) // 2
      if arr[m] == arr[0] + m * delta:
        l = m + 1
      else:
        r = m

    return arr[0] + l * delta

```

## 1985. Find the Kth Largest Integer in the Array_1985.py
```python
class Solution:
  # Similar to 215. Kth Largest Element in an Array
  def kthLargestNumber(self, nums: List[str], k: int) -> str:
    minHeap = []

    for num in nums:
      heapq.heappush(minHeap, int(num))
      if len(minHeap) > k:
        heapq.heappop(minHeap)

    return str(minHeap[0])

```

## 2559. Count Vowel Strings in Ranges_2559.py
```python
class Solution:
  def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:
    kVowels = 'aeiou'
    # prefix[i] := the number of the first i words that start with and end in a vowel
    prefix = [0] * (len(words) + 1)

    for i, word in enumerate(words):
      prefix[i + 1] += prefix[i] + (word[0] in kVowels and word[-1] in kVowels)

    return [prefix[r + 1] - prefix[l]
            for l, r in queries]

```

## 203. Remove Linked List Elements_203.py
```python
class Solution:
  def removeElements(self, head: ListNode, val: int) -> ListNode:
    dummy = ListNode(0, head)
    prev = dummy

    while head:
      if head.val != val:
        prev.next = head
        prev = prev.next
      head = head.next
    prev.next = None

    return dummy.next

```

## 696. Count Binary Substrings_696.py
```python
class Solution:
  def countBinarySubstrings(self, s: str) -> int:
    ans = 0
    prevCount = 0
    equals = 1

    for i in range(len(s) - 1):
      if s[i] == s[i + 1]:
        equals += 1
      else:
        ans += min(prevCount, equals)
        prevCount = equals
        equals = 1

    return ans + min(prevCount, equals)

```

## 2595. Number of Even and Odd Bits_2595.py
```python
class Solution:
  def evenOddBit(self, n: int) -> List[int]:
    ans = [0] * 2
    i = 0  # 0 := even, 1 := odd

    while n > 0:
      ans[i] += n & 1
      n >>= 1
      i ^= 1

    return ans

```

## 3185. Count Pairs That Form a Complete Day II_3185.py
```python
class Solution:
  # Same as 3184. Count Pairs That Form a Complete Day I
  def countCompleteDayPairs(self, hours: List[int]) -> int:
    ans = 0
    count = [0] * 24

    for hour in hours:
      ans += count[(24 - hour % 24) % 24]
      count[hour % 24] += 1

    return ans

```

## 1062. Longest Repeating Substring_1062.py
```python
class Solution:
  def longestRepeatingSubstring(self, s: str) -> int:
    n = len(s)
    ans = 0
    # dp[i][j] := the number of repeating characters of s[0..i) and s[0..j)
    dp = [[0] * (n + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
      for j in range(i + 1, n + 1):
        if s[i - 1] == s[j - 1]:
          dp[i][j] = 1 + dp[i - 1][j - 1]
          ans = max(ans, dp[i][j])

    return ans

```

## 1318. Minimum Flips to Make a OR b Equal to c_1318.py
```python
class Solution:
  def minFlips(self, a: int, b: int, c: int) -> int:
    kMaxBit = 30
    ans = 0

    for i in range(kMaxBit):
      if c >> i & 1:
        ans += (a >> i & 1) == 0 and (b >> i & 1) == 0
      else:  # (c >> i & 1) == 0
        ans += (a >> i & 1) + (b >> i & 1)

    return ans

```

## 3079. Find the Sum of Encrypted Integers_3079.py
```python
class Solution:
  def sumOfEncryptedInt(self, nums: List[int]) -> int:
    def getEncrypted(num: int) -> int:
      maxDigit = 0
      base = 0
      while num > 0:
        maxDigit = max(maxDigit, num % 10)
        base = base * 10 + 1
        num //= 10
      return base * maxDigit

    return sum(getEncrypted(num) for num in nums)

```

## 2387. Median of a Row Wise Sorted Matrix_2387.py
```python
class Solution:
  def matrixMedian(self, grid: List[List[int]]) -> int:
    noGreaterThanMedianCount = len(grid) * len(grid[0]) // 2 + 1
    l = 1
    r = int(1e6)

    while l < r:
      m = (l + r) // 2
      if sum(bisect_right(row, m) for row in grid) >= \
              noGreaterThanMedianCount:
        r = m
      else:
        l = m + 1

    return l

```

## 1860. Incremental Memory Leak_1860.py
```python
class Solution:
  def memLeak(self, memory1: int, memory2: int) -> List[int]:
    i = 1

    while memory1 >= i or memory2 >= i:
      if memory1 >= memory2:
        memory1 -= i
      else:
        memory2 -= i
      i += 1

    return [i, memory1, memory2]

```

## 300. Longest Increasing Subsequence_300.py
```python
class Solution:
  def lengthOfLIS(self, nums: List[int]) -> int:
    if not nums:
      return 0

    # dp[i] the length of LIS ending in nums[i]
    dp = [1] * len(nums)

    for i in range(1, len(nums)):
      for j in range(i):
        if nums[j] < nums[i]:
          dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)

```

## 555. Split Concatenated Strings_555.py
```python
class Solution:
  def splitLoopedString(self, strs: List[str]) -> str:
    ans = ''
    sortedStrs = [max(s, s[::-1]) for s in strs]

    for i, sortedStr in enumerate(sortedStrs):
      for s in (sortedStr, sortedStr[::-1]):
        for j in range(len(s) + 1):
          ans = max(
              ans, s[j:] + ''.join(sortedStrs[i + 1:] + sortedStrs[:i]) + s[:j])

    return ans

```

## 3121. Count the Number of Special Characters II_3121.py
```python
class Solution:
  def numberOfSpecialChars(self, word: str) -> int:
    lower = collections.defaultdict(bool)
    upper = collections.defaultdict(bool)

    for c in word:
      if c.islower():
        lower[c] = not upper[c.upper()]
      else:
        upper[c] = True

    return sum(lower[a] and upper[b]
               for a, b in zip(string.ascii_lowercase,
                               string.ascii_uppercase))

```

## 2423. Remove Letter To Equalize Frequency_2423.py
```python
class Solution:
  def equalFrequency(self, word: str) -> bool:
    count = collections.Counter(word)

    # Try to remove each letter, then check if the frequency of all the letters
    # in `word` are equal.
    for c in word:
      count[c] -= 1
      if count[c] == 0:
        del count[c]
      if min(count.values()) == max(count.values()):
        return True
      count[c] += 1

    return False

```

## 3169. Count Days Without Meetings_3169.py
```python
class Solution:
  def countDays(self, days: int, meetings: List[List[int]]) -> int:
    freeDays = 0
    prevEnd = 0

    for start, end in sorted(meetings):
      if start > prevEnd:
        freeDays += start - prevEnd - 1
      prevEnd = max(prevEnd, end)

    return freeDays + max(0, days - prevEnd)

```

## 1423. Maximum Points You Can Obtain from Cards_1423.py
```python
class Solution:
  def maxScore(self, cardPoints: List[int], k: int) -> int:
    n = len(cardPoints)
    summ = sum(cardPoints)
    windowSum = sum(cardPoints[:n - k])
    ans = summ - windowSum

    for i in range(k):
      windowSum -= cardPoints[i]
      windowSum += cardPoints[i + n - k]
      ans = max(ans, summ - windowSum)

    return ans

```

## 2944. Minimum Number of Coins for Fruits_2944-2.py
```python
class Solution:
  def minimumCoins(self, prices: List[int]) -> int:
    n = len(prices)
    # Stores (dp[i], i), where dp[i] is the minimum number of coins to acquire
    # fruits[i:] (0-indexed).
    minHeap = [(0, n)]
    ans = 0

    for i in range(n - 1, -1, -1):
      while minHeap and minHeap[0][1] > (i + 1) * 2:
        heapq.heappop(minHeap)
      ans = prices[i] + minHeap[0][0]
      heapq.heappush(minHeap, (ans, i))

    return ans

```

## 58. Length of Last Word_58.py
```python
class Solution:
  def lengthOfLastWord(self, s: str) -> int:
    i = len(s) - 1

    while i >= 0 and s[i] == ' ':
      i -= 1
    lastIndex = i
    while i >= 0 and s[i] != ' ':
      i -= 1

    return lastIndex - i

```

## 332. Reconstruct Itinerary_332.py
```python
class Solution:
  def findItinerary(self, tickets: List[List[str]]) -> List[str]:
    ans = []
    graph = collections.defaultdict(list)

    for a, b in reversed(sorted(tickets)):
      graph[a].append(b)

    def dfs(u: str) -> None:
      while u in graph and graph[u]:
        dfs(graph[u].pop())
      ans.append(u)

    dfs('JFK')
    return ans[::-1]

```

## 1910. Remove All Occurrences of a Substring_1910.py
```python
class Solution:
  def removeOccurrences(self, s: str, part: str) -> str:
    n = len(s)
    k = len(part)

    t = [' '] * n
    j = 0  # t's index

    for i, c in enumerate(s):
      t[j] = c
      j += 1
      if j >= k and ''.join(t[j - k:j]) == part:
        j -= k

    return ''.join(t[:j])

```

## 630. Course Schedule III_630.py
```python
class Solution:
  def scheduleCourse(self, courses: List[List[int]]) -> int:
    time = 0
    maxHeap = []

    for duration, lastDay in sorted(courses, key=lambda x: x[1]):
      heapq.heappush(maxHeap, -duration)
      time += duration
      # If the current course cannot be taken, check if it can be swapped with
      # a previously taken course that has a larger duration to increase the
      # time available to take upcoming courses.
      if time > lastDay:
        time += heapq.heappop(maxHeap)

    return len(maxHeap)

```

## 2735. Collecting Chocolates_2735.py
```python
class Solution:
  def minCost(self, nums: List[int], x: int) -> int:
    n = len(nums)
    ans = math.inf
    # minCost[i] := the minimum cost to collect the i-th type
    minCost = [math.inf] * n

    for rotate in range(n):
      for i in range(n):
        minCost[i] = min(minCost[i], nums[(i - rotate + n) % n])
      ans = min(ans, sum(minCost) + rotate * x)

    return ans

```

## 1922. Count Good Numbers_1922.py
```python
class Solution:
  def countGoodNumbers(self, n: int) -> int:
    kMod = 1_000_000_007

    def modPow(x: int, n: int) -> int:
      if n == 0:
        return 1
      if n % 2 == 1:
        return x * modPow(x, n - 1) % kMod
      return modPow(x * x % kMod, n // 2)

    return modPow(4 * 5, n // 2) * (1 if n % 2 == 0 else 5) % kMod

```

## 418. Sentence Screen Fitting_418.py
```python
class Solution:
  def wordsTyping(self, sentence: List[str], rows: int, cols: int) -> int:
    combined = ' '.join(sentence) + ' '
    n = len(combined)
    i = 0

    for _ in range(rows):
      i += cols
      if combined[i % n] == ' ':
        i += 1
      else:
        while i > 0 and combined[(i - 1) % n] != ' ':
          i -= 1

    return i // n

```

## 48. Rotate Image_48-2.py
```python
class Solution:
  def rotate(self, matrix: List[List[int]]) -> None:
    for mn in range(len(matrix) // 2):
      mx = len(matrix) - mn - 1
      for i in range(mn, mx):
        offset = i - mn
        top = matrix[mn][i]
        matrix[mn][i] = matrix[mx - offset][mn]
        matrix[mx - offset][mn] = matrix[mx][mx - offset]
        matrix[mx][mx - offset] = matrix[i][mx]
        matrix[i][mx] = top

```

## 3069. Distribute Elements Into Two Arrays I_3069.py
```python
class Solution:
  def resultArray(self, nums: List[int]) -> List[int]:
    arr1 = [nums[0]]
    arr2 = [nums[1]]

    for i in range(2, len(nums)):
      if arr1[-1] > arr2[-1]:
        arr1.append(nums[i])
      else:
        arr2.append(nums[i])

    return arr1 + arr2

```

## 1940. Longest Common Subsequence Between Sorted Arrays_1940.py
```python
class Solution:
  def longestCommonSubsequence(self, arrays: List[List[int]]) -> List[int]:
    kMax = 100
    ans = []
    count = [0] * (kMax + 1)

    for array in arrays:
      for a in array:
        count[a] += 1
        if count[a] == len(arrays):
          ans.append(a)

    return ans

```

## 14. Longest Common Prefix_14.py
```python
class Solution:
  def longestCommonPrefix(self, strs: List[str]) -> str:
    if not strs:
      return ''

    for i in range(len(strs[0])):
      for j in range(1, len(strs)):
        if i == len(strs[j]) or strs[j][i] != strs[0][i]:
          return strs[0][:i]

    return strs[0]

```

## 3153. Sum of Digit Differences of All Pairs_3153.py
```python
class Solution:
  def sumDigitDifferences(self, nums: List[int]) -> int:
    n = len(nums)
    digitSize = len(str(nums[0]))
    ans = 0

    denominator = 1
    for _ in range(digitSize):
      count = [0] * 10
      for num in nums:
        count[num // denominator % 10] += 1
      ans += sum(freq * (n - freq) for freq in count)
      denominator *= 10

    return ans // 2

```

## 474. Ones and Zeroes_474.py
```python
class Solution:
  def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
    # dp[i][j] := the maximum size of the subset given i 0s and j 1s are
    # available
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for s in strs:
      count0 = s.count('0')
      count1 = len(s) - count0
      for i in range(m, count0 - 1, -1):
        for j in range(n, count1 - 1, -1):
          dp[i][j] = max(dp[i][j], dp[i - count0][j - count1] + 1)

    return dp[m][n]

```

## 2211. Count Collisions on a Road_2211.py
```python
class Solution:
  def countCollisions(self, directions: str) -> int:
    l = 0
    r = len(directions) - 1

    while l < len(directions) and directions[l] == 'L':
      l += 1

    while r >= 0 and directions[r] == 'R':
      r -= 1

    return sum(c != 'S' for c in directions[l:r + 1])

```

## 116. Populating Next Right Pointers in Each Node_116.py
```python
class Solution:
  def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
    if not root:
      return None

    def connectTwoNodes(p, q) -> None:
      if not p:
        return
      p.next = q
      connectTwoNodes(p.left, p.right)
      connectTwoNodes(q.left, q.right)
      connectTwoNodes(p.right, q.left)

    connectTwoNodes(root.left, root.right)
    return root

```

## 806. Number of Lines To Write String_806.py
```python
class Solution:
  def numberOfLines(self, widths: List[int], s: str) -> List[int]:
    numLines = 1
    runningWidth = 0

    for c in s:
      width = widths[ord(c) - ord('a')]
      if runningWidth + width <= 100:
        runningWidth += width
      else:
        numLines += 1
        runningWidth = width

    return [numLines, runningWidth]

```

## 2580. Count Ways to Group Overlapping Ranges_2580.py
```python
class Solution:
  def countWays(self, ranges: List[List[int]]) -> int:
    kMod = 1_000_000_007
    ans = 1
    prevEnd = -1

    for start, end in sorted(ranges):
      if start > prevEnd:
        ans = ans * 2 % kMod
      prevEnd = max(prevEnd, end)

    return ans

```

## 1580. Put Boxes Into the Warehouse II_1580.py
```python
class Solution:
  def maxBoxesInWarehouse(self, boxes: List[int], warehouse: List[int]) -> int:
    l = 0
    r = len(warehouse) - 1

    for box in sorted(boxes, reverse=True):
      if l > r:
        return len(warehouse)
      if box <= warehouse[l]:
        l += 1
      elif box <= warehouse[r]:
        r -= 1

    return l + (len(warehouse) - r - 1)

```

## 2643. Row With Maximum Ones_2643.py
```python
class Solution:
  def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:
    ans = [0, 0]

    for i, row in enumerate(mat):
      ones = row.count(1)
      if ones > ans[1]:
        ans[0] = i
        ans[1] = ones

    return ans

```

## 2606. Find the Substring With Maximum Cost_2606.py
```python
class Solution:
  def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:
    ans = 0
    cost = 0
    costs = [i for i in range(1, 27)]  # costs[i] := the cost of 'a' + i

    for c, val in zip(chars, vals):
      costs[ord(c) - ord('a')] = val

    for c in s:
      cost = max(0, cost + costs[ord(c) - ord('a')])
      ans = max(ans, cost)

    return ans

```

## 1746. Maximum Subarray Sum After One Operation_1746.py
```python
class Solution:
  def maxSumAfterOperation(self, nums: List[int]) -> int:
    ans = -math.inf
    regular = 0
    squared = 0

    for num in nums:
      squared = max(num**2, regular + num**2, squared + num)
      regular = max(num, regular + num)
      ans = max(ans, squared)

    return ans

```

## 3170. Lexicographically Minimum String After Removing Stars_3170.py
```python
class Solution:
  def clearStars(self, s: str) -> str:
    ans = list(s)
    buckets = [[] for _ in range(26)]

    for i, c in enumerate(s):
      if c == '*':
        ans[i] = ''
        j = next(j for j, bucket in enumerate(buckets) if bucket)
        ans[buckets[j].pop()] = ''
      else:
        buckets[ord(c) - ord('a')].append(i)

    return ''.join(ans)

```

## 3. Longest Substring Without Repeating Characters_3.py
```python
class Solution:
  def lengthOfLongestSubstring(self, s: str) -> int:
    ans = 0
    count = collections.Counter()

    l = 0
    for r, c in enumerate(s):
      count[c] += 1
      while count[c] > 1:
        count[s[l]] -= 1
        l += 1
      ans = max(ans, r - l + 1)

    return ans

```

## 2515. Shortest Distance to Target String in a Circular Array_2515.py
```python
class Solution:
  def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:
    n = len(words)

    for i in range(n):
      if words[(startIndex + i + n) % n] == target:
        return i
      if words[(startIndex - i + n) % n] == target:
        return i

    return -1

```

## 1742. Maximum Number of Balls in a Box_1742.py
```python
class Solution:
  def countBalls(self, lowLimit: int, highLimit: int) -> int:
    maxDigitSum = 9 * 5  # 99999
    ans = 0
    count = [0] * (maxDigitSum + 1)

    for num in range(lowLimit, highLimit + 1):
      digitSum = self._getDigitSum(num)
      count[digitSum] += 1
      ans = max(ans, count[digitSum])

    return ans

  def _getDigitSum(self, num: int) -> int:
    return sum(int(digit) for digit in str(num))

```

## 900. RLE Iterator_900.py
```python
class RLEIterator:
  def __init__(self, encoding: List[int]):
    self.encoding = encoding
    self.index = 0

  def next(self, n: int) -> int:
    while self.index < len(self.encoding) and self.encoding[self.index] < n:
      n -= self.encoding[self.index]
      self.index += 2

    if self.index == len(self.encoding):
      return -1

    self.encoding[self.index] -= n
    return self.encoding[self.index + 1]

```

## 812. Largest Triangle Area_812.py
```python
class Solution:
  def largestTriangleArea(self, points: List[List[int]]) -> float:
    ans = 0

    for Ax, Ay in points:
      for Bx, By in points:
        for Cx, Cy in points:
          ans = max(ans, 0.5 * abs((Bx - Ax) * (Cy - Ay) -
                                   (Cx - Ax) * (By - Ay)))

    return ans

```

## 930. Binary Subarrays With Sum_930.py
```python
class Solution:
  def numSubarraysWithSum(self, nums: List[int], goal: int) -> int:
    ans = 0
    prefix = 0
    # {prefix: number of occurrence}
    count = collections.Counter({0: 1})

    for num in nums:
      prefix += num
      ans += count[prefix - goal]
      count[prefix] += 1

    return ans

```

## 1029. Two City Scheduling_1029.py
```python
class Solution:
  def twoCitySchedCost(self, costs: List[List[int]]) -> int:
    n = len(costs) // 2

    # How much money can we save if we fly a person to A instead of B?
    # To save money, we should
    #   1. Fly the person with the maximum saving to A.
    #   2. Fly the person with the minimum saving to B.

    # Sort `costs` in descending order by the money saved if we fly a person
    # to A instead of B.
    costs.sort(key=lambda x: x[0] - x[1])
    return sum(costs[i][0] + costs[i + n][1] for i in range(n))

```

## 209. Minimum Size Subarray Sum_209.py
```python
class Solution:
  def minSubArrayLen(self, s: int, nums: List[int]) -> int:
    ans = math.inf
    summ = 0
    j = 0

    for i, num in enumerate(nums):
      summ += num
      while summ >= s:
        ans = min(ans, i - j + 1)
        summ -= nums[j]
        j += 1

    return ans if ans != math.inf else 0

```

## 724. Find Pivot Index_724.py
```python
class Solution:
  def pivotIndex(self, nums: List[int]) -> int:
    summ = sum(nums)
    prefix = 0

    for i, num in enumerate(nums):
      if prefix == summ - prefix - num:
        return i
      prefix += num

    return -1

```

## 931. Minimum Falling Path Sum_931.py
```python
class Solution:
  def minFallingPathSum(self, A: List[List[int]]) -> int:
    n = len(A)

    for i in range(1, n):
      for j in range(n):
        mn = math.inf
        for k in range(max(0, j - 1), min(n, j + 2)):
          mn = min(mn, A[i - 1][k])
        A[i][j] += mn

    return min(A[-1])

```

## 1759. Count Number of Homogenous Substrings_1759.py
```python
class Solution:
  def countHomogenous(self, s: str) -> int:
    kMod = 1_000_000_007
    ans = 0
    count = 0
    currentChar = '@'

    for c in s:
      count = count + 1 if c == currentChar else 1
      currentChar = c
      ans += count
      ans %= kMod

    return ans

```

## 2111. Minimum Operations to Make the Array K-Increasing_2111.py
```python
class Solution:
  def kIncreasing(self, arr: List[int], k: int) -> int:
    def numReplaced(A: List[int]) -> int:
      tail = []
      for a in A:
        if not tail or tail[-1] <= a:
          tail.append(a)
        else:
          tail[bisect_right(tail, a)] = a
      return len(A) - len(tail)

    return sum(numReplaced(arr[i::k]) for i in range(k))

```

## 3228. Maximum Number of Operations to Move Ones to the End_3228.py
```python
class Solution:
  def maxOperations(self, s: str) -> int:
    ans = 0
    ones = 0

    for i, c in enumerate(s):
      if c == '1':
        ones += 1
      elif i + 1 == len(s) or s[i + 1] == '1':
        ans += ones

    return ans

```

## 1872. Stone Game VIII_1872.py
```python
class Solution:
  def stoneGameVIII(self, stones: List[int]) -> int:
    n = len(stones)
    prefix = list(itertools.accumulate(stones))
    # dp[i] := the maximum score difference the current player can get when the
    # game starts at i, i.e. stones[0..i] are merged into the value prefix[i]
    dp = [-math.inf] * n

    # Must take all when there're only two stones left.
    dp[n - 2] = prefix[-1]

    for i in reversed(range(n - 2)):
      dp[i] = max(dp[i + 1], prefix[i + 1] - dp[i + 1])

    return dp[0]

```

## 1137. N-th Tribonacci Number_1137.py
```python
class Solution:
  def tribonacci(self, n: int) -> int:
    if n < 2:
      return n

    dp = [0, 1, 1]

    for _ in range(3, n + 1):
      dp[0], dp[1], dp[2] = dp[1], dp[2], sum(dp)

    return dp[2]

```

## 139. Word Break_139.py
```python
class Solution:
  def wordBreak(self, s: str, wordDict: List[str]) -> bool:
    wordSet = set(wordDict)

    @functools.lru_cache(None)
    def wordBreak(s: str) -> bool:
      """Returns True if s can be segmented."""
      if s in wordSet:
        return True
      return any(s[:i] in wordSet and wordBreak(s[i:]) for i in range(len(s)))

    return wordBreak(s)

```

## 1946. Largest Number After Mutating Substring_1946.py
```python
class Solution:
  def maximumNumber(self, num: str, change: List[int]) -> str:
    numList = list(num)
    mutated = False

    for i, c in enumerate(numList):
      d = int(c)
      numList[i] = chr(ord('0') + max(d, change[d]))
      if mutated and d > change[d]:
        return ''.join(numList)
      if d < change[d]:
        mutated = True

    return ''.join(numList)

```

## 2855. Minimum Right Shifts to Sort the Array_2855.py
```python
class Solution:
  def minimumRightShifts(self, nums: List[int]) -> int:
    count = 0

    for i, (a, b) in enumerate(itertools.pairwise(nums)):
      if a > b:
        count += 1
        pivot = i

    if count == 0:
      return 0
    if count > 1 or nums[-1] > nums[0]:
      return -1
    return len(nums) - pivot - 1

```

## 2845. Count of Interesting Subarrays_2845.py
```python
class Solution:
  def countInterestingSubarrays(self, nums: List[int], modulo: int, k: int) -> int:
    ans = 0
    prefix = 0  # (number of nums[i] % modulo == k so far) % modulo
    prefixCount = collections.Counter({0: 1})

    for num in nums:
      if num % modulo == k:
        prefix = (prefix + 1) % modulo
      ans += prefixCount[(prefix - k + modulo) % modulo]
      prefixCount[prefix] += 1

    return ans

```

## 2779. Maximum Beauty of an Array After Applying Operation_2779-2.py
```python
class Solution:
  def maximumBeauty(self, nums: List[int], k: int) -> int:
    nums.sort()

    # l and r track the maximum window instead of the valid window.
    l = 0
    for r in range(len(nums)):
      if nums[r] - nums[l] > 2 * k:
        l += 1

    return r - l + 1

```

## 1665. Minimum Initial Energy to Finish Tasks_1665.py
```python
class Solution:
  def minimumEffort(self, tasks: List[List[int]]) -> int:
    ans = 0
    prevSaved = 0

    for actual, minimum in sorted(tasks, key=lambda x: x[0] - x[1]):
      if prevSaved < minimum:
        ans += minimum - prevSaved
        prevSaved = minimum - actual
      else:
        prevSaved -= actual

    return ans

```

## 145. Binary Tree Postorder Traversal_145.py
```python
class Solution:
  def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
    ans = []

    def postorder(root: Optional[TreeNode]) -> None:
      if not root:
        return

      postorder(root.left)
      postorder(root.right)
      ans.append(root.val)

    postorder(root)
    return ans

```

## 1023. Camelcase Matching_1023.py
```python
class Solution:
  def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:
    def isMatch(query: str) -> bool:
      j = 0
      for c in query:
        if j < len(pattern) and c == pattern[j]:
          j += 1
        elif c.isupper():
          return False
      return j == len(pattern)

    return [isMatch(query) for query in queries]

```

## 672. Bulb Switcher II_672.py
```python
class Solution:
  def flipLights(self, n: int, m: int) -> int:
    n = min(n, 3)

    if m == 0:
      return 1
    if m == 1:
      return [2, 3, 4][n - 1]
    if m == 2:
      return [2, 4, 7][n - 1]

    return [2, 4, 8][n - 1]

```

## 859. Buddy Strings_859.py
```python
class Solution:
  def buddyStrings(self, s: str, goal: str) -> bool:
    if len(s) != len(goal):
      return False
    if s == goal and len(set(s)) < len(s):
      return True
    diffIndices = [i for i, (a, b) in enumerate(zip(s, goal))
                   if a != b]
    return len(diffIndices) == 2 and \
        s[diffIndices[0]] == goal[diffIndices[1]] and \
        s[diffIndices[1]] == goal[diffIndices[0]]

```

## 2540. Minimum Common Value_2540.py
```python
class Solution:
  def getCommon(self, nums1: List[int], nums2: List[int]) -> int:
    i = 0  # nums1's index
    j = 0  # nums2's index

    while i < len(nums1) and j < len(nums2):
      if nums1[i] == nums2[j]:
        return nums1[i]
      if nums1[i] < nums2[j]:
        i += 1
      else:
        j += 1

    return -1

```

## 665. Non-decreasing Array_665.py
```python
class Solution:
  def checkPossibility(self, nums: List[int]) -> bool:
    j = None

    for i in range(len(nums) - 1):
      if nums[i] > nums[i + 1]:
        if j is not None:
          return False
        j = i

    return j is None or j == 0 or j == len(nums) - 2 or \
        nums[j - 1] <= nums[j + 1] or nums[j] <= nums[j + 2]

```

## 621. Task Scheduler_621.py
```python
class Solution:
  def leastInterval(self, tasks: List[str], n: int) -> int:
    count = collections.Counter(tasks)
    maxFreq = max(count.values())
    # Put the most frequent task in the slot first.
    maxFreqTaskOccupy = (maxFreq - 1) * (n + 1)
    # Get the number of tasks with same frequency as maxFreq, we'll append them after the
    # `maxFreqTaskOccupy`.
    nMaxFreq = sum(value == maxFreq for value in count.values())
    # max(
    #   the most frequent task is frequent enough to force some idle slots,
    #   the most frequent task is not frequent enough to force idle slots
    # )
    return max(maxFreqTaskOccupy + nMaxFreq, len(tasks))

```

## 1991. Find the Middle Index in Array_1991.py
```python
class Solution:
  def findMiddleIndex(self, nums: List[int]) -> int:
    prefix = 0
    suffix = sum(nums)

    for i, num in enumerate(nums):
      suffix -= num
      if prefix == suffix:
        return i
      prefix += num

    return -1

```

## 156. Binary Tree Upside Down_156.py
```python
class Solution:
  def upsideDownBinaryTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
    if not root or not root.left:
      return root

    newRoot = self.upsideDownBinaryTree(root.left)
    root.left.left = root.right  # 2's left = 3 (root's right)
    root.left.right = root  # 2's right = 1 (root)
    root.left = None
    root.right = None
    return newRoot

```

## 162. Find Peak Element_162.py
```python
class Solution:
  def findPeakElement(self, nums: List[int]) -> int:
    l = 0
    r = len(nums) - 1

    while l < r:
      m = (l + r) // 2
      if nums[m] >= nums[m + 1]:
        r = m
      else:
        l = m + 1

    return l

```

## 386. Lexicographical Numbers_386.py
```python
class Solution:
  def lexicalOrder(self, n: int) -> List[int]:
    ans = []
    curr = 1

    while len(ans) < n:
      ans.append(curr)
      if curr * 10 <= n:
        curr *= 10
      else:
        while curr % 10 == 9 or curr == n:
          curr //= 10
        curr += 1

    return ans

```

## 2482. Difference Between Ones and Zeros in Row and Column_2482.py
```python
class Solution:
  def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:
    m = len(grid)
    n = len(grid[0])
    ans = [[0] * n for _ in range(m)]
    onesRow = [row.count(1) for row in grid]
    onesCol = [col.count(1) for col in zip(*grid)]

    for i in range(m):
      for j in range(n):
        ans[i][j] = onesRow[i] + onesCol[j] - \
            (n - onesRow[i]) - (m - onesCol[j])

    return ans

```

## 335. Self Crossing_335.py
```python
class Solution:
  def isSelfCrossing(self, x: List[int]) -> bool:
    if len(x) <= 3:
      return False

    for i in range(3, len(x)):
      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:
        return True
      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:
        return True
      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:
        return True

    return False

```

## 1656. Design an Ordered Stream_1656.py
```python
class OrderedStream:
  def __init__(self, n: int):
    self.values = [''] * n
    self.i = 0  # self.values' index (0-indexed)

  def insert(self, idKey: int, value: str) -> List[str]:
    idKey -= 1  # Converts to 0-indexed.
    self.values[idKey] = value
    if idKey > self.i:
      return []
    while self.i < len(self.values) and self.values[self.i]:
      self.i += 1
    return self.values[idKey:self.i]

```

## 2655. Find Maximal Uncovered Ranges_2655.py
```python
class Solution:
  def findMaximalUncoveredRanges(self, n: int, ranges: List[List[int]]) -> List[List[int]]:
    ans = []
    start = 0

    for l, r in sorted(ranges):
      if start < l:
        ans.append([start, l - 1])
      if start <= r:
        start = r + 1

    if start < n:
      ans.append([start, n - 1])

    return ans

```

## 633. Sum of Square Numbers_633.py
```python
class Solution:
  def judgeSquareSum(self, c: int) -> bool:
    l = 0
    r = math.isqrt(c)

    while l <= r:
      summ = l * l + r * r
      if summ == c:
        return True
      if summ < c:
        l += 1
      else:
        r -= 1

    return False

```

## 1371. Find the Longest Substring Containing Vowels in Even Counts_1371.py
```python
class Solution:
  def findTheLongestSubstring(self, s: str) -> int:
    kVowels = 'aeiou'
    ans = 0
    prefix = 0  # the binary prefix
    prefixToIndex = {0: -1}

    for i, c in enumerate(s):
      index = kVowels.find(c)
      if index != -1:
        prefix ^= 1 << index
      prefixToIndex.setdefault(prefix, i)
      ans = max(ans, i - prefixToIndex[prefix])

    return ans

```

## 2399. Check Distances Between Same Letters_2399.py
```python
class Solution:
  def checkDistances(self, s: str, distance: List[int]) -> bool:
    firstSeenIndex = [-1] * 26

    for i, c in enumerate(s):
      j = ord(c) - ord('a')
      prevIndex = firstSeenIndex[j]
      if prevIndex != -1 and i - prevIndex - 1 != distance[j]:
        return False
      firstSeenIndex[j] = i

    return True

```

## 334. Increasing Triplet Subsequence_334.py
```python
class Solution:
  def increasingTriplet(self, nums: List[int]) -> bool:
    first = math.inf
    second = math.inf

    for num in nums:
      if num <= first:
        first = num
      elif num <= second:  # first < num <= second
        second = num
      else:
        return True  # first < second < num (third)

    return False

```

## 1252. Cells with Odd Values in a Matrix_1252.py
```python
class Solution:
  def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:
    # rows[i] and cols[i] :=
    #   true (flipped even times) / false (flipped odd times)
    rows = [False] * m
    cols = [False] * n

    for r, c in indices:
      rows[r] ^= True
      cols[c] ^= True

    return sum(rows[i] ^ cols[j]
               for i in range(m)
               for j in range(n))

```

## 266. Palindrome Permutation_266.py
```python
class Solution:
  def canPermutePalindrome(self, s: str) -> bool:
    seen = set()

    for c in s:
      if c in seen:
        seen.remove(c)
      else:
        seen.add(c)

    return len(seen) <= 1

```

## 377. Combination Sum IV_377.py
```python
class Solution:
  def combinationSum4(self, nums: List[int], target: int) -> int:
    dp = [1] + [-1] * target

    def dfs(target: int) -> int:
      if target < 0:
        return 0
      if dp[target] != -1:
        return dp[target]

      dp[target] = sum(dfs(target - num) for num in nums)
      return dp[target]

    return dfs(target)

```

## 13. Roman to Integer_13.py
```python
class Solution:
  def romanToInt(self, s: str) -> int:
    ans = 0
    roman = {'I': 1, 'V': 5, 'X': 10, 'L': 50,
             'C': 100, 'D': 500, 'M': 1000}

    for a, b in zip(s, s[1:]):
      if roman[a] < roman[b]:
        ans -= roman[a]
      else:
        ans += roman[a]

    return ans + roman[s[-1]]

```

## 2847. Smallest Number With Given Digit Product_2847.py
```python
class Solution:
  def smallestNumber(self, n: int) -> str:
    if n <= 9:
      return str(n)

    ans = []

    for divisor in range(9, 1, -1):
      while n % divisor == 0:
        ans.append(str(divisor))
        n //= divisor

    return '-1' if n > 1 else ''.join(reversed(ans))

```

## 1901. Find a Peak Element II_1901.py
```python
class Solution:
  def findPeakGrid(self, mat: List[List[int]]) -> List[int]:
    l = 0
    r = len(mat) - 1

    while l < r:
      m = (l + r) // 2
      if max(mat[m]) >= max(mat[m + 1]):
        r = m
      else:
        l = m + 1

    return [l, mat[l].index(max(mat[l]))]

```

## 404. Sum of Left Leaves_404.py
```python
class Solution:
  def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
    if not root:
      return 0

    ans = 0

    if root.left:
      if not root.left.left and not root.left.right:
        ans += root.left.val
      else:
        ans += self.sumOfLeftLeaves(root.left)
    ans += self.sumOfLeftLeaves(root.right)

    return ans

```

## 981. Time Based Key-Value Store_981.py
```python
class TimeMap:
  def __init__(self):
    self.values = collections.defaultdict(list)
    self.timestamps = collections.defaultdict(list)

  def set(self, key: str, value: str, timestamp: int) -> None:
    self.values[key].append(value)
    self.timestamps[key].append(timestamp)

  def get(self, key: str, timestamp: int) -> str:
    if key not in self.timestamps:
      return ''
    i = bisect.bisect(self.timestamps[key], timestamp)
    return self.values[key][i - 1] if i > 0 else ''

```

## 840. Magic Squares In Grid_840.py
```python
class Solution:
  def numMagicSquaresInside(self, grid: List[List[int]]) -> int:
    def isMagic(i: int, j: int) -> int:
      s = "".join(str(grid[i + num // 3][j + num % 3])
                  for num in [0, 1, 2, 5, 8, 7, 6, 3])
      return s in "43816729" * 2 or s in "43816729"[::-1] * 2

    ans = 0

    for i in range(len(grid) - 2):
      for j in range(len(grid[0]) - 2):
        if grid[i][j] % 2 == 0 and grid[i + 1][j + 1] == 5:
          ans += isMagic(i, j)

    return ans

```

## 255. Verify Preorder Sequence in Binary Search Tree_255-2.py
```python
class Solution:
  def verifyPreorder(self, preorder: List[int]) -> List[int]:
    low = -math.inf
    stack = []

    for p in preorder:
      if p < low:
        return False
      while stack and stack[-1] < p:
        low = stack.pop()
      stack.append(p)

    return True

```

## 877. Stone Game_877-2.py
```python
class Solution:
  def stoneGame(self, piles: List[int]) -> bool:
    n = len(piles)
    dp = piles.copy()

    for d in range(1, n):
      for j in range(n - 1, d - 1, -1):
        i = j - d
        dp[j] = max(piles[i] - dp[j], piles[j] - dp[j - 1])

    return dp[n - 1] > 0

```

## 2149. Rearrange Array Elements by Sign_2149.py
```python
class Solution:
  def rearrangeArray(self, nums: List[int]) -> List[int]:
    ans = []
    pos = []
    neg = []

    for num in nums:
      (pos if num > 0 else neg).append(num)

    for p, n in zip(pos, neg):
      ans += [p, n]

    return ans

```

## 1863. Sum of All Subset XOR Totals_1863.py
```python
class Solution:
  def subsetXORSum(self, nums: List[int]) -> int:
    def dfs(i: int, xors: int) -> int:
      if i == len(nums):
        return xors

      x = dfs(i + 1, xors)
      y = dfs(i + 1, nums[i] ^ xors)
      return x + y

    return dfs(0, 0)

```

## 1003. Check If Word Is Valid After Substitutions_1003.py
```python
class Solution:
  def isValid(self, s: str) -> bool:
    stack = []

    for c in s:
      if c == 'c':
        if len(stack) < 2 or stack[-2] != 'a' or stack[-1] != 'b':
          return False
        stack.pop()
        stack.pop()
      else:
        stack.append(c)

    return not stack

```

## 2147. Number of Ways to Divide a Long Corridor_2147.py
```python
class Solution:
  def numberOfWays(self, corridor: str) -> int:
    kMod = 1_000_000_007
    ans = 1
    prevSeat = -1
    numSeats = 0

    for i, c in enumerate(corridor):
      if c == 'S':
        numSeats += 1
        if numSeats > 2 and numSeats % 2 == 1:
          ans = ans * (i - prevSeat) % kMod
        prevSeat = i

    return ans if numSeats > 1 and numSeats % 2 == 0 else 0

```

## 2304. Minimum Path Cost in a Grid_2304.py
```python
class Solution:
  def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    # dp[i][j] := the minimum cost to reach grid[i][j]
    dp = [[math.inf] * n for _ in range(m)]
    dp[0] = grid[0]

    for i in range(1, m):
      for j in range(n):
        for k in range(n):
          dp[i][j] = min(dp[i][j], dp[i - 1][k] +
                         moveCost[grid[i - 1][k]][j] + grid[i][j])

    return min(dp[-1])

```

## 2749. Minimum Operations to Make the Integer Zero_2749.py
```python
class Solution:
  def makeTheIntegerZero(self, num1: int, num2: int) -> int:
    # If k operations are used, num1 - [(num2 + 2^{i_1}) + (num2 + 2^{i_2}) +
    # ... + (num2 + 2^{i_k})] = 0. So, num1 - k * num2 = (2^{i_1} + 2^{i_2} +
    # ... + 2^{i_k}), where i_1, i_2, ..., i_k are in the range [0, 60].
    # Note that for any number x, we can use "x's bit count" operations to make
    # x equal to 0. Additionally, we can also use x operations to deduct x by
    # 2^0 (x times), which also results in 0.

    for ops in range(61):
      target = num1 - ops * num2
      if target.bit_count() <= ops <= target:
        return ops

    return -1

```

## 2348. Number of Zero-Filled Subarrays_2348.py
```python
class Solution:
  def zeroFilledSubarray(self, nums: List[int]) -> int:
    ans = 0
    indexBeforeZero = -1

    for i, num in enumerate(nums):
      if num:
        indexBeforeZero = i
      else:
        ans += i - indexBeforeZero

    return ans

```

## 846. Hand of Straights_846.py
```python
class Solution:
  def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:
    count = collections.Counter(hand)

    for start in sorted(count):
      value = count[start]
      if value > 0:
        for i in range(start, start + groupSize):
          count[i] -= value
          if count[i] < 0:
            return False

    return True

```

## 921. Minimum Add to Make Parentheses Valid_921.py
```python
class Solution:
  def minAddToMakeValid(self, s: str) -> int:
    l = 0
    r = 0

    for c in s:
      if c == '(':
        l += 1
      else:
        if l == 0:
          r += 1
        else:
          l -= 1

    return l + r

```

## 2140. Solving Questions With Brainpower_2140.py
```python
class Solution:
  def mostPoints(self, questions: List[List[int]]) -> int:
    n = len(questions)
    # dp[i] := the maximum points starting from questions[i]
    dp = [0] * (n + 1)

    for i in reversed(range(n)):
      points, brainpower = questions[i]
      nextIndex = i + brainpower + 1
      nextPoints = dp[nextIndex] if nextIndex < n else 0
      dp[i] = max(points + nextPoints, dp[i + 1])

    return dp[0]

```

## 9. Palindrome Number_9.py
```python
class Solution:
  def isPalindrome(self, x: int) -> bool:
    if x < 0:
      return False

    rev = 0
    y = x

    while y:
      rev = rev * 10 + y % 10
      y //= 10

    return rev == x

```

## 2369. Check if There is a Valid Partition For The Array_2369.py
```python
class Solution:
  def validPartition(self, nums: List[int]) -> bool:
    n = len(nums)
    # dp[i] := True if there's a valid partition for the first i numbers
    dp = [False] * (n + 1)
    dp[0] = True
    dp[2] = nums[0] == nums[1]

    for i in range(3, n + 1):
      dp[i] = (dp[i - 2] and nums[i - 2] == nums[i - 1]) or \
          (dp[i - 3] and ((nums[i - 3] == nums[i - 2] and nums[i - 2] == nums[i - 1]) or
                          (nums[i - 3] + 1 == nums[i - 2] and nums[i - 2] + 1 == nums[i - 1])))

    return dp[n]

```

## 1432. Max Difference You Can Get From Changing an Integer_1432.py
```python
class Solution:
  def maxDiff(self, num: int) -> int:
    s = str(num)

    def firstNot(s: str, t: str) -> int:
      for i, c in enumerate(s):
        if all(c != d for d in t):
          return i
      return 0

    firstNot9 = firstNot(s, '9')
    firstNot01 = firstNot(s, '01')
    a = s.replace(s[firstNot9], '9')
    b = s.replace(s[firstNot01], '1' if firstNot01 == 0 else '0')
    return int(a) - int(b)

```

## 646. Maximum Length of Pair Chain_646.py
```python
class Solution:
  def findLongestChain(self, pairs: List[List[int]]) -> int:
    ans = 0
    prevEnd = -math.inf

    for s, e in sorted(pairs, key=lambda x: x[1]):
      if s > prevEnd:
        ans += 1
        prevEnd = e

    return ans

```

## 625. Minimum Factorization_625.py
```python
class Solution:
  def smallestFactorization(self, num: int) -> int:
    if num == 1:
      return 1

    ans = 0
    base = 1

    for i in range(9, 1, -1):
      while num % i == 0:
        num //= i
        ans = base * i + ans
        base *= 10

    return ans if num == 1 and ans < 2**31 - 1 else 0

```

## 174. Dungeon Game_174.py
```python
class Solution:
  def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
    m = len(dungeon)
    n = len(dungeon[0])
    dp = [math.inf] * (n + 1)
    dp[n - 1] = 1

    for i in reversed(range(m)):
      for j in reversed(range(n)):
        dp[j] = min(dp[j], dp[j + 1]) - dungeon[i][j]
        dp[j] = max(dp[j], 1)

    return dp[0]

```

## 2560. House Robber IV_2560.py
```python
class Solution:
  def minCapability(self, nums: List[int], k: int) -> int:
    def numStolenHouses(capacity: int) -> int:
      stolenHouses = 0
      i = 0
      while i < len(nums):
        if nums[i] <= capacity:
          stolenHouses += 1
          i += 1
        i += 1
      return stolenHouses

    return bisect.bisect_left(range(max(nums)), k,
                              key=lambda m: numStolenHouses(m))

```

## 2702. Minimum Operations to Make Numbers Non-positive_2702.py
```python
class Solution:
  def minOperations(self, nums: list[int], x: int, y: int) -> int:
    def isPossible(m: int) -> bool:
      """
      Returns True if it's possible to make all `nums` <= 0 using m operations.
      """
      # If we want m operations, first decrease all the numbers by y * m. Then
      # we have m operations to select indices to decrease them by x - y.
      return sum(max(0, math.ceil((num - y * m) / (x - y)))
                 for num in nums) <= m

    return bisect.bisect_left(range(max(nums)), True,
                              key=isPossible)

```

## 7. Reverse Integer_7.py
```python
class Solution:
  def reverse(self, x: int) -> int:
    ans = 0
    sign = -1 if x < 0 else 1
    x *= sign

    while x:
      ans = ans * 10 + x % 10
      x //= 10

    return 0 if ans < -2**31 or ans > 2**31 - 1 else sign * ans

```

## 3217. Delete Nodes From Linked List Present in Array_3217.py
```python
class Solution:
  def modifiedList(self, nums: List[int], head: Optional[ListNode]) -> Optional[ListNode]:
    dummy = ListNode(0, head)
    numsSet = set(nums)

    curr = dummy
    while curr.next:
      if curr.next.val in numsSet:
        curr.next = curr.next.next
      else:
        curr = curr.next

    return dummy.next

```

## 1402. Reducing Dishes_1402.py
```python
class Solution:
  def maxSatisfaction(self, satisfaction: List[int]) -> int:
    ans = 0
    sumSatisfaction = 0

    for s in sorted(satisfaction, reverse=True):
      sumSatisfaction += s
      if sumSatisfaction <= 0:
        return ans
      ans += sumSatisfaction

    return ans

```

## 3033. Modify the Matrix_3033.py
```python
class Solution:
  def modifiedMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
    m = len(matrix)
    n = len(matrix[0])
    ans = matrix.copy()

    for j in range(n):
      mx = max(matrix[i][j] for i in range(m))
      for i in range(m):
        if matrix[i][j] == -1:
          ans[i][j] = mx

    return ans

```

## 1829. Maximum XOR for Each Query_1829.py
```python
class Solution:
  def getMaximumXor(self, nums: List[int], maximumBit: int) -> List[int]:
    mx = (1 << maximumBit) - 1
    ans = []
    xors = 0

    for num in nums:
      xors ^= num
      ans.append(xors ^ mx)

    return ans[::-1]

```

## 635. Design Log Storage System_635.py
```python
class LogSystem:
  def __init__(self):
    self.granularityToIndices = {'Year': 4, 'Month': 7, 'Day': 10,
                                 'Hour': 13, 'Minute': 16, 'Second': 19}
    self.idAndTimestamps = []

  def put(self, id: int, timestamp: str) -> None:
    self.idAndTimestamps.append((id, timestamp))

  def retrieve(self, start: str, end: str, granularity: str) -> List[int]:
    index = self.granularityToIndices[granularity]
    s = start[:index]
    e = end[:index]
    return [id for id, timestamp in self.idAndTimestamps
            if s <= timestamp[:index] <= e]

```

## 1995. Count Special Quadruplets_1995-2.py
```python
class Solution:
  def countQuadruplets(self, nums: List[int]) -> int:
    n = len(nums)
    ans = 0
    count = collections.Counter()

    for c in range(n - 1, 1, -1):  # `c` also represents `d`.
      for b in range(c - 1, 0, -1):
        for a in range(b - 1, -1, -1):
          ans += count[nums[a] + nums[b] + nums[c]]
      count[nums[c]] += 1  # c := d

    return ans

```

## 2299. Strong Password Checker II_2299.py
```python
class Solution:
  def strongPasswordCheckerII(self, password: str) -> bool:
    if len(password) < 8:
      return False
    if not any(c.islower() for c in password):
      return False
    if not any(c.isupper() for c in password):
      return False
    if not any(c.isdigit() for c in password):
      return False
    if not any("!@#$%^&*()-+".find(c) != -1 for c in password):
      return False
    return all(a != b for a, b in zip(password, password[1:]))

```

## 2141. Maximum Running Time of N Computers_2141.py
```python
class Solution:
  def maxRunTime(self, n: int, batteries: List[int]) -> int:
    summ = sum(batteries)

    batteries.sort()

    # The maximum battery is greater than the average, so it can last forever.
    # Reduce the problem from size n to size n - 1.
    while batteries[-1] > summ // n:
      summ -= batteries.pop()
      n -= 1

    # If the maximum battery <= average running time, it won't be waste, and so
    # do smaller batteries.
    return summ // n

```

## 3091. Apply Operations to Make Sum of Array Greater Than or Equal to k_3091.py
```python
class Solution:
  def minOperations(self, k: int) -> int:
    # The required operations are
    #   1. Increase `1` to `x`
    #   2. Duplicate `x`, `y` times, to `sum` s.t. x * (1 + y) >= k.
    # The number of operations used would be (x - 1) + y. Equivalently, the
    # problem can be rephrased as finding min(x - 1 + y) s.t. x * (1 + y) >= k.
    # Optimally, `x` should equal to `1 + y`, implying that x^2 >= k, and
    # hence, x >= sqrt(k) and y = ceil(k / x) - 1.
    x = math.ceil(math.sqrt(k))
    y = (k - 1) // x + 1 - 1  # ceil(k / x) - 1
    return x - 1 + y

```

## 1749. Maximum Absolute Sum of Any Subarray_1749.py
```python
class Solution:
  def maxAbsoluteSum(self, nums):
    ans = -math.inf
    maxSum = 0
    minSum = 0

    for num in nums:
      maxSum = max(num, maxSum + num)
      minSum = min(num, minSum + num)
      ans = max(ans, maxSum, -minSum)

    return ans

```

## 1324. Print Words Vertically_1324.py
```python
class Solution:
  def printVertically(self, s: str) -> List[str]:
    ans = []
    words = s.split()
    maxLength = max(len(word) for word in words)

    for i in range(maxLength):
      row = []
      for word in words:
        row.append(word[i] if i < len(word) else ' ')
      ans.append(''.join(row).rstrip())

    return ans

```

## 2706. Buy Two Chocolates_2706.py
```python
class Solution:
  def buyChoco(self, prices: List[int], money: int) -> int:
    min1 = math.inf
    min2 = math.inf

    for price in prices:
      if price <= min1:
        min2 = min1
        min1 = price
      elif price < min2:
        min2 = price

    minCost = min1 + min2
    return money if minCost > money else money - minCost

```

## 1128. Number of Equivalent Domino Pairs_1128.py
```python
class Solution:
  def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:
    ans = 0
    count = collections.Counter()

    for domino in dominoes:
      key = min(domino[0], domino[1]) * 10 + max(domino[0], domino[1])
      ans += count[key]
      count[key] += 1

    return ans

```

## 937. Reorder Data in Log Files_937.py
```python
class Solution:
  def reorderLogFiles(self, logs: List[str]) -> List[str]:
    digitLogs = []
    letterLogs = []

    for log in logs:
      i = log.index(' ')
      if log[i + 1].isdigit():
        digitLogs.append(log)
      else:
        letterLogs.append((log[:i], log[i + 1:]))

    letterLogs.sort(key=lambda l: (l[1], l[0]))

    return [identifier + ' ' + letters for identifier, letters in letterLogs] + digitLogs

```

## 2742. Painting the Walls_2742-2.py
```python
class Solution:
  def paintWalls(self, cost: List[int], time: List[int]) -> int:
    kMax = 500_000_000
    n = len(cost)
    # dp[i] := the minimum cost to paint i walls by the painters so far
    dp = [0] + [kMax] * n

    for c, t in zip(cost, time):
      for walls in range(n, 0, -1):
        dp[walls] = min(dp[walls], dp[max(walls - t - 1, 0)] + c)

    return dp[n]

```

## 241. Different Ways to Add Parentheses_241.py
```python
class Solution:
  @functools.lru_cache(None)
  def diffWaysToCompute(self, expression: str) -> List[int]:
    ans = []

    for i, c in enumerate(expression):
      if c in '+-*':
        for a in self.diffWaysToCompute(expression[:i]):
          for b in self.diffWaysToCompute(expression[i + 1:]):
            ans.append(eval(str(a) + c + str(b)))

    return ans or [int(expression)]

```

## 3012. Minimize Length of Array Using Operations_3012.py
```python
class Solution:
  def minimumArrayLength(self, nums: List[int]) -> int:
    # Let the minimum number in the array `nums` be x.
    # * If there exists any element nums[i] where nums[i] % x > 0, a new
    #   minimum can be generated and all other numbers can be removed.
    # * If not, count the frequency of x in `nums`. For each pair of x, a 0 is
    #   generated which cannot be removed. Therefore, the result will be
    #   (frequency of x + 1) / 2.
    minNum = min(nums)
    if any(num % minNum > 0 for num in nums):
      return 1
    return (nums.count(minNum) + 1) // 2

```

## 2441. Largest Positive Integer That Exists With Its Negative_2441.py
```python
class Solution:
  def findMaxK(self, nums: List[int]) -> int:
    ans = -1
    seen = set()

    for num in nums:
      if -num in seen:
        ans = max(ans, abs(num))
      else:
        seen.add(num)

    return ans

```

## 1506. Find Root of N-Ary Tree_1506.py
```python
class Solution:
  def findRoot(self, tree: List['Node']) -> 'Node':
    sum = 0

    for node in tree:
      sum ^= node.val
      for child in node.children:
        sum ^= child.val

    for node in tree:
      if node.val == sum:
        return node

```

## 3164. Find the Number of Good Pairs II_3164.py
```python
class Solution:
  def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:
    count = collections.Counter(num * k for num in nums2)
    ans = 0

    for num in nums1:
      for divisor in range(1, int(num ** 0.5) + 1):
        if num % divisor == 0:
          ans += count[divisor]
          if num // divisor != divisor:
            ans += count[num // divisor]

    return ans

```

## 1049. Last Stone Weight II_1049.py
```python
class Solution:
  def lastStoneWeightII(self, stones: List[int]) -> int:
    summ = sum(stones)
    s = 0
    dp = [True] + [False] * summ

    for stone in stones:
      for w in range(summ // 2 + 1)[::-1]:
        if w >= stone:
          dp[w] = dp[w] or dp[w - stone]
        if dp[w]:
          s = max(s, w)

    return summ - 2 * s

```

## 199. Binary Tree Right Side View_199-2.py
```python
class Solution:
  def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
    ans = []

    def dfs(root: Optional[TreeNode], depth: int) -> None:
      if not root:
        return

      if depth == len(ans):
        ans.append(root.val)
      dfs(root.right, depth + 1)
      dfs(root.left, depth + 1)

    dfs(root, 0)
    return ans

```

## 1866. Number of Ways to Rearrange Sticks With K Sticks Visible_1866.py
```python
class Solution:
  @functools.lru_cache(None)
  def rearrangeSticks(self, n: int, k: int) -> int:
    if n == k:
      return 1
    if k == 0:
      return 0
    return (self.rearrangeSticks(n - 1, k - 1) +
            self.rearrangeSticks(n - 1, k) * (n - 1)) % self.kMod

  kMod = 1_000_000_007

```

## 487. Max Consecutive Ones II_487-3.py
```python
class Solution:
  def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
    ans = 0
    lastZeroIndex = -1

    l = 0
    for r, num in enumerate(nums):
      if num == 0:
        l = lastZeroIndex + 1
        lastZeroIndex = r
      ans = max(ans, r - l + 1)

    return ans

```

## 161. One Edit Distance_161.py
```python
class Solution:
  def isOneEditDistance(self, s: str, t: str) -> bool:
    m = len(s)
    n = len(t)
    if m > n:  # Make sure that |s| <= |t|.
      return self.isOneEditDistance(t, s)

    for i in range(m):
      if s[i] != t[i]:
        if m == n:
          return s[i + 1:] == t[i + 1:]  # Replace s[i] with t[i].
        return s[i:] == t[i + 1:]  # Delete t[i].

    return m + 1 == n  # Delete t[-1].

```

## 495. Teemo Attacking_495.py
```python
class Solution:
  def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:
    if duration == 0:
      return 0

    ans = 0

    for i in range(0, len(timeSeries) - 1):
      ans += min(timeSeries[i + 1] - timeSeries[i], duration)

    return ans + duration

```

## 392. Is Subsequence_392.py
```python
class Solution:
  def isSubsequence(self, s: str, t: str) -> bool:
    if not s:
      return True

    i = 0
    for c in t:
      if s[i] == c:
        i += 1
        if i == len(s):
          return True

    return False

```

## 2224. Minimum Number of Operations to Convert Time_2224.py
```python
class Solution:
  def convertTime(self, current: str, correct: str) -> int:
    ops = [60, 15, 5, 1]

    def getMinutes(s: str) -> int:
      return int(s[:2]) * 60 + int(s[3:])

    diff = getMinutes(correct) - getMinutes(current)
    ans = 0

    for op in ops:
      ans += diff // op
      diff %= op

    return ans

```

## 1230. Toss Strange Coins_1230.py
```python
class Solution:
  def probabilityOfHeads(self, prob: List[float], target: int) -> float:
    # dp[i][j] := the probability of tossing the first i coins with j heads
    dp = [[0] * (target + 1) for _ in range(len(prob) + 1)]
    dp[0][0] = 1.0

    for i in range(1, len(prob) + 1):
      for j in range(target + 1):
        dp[i][j] = (dp[i - 1][j - 1] * prob[i - 1] if j > 0 else 0) + \
            dp[i - 1][j] * (1 - prob[i - 1])

    return dp[len(prob)][target]

```

## 2892. Minimizing Array After Replacing Pairs With Their Product_2892.py
```python
class Solution:
  def minArrayLength(self, nums: List[int], k: int) -> int:
    count = 0
    prod = -1

    for num in nums:
      if num == 0:
        return 1
      if prod != -1 and prod * num <= k:
        prod *= num
      else:
        prod = num
        count += 1

    return count

```

## 2554. Maximum Number of Integers to Choose From a Range I_2554.py
```python
class Solution:
  def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:
    ans = 0
    summ = 0
    bannedSet = set(banned)

    for i in range(1, n + 1):
      if i not in bannedSet and summ + i <= maxSum:
        ans += 1
        summ += i

    return ans

```

## 1403. Minimum Subsequence in Non-Increasing Order_1403.py
```python
class Solution:
  def minSubsequence(self, nums: List[int]) -> List[int]:
    ans = []
    maxHeap = [-num for num in nums]
    heapq.heapify(maxHeap)
    half = sum(nums) // 2

    while half >= 0:
      ans.append(-maxHeap[0])
      half += heapq.heappop(maxHeap)

    return ans

```

## 219. Contains Duplicate II_219.py
```python
class Solution:
  def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
    seen = set()

    for i, num in enumerate(nums):
      if i > k:
        seen.remove(nums[i - k - 1])
      if num in seen:
        return True
      seen.add(num)

    return False

```

## 1198. Find Smallest Common Element in All Rows_1198.py
```python
class Solution:
  def smallestCommonElement(self, mat: List[List[int]]) -> int:
    kMax = 10000
    count = [0] * (kMax + 1)

    for row in mat:
      for a in row:
        count[a] += 1
        if count[a] == len(mat):
          return a

    return -1

```

## 2530. Maximal Score After Applying K Operations_2530.py
```python
class Solution:
  def maxKelements(self, nums: List[int], k: int) -> int:
    ans = 0
    maxHeap = [-num for num in nums]
    heapq.heapify(maxHeap)

    for _ in range(k):
      num = -heapq.heappop(maxHeap)
      ans += num
      heapq.heappush(maxHeap, -math.ceil(num / 3))

    return ans

```

## 2574. Left and Right Sum Differences_2574-2.py
```python
class Solution:
  def leftRigthDifference(self, nums: List[int]) -> List[int]:
    ans = []
    leftSum = 0
    rightSum = sum(nums)

    for num in nums:
      rightSum -= num
      ans.append(abs(leftSum - rightSum))
      leftSum += num

    return ans

```

## 2325. Decode the Message_2325.py
```python
class Solution:
  def decodeMessage(self, key: str, message: str) -> str:
    keyToActual = {' ': ' '}
    currChar = 'a'

    for c in key:
      if c not in keyToActual:
        keyToActual[c] = currChar
        currChar = chr(ord(currChar) + 1)

    return ''.join(keyToActual[c] for c in message)

```

## 1995. Count Special Quadruplets_1995-3.py
```python
class Solution:
  def countQuadruplets(self, nums: List[int]) -> int:
    n = len(nums)
    ans = 0
    count = collections.Counter()

    #    nums[a] + nums[b] + nums[c] == nums[d]
    # => nums[a] + nums[b] == nums[d] - nums[c]
    for b in range(n - 1, 0, -1):  # `b` also represents `c`.
      for a in range(b - 1, -1, -1):
        ans += count[nums[a] + nums[b]]
      for d in range(n - 1, b, -1):
        count[nums[d] - nums[b]] += 1  # b := c

    return ans

```

## 1793. Maximum Score of a Good Subarray_1793.py
```python
class Solution:
  # Similar to 84. Largest Rectangle in Histogram
  def maximumScore(self, nums: List[int], k: int) -> int:
    ans = 0
    stack = []

    for i in range(len(nums) + 1):
      while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):
        h = nums[stack.pop()]
        w = i - stack[-1] - 1 if stack else i
        if (not stack or stack[-1] + 1 <= k) and i - 1 >= k:
          ans = max(ans, h * w)
      stack.append(i)

    return ans

```

## 2781. Length of the Longest Valid Substring_2781.py
```python
class Solution:
  def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
    forbiddenSet = set(forbidden)
    ans = 0
    r = len(word) - 1  # rightmost index of the valid substring

    for l in range(len(word) - 1, -1, -1):
      for end in range(l, min(l + 10, r + 1)):
        if word[l:end + 1] in forbiddenSet:
          r = end - 1
          break
      ans = max(ans, r - l + 1)

    return ans

```

## 1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K_1414.py
```python
class Solution:
  def findMinFibonacciNumbers(self, k: int) -> int:
    if k < 2:  # k == 0 or k == 1
      return k

    a = 1  # F_1
    b = 1  # F_2

    while b <= k:
      #    a, b = F_{i + 1}, F_{i + 2}
      # -> a, b = F_{i + 2}, F_{i + 3}
      a, b = b, a + b

    return 1 + self.findMinFibonacciNumbers(k - a)

```

## 1996. The Number of Weak Characters in the Game_1996.py
```python
class Solution:
  def numberOfWeakCharacters(self, properties: List[List[int]]) -> int:
    ans = 0
    maxDefense = 0

    # Sort properties by `attack` in descending order, then by `defense` in
    # ascending order.
    for _, defense in sorted(properties, key=lambda x: (-x[0], x[1])):
      if defense < maxDefense:
        ans += 1
      maxDefense = max(maxDefense, defense)

    return ans

```

## 2225. Find Players With Zero or One Losses_2225.py
```python
class Solution:
  def findWinners(self, matches: List[List[int]]) -> List[List[int]]:
    ans = [[] for _ in range(2)]
    lossesCount = collections.Counter()

    for winner, loser in matches:
      if winner not in lossesCount:
        lossesCount[winner] = 0
      lossesCount[loser] += 1

    for player, nLosses in lossesCount.items():
      if nLosses < 2:
        ans[nLosses].append(player)

    return [sorted(ans[0]), sorted(ans[1])]

```

## 2380. Time Needed to Rearrange a Binary String_2380.py
```python
class Solution:
  def secondsToRemoveOccurrences(self, s: str) -> int:
    ans = 0
    zeros = 0

    for c in s:
      if c == '0':
        zeros += 1
      elif zeros > 0:  # c == '1'
        ans = max(ans + 1, zeros)

    return ans

```

## 739. Daily Temperatures_739.py
```python
class Solution:
  def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
    ans = [0] * len(temperatures)
    stack = []  # a decreasing stack

    for i, temperature in enumerate(temperatures):
      while stack and temperature > temperatures[stack[-1]]:
        index = stack.pop()
        ans[index] = i - index
      stack.append(i)

    return ans

```

## 606. Construct String from Binary Tree_606.py
```python
class Solution:
  def tree2str(self, t: Optional[TreeNode]) -> str:
    def dfs(root: Optional[TreeNode]) -> str:
      if not root:
        return ''
      if root.right:
        return str(root.val) + '(' + dfs(root.left) + ')(' + dfs(root.right) + ')'
      if root.left:
        return str(root.val) + '(' + dfs(root.left) + ')'
      return str(root.val)
    return dfs(t)

```

## 2996. Smallest Missing Integer Greater Than Sequential Prefix Sum_2996.py
```python
class Solution:
  def missingInteger(self, nums: List[int]) -> int:
    numsSet = set(nums)
    ans = nums[0]

    for i in range(1, len(nums)):
      if nums[i] != nums[i - 1] + 1:
        break
      ans += nums[i]

    while ans in numsSet:
      ans += 1

    return ans

```

## 1352. Product of the Last K Numbers_1352.py
```python
class ProductOfNumbers:
  def __init__(self):
    self.prefix = [1]

  def add(self, num: int) -> None:
    if num == 0:
      self.prefix = [1]
    else:
      self.prefix.append(self.prefix[-1] * num)

  def getProduct(self, k: int) -> int:
    return 0 if k >= len(self.prefix) else self.prefix[-1] // self.prefix[len(self.prefix) - k - 1]

```

## 63. Unique Paths II_63-2.py
```python
class Solution:
  def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
    m = len(obstacleGrid)
    n = len(obstacleGrid[0])
    dp = [0] * n
    dp[0] = 1

    for i in range(m):
      for j in range(n):
        if obstacleGrid[i][j]:
          dp[j] = 0
        elif j > 0:
          dp[j] += dp[j - 1]

    return dp[n - 1]

```

## 2393. Count Strictly Increasing Subarrays_2393.py
```python
class Solution:
  def countSubarrays(self, nums: List[int]) -> int:
    ans = 0

    j = -1
    for i, num in enumerate(nums):
      if i > 0 and num <= nums[i - 1]:
        j = i - 1
      ans += i - j

    return ans

```

## 1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold_1343.py
```python
class Solution:
  def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:
    ans = 0
    windowSum = 0

    for i in range(len(arr)):
      windowSum += arr[i]
      if i >= k:
        windowSum -= arr[i - k]
      if i >= k - 1 and windowSum // k >= threshold:
        ans += 1

    return ans

```

## 2033. Minimum Operations to Make a Uni-Value Grid_2033.py
```python
class Solution:
  def minOperations(self, grid: List[List[int]], x: int) -> int:
    A = sorted([a for row in grid for a in row])
    if any((a - A[0]) % x for a in A):
      return -1

    ans = 0

    for a in A:
      ans += abs(a - A[len(A) // 2]) // x

    return ans

```

## 524. Longest Word in Dictionary through Deleting_524.py
```python
class Solution:
  def findLongestWord(self, s: str, d: List[str]) -> str:
    ans = ''

    for word in d:
      i = 0
      for c in s:
        if i < len(word) and c == word[i]:
          i += 1
      if i == len(word):
        if len(word) > len(ans) or len(word) == len(ans) and word < ans:
          ans = word

    return ans

```

## 2576. Find the Maximum Number of Marked Indices_2576.py
```python
class Solution:
  def maxNumOfMarkedIndices(self, nums: List[int]) -> int:
    nums.sort()

    def isPossible(m: int) -> bool:
      for i in range(m):
        if 2 * nums[i] > nums[-m + i]:
          return False
      return True

    l = bisect.bisect_left(range(len(nums) // 2 + 1), True,
                           key=lambda m: not isPossible(m))
    return (l - 1) * 2

```

## 1542. Find Longest Awesome Substring_1542.py
```python
class Solution:
  def longestAwesome(self, s: str) -> int:
    ans = 0
    prefix = 0  # the binary prefix
    prefixToIndex = [len(s)] * 1024
    prefixToIndex[0] = -1

    for i, c in enumerate(s):
      prefix ^= 1 << ord(c) - ord('0')
      ans = max(ans, i - prefixToIndex[prefix])
      for j in range(10):
        ans = max(ans, i - prefixToIndex[prefix ^ 1 << j])
      prefixToIndex[prefix] = min(prefixToIndex[prefix], i)

    return ans

```

## 2154. Keep Multiplying Found Values by Two_2155-2.py
```python
class Solution:
  def findFinalValue(self, nums: List[int], original: int) -> int:
    seen = [False] * 1001

    for num in nums:
      seen[num] = True

    while original < 1001 and seen[original]:
      original *= 2

    return original

```

## 1944. Number of Visible People in a Queue_1944.py
```python
class Solution:
  def canSeePersonsCount(self, heights: List[int]) -> List[int]:
    ans = [0] * len(heights)
    stack = []

    for i, height in enumerate(heights):
      while stack and heights[stack[-1]] <= height:
        ans[stack.pop()] += 1
      if stack:
        ans[stack[-1]] += 1
      stack.append(i)

    return ans

```

## 2843. Count Symmetric Integers_2843.py
```python
class Solution:
  def countSymmetricIntegers(self, low: int, high: int) -> int:
    def isSymmetricInteger(num: int) -> bool:
      if num >= 10 and num <= 99:
        return num // 10 == num % 10
      if num >= 1000 and num <= 9999:
        left = num // 100
        right = num % 100
        return left // 10 + left % 10 == right // 10 + right % 10
      return False

    return sum(isSymmetricInteger(num) for num in range(low, high + 1))

```

## 3135. Equalize Strings by Adding or Removing Characters at Ends_3135.py
```python
class Solution:
  def minOperations(self, initial: str, target: str) -> int:
    m = len(initial)
    n = len(target)
    # dp[i][j] := the length of LCS(initial[0..i), target[0..j))
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
      for j in range(1, n + 1):
        if initial[i - 1] == target[j - 1]:
          dp[i][j] = 1 + dp[i - 1][j - 1]

    return m + n - 2 * max(map(max, dp))

```

## 71. Simplify Path_71.py
```python
class Solution:
  def simplifyPath(self, path: str) -> str:
    stack = []

    for str in path.split('/'):
      if str in ('', '.'):
        continue
      if str == '..':
        if stack:
          stack.pop()
      else:
        stack.append(str)

    return '/' + '/'.join(stack)

```

## 946. Validate Stack Sequences_946.py
```python
class Solution:
  def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
    stack = []
    i = 0  # popped's index

    for x in pushed:
      stack.append(x)
      while stack and stack[-1] == popped[i]:
        stack.pop()
        i += 1

    return not stack

```

## 1310. XOR Queries of a Subarray_1310.py
```python
class Solution:
  def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:
    ans = []
    xors = [0] * (len(arr) + 1)

    for i, a in enumerate(arr):
      xors[i + 1] = xors[i] ^ a

    for left, right in queries:
      ans.append(xors[left] ^ xors[right + 1])

    return ans

```

## 763. Partition Labels_763.py
```python
class Solution:
  def partitionLabels(self, s: str) -> List[int]:
    ans = []
    letterToRightmostIndex = {c: i for i, c in enumerate(s)}

    l = 0  # the leftmost index of the current running string
    r = 0  # the rightmost index of the current running string

    for i, c in enumerate(s):
      r = max(r, letterToRightmostIndex[c])
      if i == r:
        ans.append(r - l + 1)
        l = r + 1

    return ans

```

## 487. Max Consecutive Ones II_487-2.py
```python
class Solution:
  def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
    maxZeros = 1
    ans = 0
    q = collections.deque()  # Store indices of zero.

    l = 0
    for r, num in enumerate(nums):
      if num == 0:
        q.append(r)
      if len(q) > maxZeros:
        l = q.popleft() + 1
      ans = max(ans, r - l + 1)

    return ans

```

## 2364. Count Number of Bad Pairs_2364.py
```python
class Solution:
  def countBadPairs(self, nums: List[int]) -> int:
    ans = 0
    count = collections.Counter()  # (nums[i] - i)

    for i, num in enumerate(nums):
      #     count[nums[i] - i] := the number of good pairs
      # i - count[nums[i] - i] := the number of bad pairs
      ans += i - count[num - i]
      count[num - i] += 1

    return ans

```

## 1660. Correct a Binary Tree_1660.py
```python
class Solution:
  def __init__(self):
    self.seen = set()

  def correctBinaryTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
    if root == None:
      return None
    if root.right and root.right.val in self.seen:
      return None
    self.seen.add(root.val)
    root.right = self.correctBinaryTree(root.right)
    root.left = self.correctBinaryTree(root.left)
    return root

```

## 3091. Apply Operations to Make Sum of Array Greater Than or Equal to k_3091-2.py
```python
class Solution:
  def minOperations(self, k: int) -> int:
    # The required operations are
    #   1. Increase `1` to `x`
    #   2. Duplicate `x`, `y` times, to `sum` s.t. x * (1 + y) >= k.
    # The number of operations used would be (x - 1) + y. Equivalently, the
    # problem can be rephrased as finding min(x - 1 + y) s.t. x * (1 + y) >= k.
    # Optimally, `x` should equal to `1 + y`, implying that x^2 >= k, and
    # hence, x >= sqrt(k) and y = ceil(k / x) - 1.
    x = math.isqrt(k)
    y = (k - 1) // x + 1 - 1  # ceil(k / x) - 1
    return x - 1 + y

```

## 776. Split BST_776.py
```python
class Solution:
  def splitBST(self, root: Optional[TreeNode], target: int) -> List[Optional[TreeNode]]:
    if not root:
      return None, None
    if root.val > target:
      left, right = self.splitBST(root.left, target)
      root.left = right
      return left, root
    else:  # root.val <= target
      left, right = self.splitBST(root.right, target)
      root.right = left
      return root, right

```

## 2315. Count Asterisks_2315.py
```python
class Solution:
  def countAsterisks(self, s: str) -> int:
    ans = 0
    bars = 0

    for c in s:
      if c == '|':
        bars += 1
      elif c == '*' and bars % 2 == 0:
        ans += 1

    return ans

```

## 1639. Number of Ways to Form a Target String Given a Dictionary_1639-3.py
```python
class Solution:
  def numWays(self, words: List[str], target: str) -> int:
    kMod = 1_000_000_007
    # dp[i] := the number of ways to form the first i characters of `target`
    dp = [0] * (len(target) + 1)
    dp[0] = 1

    for j in range(len(words[0])):
      count = collections.Counter(word[j] for word in words)
      for i in range(len(target), 0, -1):
        dp[i] += dp[i - 1] * count[target[i - 1]]
        dp[i] %= kMod

    return dp[len(target)]

```

## 337. House Robber III_337.py
```python
class Solution:
  def rob(self, root: Optional[TreeNode]) -> int:
    def robOrNot(root: Optional[TreeNode]) -> tuple:
      if not root:
        return (0, 0)

      robLeft, notRobLeft = robOrNot(root.left)
      robRight, notRobRight = robOrNot(root.right)

      return (root.val + notRobLeft + notRobRight,
              max(robLeft, notRobLeft) + max(robRight, notRobRight))

    return max(robOrNot(root))

```

## 482. License Key Formatting_482.py
```python
class Solution:
  def licenseKeyFormatting(self, s: str, k: int) -> str:
    ans = []
    length = 0

    for i in reversed(range(len(s))):
      if s[i] == '-':
        continue
      if length > 0 and length % k == 0:
        ans += '-'
      ans += s[i].upper()
      length += 1

    return ''.join(reversed(ans))

```

## 2187. Minimum Time to Complete Trips_2187.py
```python
class Solution:
  def minimumTime(self, time: List[int], totalTrips: int) -> int:
    l = 1
    r = min(time) * totalTrips

    while l < r:
      m = (l + r) // 2
      if sum(m // t for t in time) >= totalTrips:
        r = m
      else:
        l = m + 1

    return l

```

## 804. Unique Morse Code Words_804.py
```python
class Solution:
  def uniqueMorseRepresentations(self, words: List[str]) -> int:
    morse = [".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--",
             "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."]
    transformations = set()

    for word in words:
      transformation = ''.join(morse[ord(c) - ord('a')] for c in word)
      transformations.add(transformation)

    return len(transformations)

```

## 346. Moving Average from Data Stream_346.py
```python
class MovingAverage:
  def __init__(self, size: int):
    self.size = size
    self.sum = 0
    self.q = collections.deque()

  def next(self, val: int) -> float:
    if len(self.q) == self.size:
      self.sum -= self.q.popleft()
    self.sum += val
    self.q.append(val)
    return self.sum / len(self.q)

```

## 70. Climbing Stairs_70-2.py
```python
class Solution:
  def climbStairs(self, n: int) -> int:
    prev1 = 1  # dp[i - 1]
    prev2 = 1  # dp[i - 2]

    for _ in range(2, n + 1):
      dp = prev1 + prev2
      prev2 = prev1
      prev1 = dp

    return prev1

```

## 2291. Maximum Profit From Trading Stocks_2291-2.py
```python
class Solution:
  def maximumProfit(self, present: List[int], future: List[int], budget: int) -> int:
    n = len(present)
    # dp[i] := the maximum profit of buying present so far with i budget
    dp = [0] * (budget + 1)

    for p, f in zip(present, future):
      for j in range(budget, p - 1, -1):
        dp[j] = max(dp[j], f - p + dp[j - p])

    return dp[budget]

```

## 2787. Ways to Express an Integer as Sum of Powers_2787.py
```python
class Solution:
  def numberOfWays(self, n: int, x: int) -> int:
    kMod = 1_000_000_007
    # dp[i] := the number of ways to express i
    dp = [1] + [0] * n

    for a in range(1, n + 1):
      ax = a**x
      if ax > n:
        break
      for i in range(n, ax - 1, -1):
        dp[i] += dp[i - ax]
        dp[i] %= kMod

    return dp[n]

```

## 1281. Subtract the Product and Sum of Digits of an Integer_1281.py
```python
class Solution:
  def subtractProductAndSum(self, n: int) -> int:
    prod = 1
    summ = 0

    while n > 0:
      prod *= n % 10
      summ += n % 10
      n //= 10

    return prod - summ

```

## 2915. Length of the Longest Subsequence That Sums to Target_2915-2.py
```python
class Solution:
  def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:
    # dp[i] := the maximum length of any subsequence of numbers so far that
    # sum to j
    dp = [0] * (target + 1)

    for num in nums:
      for i in range(target, num - 1, -1):
        if i == num or dp[i - num] > 0:
          dp[i] = max(dp[i], 1 + dp[i - num])

    return dp[target] if dp[target] > 0 else -1

```

## 2303. Calculate Amount Paid in Taxes_2303.py
```python
class Solution:
  def calculateTax(self, brackets: List[List[int]], income: int) -> float:
    ans = 0
    prev = 0

    for upper, percent in brackets:
      if income < upper:
        return ans + (income - prev) * percent / 100.0
      ans += (upper - prev) * percent / 100.0
      prev = upper

    return ans

```

## 2551. Put Marbles in Bags_2551.py
```python
class Solution:
  def putMarbles(self, weights: List[int], k: int) -> int:
    # To distribute marbles into k bags, there will be k - 1 cuts. If there's a
    # cut after weights[i], then weights[i] and weights[i + 1] will be added to
    # the cost. Also, no matter how we cut, weights[0] and weights[n - 1] will
    # be counted. So, the goal is to find the max//min k - 1 weights[i] +
    # weights[i + 1].

    # weights[i] + weights[i + 1]
    A = [a + b for a, b in itertools.pairwise(weights)]
    return sum(heapq.nlargest(k - 1, A)) - sum(heapq.nsmallest(k - 1, A))

```

## 156. Binary Tree Upside Down_156-2.py
```python
class Solution:
  def upsideDownBinaryTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
    prevRoot = None
    prevRightChild = None

    while root:
      nextRoot = root.left  # Cache the next root.
      root.left = prevRightChild
      prevRightChild = root.right
      root.right = prevRoot
      prevRoot = root  # Record the previous root.
      root = nextRoot  # Update the root.

    return prevRoot

```

## 2460. Apply Operations to an Array_2460-2.py
```python
class Solution:
  def applyOperations(self, nums: List[int]) -> List[int]:
    j = 0
    for i in range(len(nums)):
      if i + 1 < len(nums) and nums[i] == nums[i + 1]:
        nums[i] *= 2
        nums[i + 1] = 0
      if nums[i] > 0:
        nums[i], nums[j] = nums[j], nums[i]
        j += 1
    return nums

```

## 251. Flatten 2D Vector_251.py
```python
class Vector2D:
  def __init__(self, vec: List[List[int]]):
    self.vec = []
    self.i = 0

    for A in vec:
      self.vec += A

  def next(self) -> int:
    ans = self.vec[self.i]
    self.i += 1
    return ans

  def hasNext(self) -> bool:
    return self.i < len(self.vec)

```

## 350. Intersection of Two Arrays II_350.py
```python
class Solution:
  def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
    if len(nums1) > len(nums2):
      return self.intersect(nums2, nums1)

    ans = []
    count = collections.Counter(nums1)

    for num in nums2:
      if count[num] > 0:
        ans.append(num)
        count[num] -= 1

    return ans

```

## 78. Subsets_78.py
```python
class Solution:
  def subsets(self, nums: List[int]) -> List[List[int]]:
    ans = []

    def dfs(s: int, path: List[int]) -> None:
      ans.append(path)

      for i in range(s, len(nums)):
        dfs(i + 1, path + [nums[i]])

    dfs(0, [])
    return ans

```

## 2088. Count Fertile Pyramids in a Land_2088.py
```python
class Solution:
  def countPyramids(self, grid: List[List[int]]) -> int:
    # dp[i][j] := the maximum height of the pyramid for which it is the apex
    def count(dp: List[List[int]]) -> int:
      ans = 0
      for i in range(len(dp) - 2, -1, -1):
        for j in range(1, len(dp[0]) - 1):
          if dp[i][j] == 1:
            dp[i][j] = min(dp[i + 1][j - 1],
                           dp[i + 1][j],
                           dp[i + 1][j + 1]) + 1
            ans += dp[i][j] - 1
      return ans

    return count(deepcopy(grid)[::-1]) + count(grid)

```

## 925. Long Pressed Name_925.py
```python
class Solution:
  def isLongPressedName(self, name: str, typed: str) -> bool:
    i = 0

    for j, t in enumerate(typed):
      if i < len(name) and name[i] == t:
        i += 1
      elif j == 0 or t != typed[j - 1]:
        return False

    return i == len(name)

```

## 2816. Double a Number Represented as a Linked List_2816.py
```python
class Solution:
  def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
    def getCarry(node: Optional[ListNode]) -> Optional[ListNode]:
      val = node.val * 2
      if node.next:
        val += getCarry(node.next)
      node.val = val % 10
      return val // 10

    if getCarry(head) == 1:
      return ListNode(1, head)
    return head

```

## 667. Beautiful Arrangement II_667.py
```python
class Solution:
  def constructArray(self, n: int, k: int) -> List[int]:
    ans = list(range(1, n - k + 1))

    for i in range(k):
      if i % 2 == 0:
        ans.append(n - i // 2)
      else:
        ans.append(n - k + (i + 1) // 2)

    return ans

```

## 1909. Remove One Element to Make the Array Strictly Increasing_1909.py
```python
class Solution:
  def canBeIncreasing(self, nums: List[int]) -> bool:
    removed = False

    for i in range(1, len(nums)):
      if nums[i - 1] >= nums[i]:
        if removed:
          return False
        removed = True  # Remove nums[i - 1].
        if i > 1 and nums[i - 2] >= nums[i]:
          nums[i] = nums[i - 1]  # Remove nums[i] instead.

    return True

```

## 255. Verify Preorder Sequence in Binary Search Tree_255-3.py
```python
class Solution:
  def verifyPreorder(self, preorder: List[int]) -> bool:
    low = -math.inf
    i = -1

    for p in preorder:
      if p < low:
        return False
      while i >= 0 and preorder[i] < p:
        low = preorder[i]
        i -= 1
      i += 1
      preorder[i] = p

    return True

```

## 496. Next Greater Element I_496.py
```python
class Solution:
  def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
    numToNextGreater = {}
    stack = []  # a decreasing stack

    for num in nums2:
      while stack and stack[-1] < num:
        numToNextGreater[stack.pop()] = num
      stack.append(num)

    return [numToNextGreater.get(num, -1) for num in nums1]

```

## 2294. Partition Array Such That Maximum Difference Is K_2294.py
```python
class Solution:
  def partitionArray(self, nums: List[int], k: int) -> int:
    nums.sort()

    ans = 1
    mn = nums[0]

    for i in range(1, len(nums)):
      if mn + k < nums[i]:
        ans += 1
        mn = nums[i]

    return ans

```

## 887. Super Egg Drop_887-3.py
```python
class Solution:
  def superEggDrop(self, k: int, n: int) -> int:
    moves = 0
    dp = [[0] * (k + 1) for _ in range(n + 1)]

    while dp[moves][k] < n:
      moves += 1
      for eggs in range(1, k + 1):
        dp[moves][eggs] = dp[moves - 1][eggs - 1] + \
            dp[moves - 1][eggs] + 1

    return moves

```

## 123. Best Time to Buy and Sell Stock III_123.py
```python
class Solution:
  def maxProfit(self, prices: List[int]) -> int:
    sellTwo = 0
    holdTwo = -math.inf
    sellOne = 0
    holdOne = -math.inf

    for price in prices:
      sellTwo = max(sellTwo, holdTwo + price)
      holdTwo = max(holdTwo, sellOne - price)
      sellOne = max(sellOne, holdOne + price)
      holdOne = max(holdOne, -price)

    return sellTwo

```

## 1053. Previous Permutation With One Swap_1053.py
```python
class Solution:
  def prevPermOpt1(self, arr: List[int]) -> List[int]:
    n = len(arr)
    l = n - 2
    r = n - 1

    while l >= 0 and arr[l] <= arr[l + 1]:
      l -= 1
    if l < 0:
      return arr
    while arr[r] >= arr[l] or arr[r] == arr[r - 1]:
      r -= 1
    arr[l], arr[r] = arr[r], arr[l]

    return arr

```

## 2908. Minimum Sum of Mountain Triplets I_2908.py
```python
class Solution:
  # Same as 2908. Minimum Sum of Mountain Triplets I
  def minimumSum(self, nums: List[int]) -> int:
    ans = math.inf
    minPrefix = list(itertools.accumulate(nums, min))
    minSuffix = list(itertools.accumulate(reversed(nums), min))[::-1]

    for i, num in enumerate(nums):
      if num > minPrefix[i] and num > minSuffix[i]:
        ans = min(ans, num + minPrefix[i] + minSuffix[i])

    return -1 if ans == math.inf else ans

```

## 1259. Handshakes That Don't Cross_1259.py
```python
class Solution:
  def numberOfWays(self, numPeople: int) -> int:
    kMod = 1_000_000_007
    # dp[i] := the number of ways i handshakes could occure s.t. none of the
    # handshakes cross
    dp = [1] + [0] * (numPeople // 2)

    for i in range(1, numPeople // 2 + 1):
      for j in range(i):
        dp[i] += dp[j] * dp[i - 1 - j]
        dp[i] %= kMod

    return dp[numPeople // 2]

```

## 2183. Count Array Pairs Divisible by K_2183.py
```python
class Solution:
  def countPairs(self, nums: List[int], k: int) -> int:
    ans = 0
    gcds = collections.Counter()

    for num in nums:
      gcd_i = math.gcd(num, k)
      for gcd_j, count in gcds.items():
        if gcd_i * gcd_j % k == 0:
          ans += count
      gcds[gcd_i] += 1

    return ans

```

## 1800. Maximum Ascending Subarray Sum_1800.py
```python
class Solution:
  def maxAscendingSum(self, nums: List[int]) -> int:
    ans = 0
    sum = nums[0]

    for i in range(1, len(nums)):
      if nums[i] > nums[i - 1]:
        sum += nums[i]
      else:
        ans = max(ans, sum)
        sum = nums[i]

    return max(ans, sum)

```

## 1925. Count Square Sum Triples_1925.py
```python
class Solution:
  def countTriples(self, n: int) -> int:
    ans = 0
    squared = set()

    for i in range(1, n + 1):
      squared.add(i * i)

    for a in squared:
      for b in squared:
        if a + b in squared:
          ans += 1

    return ans

```

## 2831. Find the Longest Equal Subarray_2831-2.py
```python
class Solution:
  def longestEqualSubarray(self, nums: List[int], k: int) -> int:
    ans = 0
    count = collections.Counter()

    # l and r track the maximum window instead of the valid window.
    l = 0
    for r, num in enumerate(nums):
      count[num] += 1
      ans = max(ans, count[num])
      if r - l + 1 - k > ans:
        count[nums[l]] -= 1
        l += 1

    return ans

```

## 532. K-diff Pairs in an Array_532.py
```python
class Solution:
  def findPairs(self, nums: List[int], k: int) -> int:
    ans = 0
    numToIndex = {num: i for i, num in enumerate(nums)}

    for i, num in enumerate(nums):
      target = num + k
      if target in numToIndex and numToIndex[target] != i:
        ans += 1
        del numToIndex[target]

    return ans

```

## 3127. Make a Square with the Same Color_3127.py
```python
class Solution:
  def canMakeSquare(self, grid: List[List[str]]) -> bool:
    for i in range(2):
      for j in range(2):
        black = 0
        white = 0
        for x in range(2):
          for y in range(2):
            if grid[i + x][j + y] == 'B':
              black += 1
            else:
              white += 1
        if black >= 3 or white >= 3:
          return True
    return False

```

## 2969. Minimum Number of Coins for Fruits II_2969.py
```python
class Solution:
  # Same as 2944. Minimum Number of Coins for Fruits
  def minimumCoins(self, prices: List[int]) -> int:
    n = len(prices)
    # Convert to 0-indexed for easy computation.
    # dp[i] := the minimum number of coins to acquire fruits[i:]
    dp = [math.inf] * n + [0]

    for i in range(n - 1, -1, -1):
      # Convert back to 1-indexed.
      for j in range(i + 1, min((i + 1) * 2 + 1, n + 1)):
        dp[i] = min(dp[i], prices[i] + dp[j])

    return dp[0]

```

## 2873. Maximum Value of an Ordered Triplet I_2873.py
```python
class Solution:
  def maximumTripletValue(self, nums: List[int]) -> int:
    ans = 0
    maxDiff = 0  # max(nums[i] - nums[j])
    maxNum = 0   # max(nums[i])

    for num in nums:
      ans = max(ans, maxDiff * num)         # num := nums[k]
      maxDiff = max(maxDiff, maxNum - num)  # num := nums[j]
      maxNum = max(maxNum, num)             # num := nums[i]

    return ans

```

## 2465. Number of Distinct Averages_2465.py
```python
class Solution:
  def distinctAverages(self, nums: List[int]) -> int:
    n = len(nums)
    sums = set()

    nums.sort()

    for i in range(n // 2):
      sums.add(nums[i] + nums[n - 1 - i])

    return len(sums)

```

## 830. Positions of Large Groups_830.py
```python
class Solution:
  def largeGroupPositions(self, s: str) -> List[List[int]]:
    n = len(s)
    ans = []
    i = 0
    j = 0

    while i < n:
      while j < n and s[j] == s[i]:
        j += 1
      if j - i >= 3:
        ans.append([i, j - 1])
      i = j

    return ans

```

## 2764. is Array a Preorder of Some Binary Tree_2764.py
```python
class Solution:
  def isPreorder(self, nodes: List[List[int]]) -> bool:
    stack = []  # Stores `id`s.

    for id, parentId in nodes:
      if parentId == -1:
        stack.append(id)
        continue
      while stack and stack[-1] != parentId:
        stack.pop()
      if not stack:
        return False
      stack.append(id)

    return True

```

## 2017. Grid Game_2017.py
```python
class Solution:
  def gridGame(self, grid: List[List[int]]) -> int:
    n = len(grid[0])
    ans = math.inf
    sumRow0 = sum(grid[0])
    sumRow1 = 0

    for i in range(n):
      sumRow0 -= grid[0][i]
      ans = min(ans, max(sumRow0, sumRow1))
      sumRow1 += grid[1][i]

    return ans

```

## 278. First Bad Version_278.py
```python
class Solution:
  def firstBadVersion(self, n: int) -> int:
    l = 1
    r = n

    while l < r:
      m = (l + r) >> 1
      if isBadVersion(m):
        r = m
      else:
        l = m + 1

    return l

```

## 2673. Make Costs of Paths Equal in a Binary Tree_2673.py
```python
class Solution:
  def minIncrements(self, n: int, cost: List[int]) -> int:
    ans = 0

    for i in range(n // 2 - 1, -1, -1):
      l = i * 2 + 1
      r = i * 2 + 2
      ans += abs(cost[l] - cost[r])
      # Record the information in the parent from the children. So, there's need to actually
      # update the values in the children.
      cost[i] += max(cost[l], cost[r])

    return ans

```

## 1458. Max Dot Product of Two Subsequences_1458.py
```python
class Solution:
  def maxDotProduct(self, A: List[int], B: List[int]) -> int:
    m = len(A)
    n = len(B)
    # dp[i][j] := the maximum dot product of the two subsequences nums[0..i)
    # and nums2[0..j)
    dp = [[-math.inf] * (n + 1) for _ in range(m + 1)]

    for i in range(m):
      for j in range(n):
        dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j],
                               max(0, dp[i][j]) + A[i] * B[j])

    return dp[m][n]

```

## 2073. Time Needed to Buy Tickets_2073.py
```python
class Solution:
  def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:
    ans = 0

    for i, ticket in enumerate(tickets):
      if i <= k:
        ans += min(ticket, tickets[k])
      else:
        ans += min(ticket, tickets[k] - 1)

    return ans

```

## 645. Set Mismatch_645.py
```python
class Solution:
  def findErrorNums(self, nums: List[int]) -> List[int]:
    for num in nums:
      if nums[abs(num) - 1] < 0:
        duplicate = abs(num)
      else:
        nums[abs(num) - 1] *= -1

    for i, num in enumerate(nums):
      if num > 0:
        return [duplicate, i + 1]

```

## 3196. Maximize Total Cost of Alternating Subarrays_3196-2.py
```python
class Solution:
  def maximumTotalCost(self, nums: List[int]) -> int:
    # A small trick so that we don't need to handle the edge case and can use
    # ranged-based for loop.
    keep = -math.inf  # the maximum cost if the last number is kept
    flip = 0  # the maximum cost if the last number is flipped

    for num in nums:
      keep, flip = max(keep, flip) + num, keep - num

    return max(keep, flip)

```

## 1052. Grumpy Bookstore Owner_1052.py
```python
class Solution:
  def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:
    satisfied = sum(c for i, c in enumerate(customers) if grumpy[i] == 0)
    madeSatisfied = 0
    windowSatisfied = 0

    for i, customer in enumerate(customers):
      if grumpy[i] == 1:
        windowSatisfied += customer
      if i >= X and grumpy[i - X] == 1:
        windowSatisfied -= customers[i - X]
      madeSatisfied = max(madeSatisfied, windowSatisfied)

    return satisfied + madeSatisfied

```

## 1493. Longest Subarray of 1's After Deleting One Element_1493-2.py
```python
class Solution:
  def longestSubarray(self, nums: List[int]) -> int:
    l = 0
    count0 = 0

    for num in nums:
      if num == 0:
        count0 += 1
      if count0 > 1:
        if nums[l] == 0:
          count0 -= 1
        l += 1

    return len(nums) - l - 1

```

## 2885. Rename Columns_2885.py
```python
import pandas as pd


def renameColumns(students: pd.DataFrame) -> pd.DataFrame:
  return students.rename(
      columns={
          "id": "student_id",
          "first": "first_name",
          "last": "last_name",
          "age": "age_in_years",
      }
  )

```

## 844. Backspace String Compare_844.py
```python
class Solution:
  def backspaceCompare(self, s: str, t: str) -> bool:
    def backspace(s: str) -> str:
      stack = []
      for c in s:
        if c != '#':
          stack.append(c)
        elif stack:
          stack.pop()
      return stack

    return backspace(s) == backspace(t)

```

## 560. Subarray Sum Equals K_560.py
```python
class Solution:
  def subarraySum(self, nums: List[int], k: int) -> int:
    ans = 0
    prefix = 0
    count = collections.Counter({0: 1})

    for num in nums:
      prefix += num
      ans += count[prefix - k]
      count[prefix] += 1

    return ans

```

## 1436. Destination City_1436.py
```python
class Solution:
  def destCity(self, paths: List[List[str]]) -> str:
    count = collections.Counter()

    for a, b in paths:
      count[a] += 1

    for a, b in paths:
      if b in count:
        count[b] -= 1
        if count[b] == 0:
          del count[b]
      else:
        return b

```

## 1945. Sum of Digits of String After Convert_1945.py
```python
class Solution:
  def getLucky(self, s: str, k: int) -> int:
    ans = self._convert(s)
    for _ in range(k):
      ans = self._getDigitSum(ans)
    return ans

  def _convert(self, s: str) -> int:
    return int(''.join(str(ord(c) - ord('a') + 1) for c in s))

  def _getDigitSum(self, num: int) -> int:
    return sum(int(digit) for digit in str(num))

```

## 260. Single Number III_260.py
```python
class Solution:
  def singleNumber(self, nums: List[int]) -> List[int]:
    xors = functools.reduce(operator.xor, nums)
    lowbit = xors & -xors
    ans = [0, 0]

    # Seperate `nums` into two groups by `lowbit`.
    for num in nums:
      if num & lowbit:
        ans[0] ^= num
      else:
        ans[1] ^= num

    return ans

```

## 1933. Check if String Is Decomposable Into Value-Equal Substrings_1933.py
```python
class Solution:
  def isDecomposable(self, s: str) -> bool:
    twos = 0

    for _, group in itertools.groupby(s):
      groupLength = len(list(group))
      if groupLength % 3 == 1:
        return False
      if groupLength % 3 == 2:
        twos += 1
        if twos > 1:
          return False

    return twos == 1

```

## 1822. Sign of the Product of an Array_1822.py
```python
class Solution:
  def arraySign(self, nums: List[int]) -> int:
    sign = 1

    for num in nums:
      if num == 0:
        return 0
      if num < 0:
        sign = -sign

    return sign

```

## 2576. Find the Maximum Number of Marked Indices_2576-2.py
```python
class Solution:
  def maxNumOfMarkedIndices(self, nums: List[int]) -> int:
    nums.sort()

    i = 0
    for j in range(len(nums) // 2, len(nums)):
      if 2 * nums[i] <= nums[j]:
        i += 1
        if i == len(nums) // 2:
          break

    return i * 2

```

## 2169. Count Operations to Obtain Zero_2169.py
```python
class Solution:
  def countOperations(self, num1: int, num2: int) -> int:
    ans = 0

    while num1 and num2:
      if num1 < num2:
        num1, num2 = num2, num1
      ans += num1 // num2
      num1 %= num2

    return ans

```

## 1109. Corporate Flight Bookings_1109.py
```python
class Solution:
  def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
    ans = [0] * n

    for booking in bookings:
      ans[booking[0] - 1] += booking[2]
      if booking[1] < n:
        ans[booking[1]] -= booking[2]

    for i in range(1, n):
      ans[i] += ans[i - 1]

    return ans

```

## 82. Remove Duplicates from Sorted List II_82.py
```python
class Solution:
  def deleteDuplicates(self, head: ListNode) -> ListNode:
    dummy = ListNode(0, head)
    prev = dummy

    while head:
      while head.next and head.val == head.next.val:
        head = head.next
      if prev.next == head:
        prev = prev.next
      else:
        prev.next = head.next
      head = head.next

    return dummy.next

```

## 2436. Minimum Split Into Subarrays With GCD Greater Than One_2436.py
```python
class Solution:
  def minimumSplits(self, nums: List[int]) -> int:
    ans = 1
    gcd = nums[0]

    for num in nums:
      newGcd = math.gcd(gcd, num)
      if newGcd > 1:
        gcd = newGcd
      else:
        gcd = num
        ans += 1

    return ans

```

## 1152. Analyze User Website Visit Pattern_1152.py
```python
class Solution:
  def mostVisitedPattern(self, username: List[str], timestamp: List[int], website: List[str]) -> List[str]:
    userToSites = collections.defaultdict(list)

    # Sort websites of each user by timestamp.
    for user, _, site in sorted(zip(username, timestamp, website), key=lambda x: (x[1])):
      userToSites[user].append(site)

    # For each of three websites, count its frequency.
    patternCount = collections.Counter()

    for user, sites in userToSites.items():
      patternCount.update(Counter(set(itertools.combinations(sites, 3))))

    return max(sorted(patternCount), key=patternCount.get)

```

## 1475. Final Prices With a Special Discount in a Shop_1475.py
```python
class Solution:
  def finalPrices(self, prices: List[int]) -> List[int]:
    ans = prices.copy()
    stack = []

    for i, price in enumerate(prices):
      # stack[-1] := i in the problem description.
      while stack and prices[stack[-1]] >= price:
        ans[stack.pop()] -= price
      stack.append(i)

    return ans

```

## 525. Contiguous Array_525.py
```python
class Solution:
  def findMaxLength(self, nums: List[int]) -> int:
    ans = 0
    prefix = 0
    prefixToIndex = {0: -1}

    for i, num in enumerate(nums):
      prefix += 1 if num else -1
      ans = max(ans, i - prefixToIndex.setdefault(prefix, i))

    return ans

```

## 11. Container With Most Water_11.py
```python
class Solution:
  def maxArea(self, height: List[int]) -> int:
    ans = 0
    l = 0
    r = len(height) - 1

    while l < r:
      minHeight = min(height[l], height[r])
      ans = max(ans, minHeight * (r - l))
      if height[l] < height[r]:
        l += 1
      else:
        r -= 1

    return ans

```

## 1071. Greatest Common Divisor of Strings_1071.py
```python
class Solution:
  def gcdOfStrings(self, str1: str, str2: str) -> str:
    def mod(s1: str, s2: str) -> str:
      while s1.startswith(s2):
        s1 = s1[len(s2):]
      return s1

    if len(str1) < len(str2):
      return self.gcdOfStrings(str2, str1)
    if not str1.startswith(str2):
      return ''
    if not str2:
      return str1
    return self.gcdOfStrings(str2, mod(str1, str2))

```

## 2347. Best Poker Hand_2347.py
```python
class Solution:
  def bestHand(self, ranks: List[int], suits: List[str]) -> str:
    if all(suit == suits[0] for suit in suits):
      return 'Flush'

    match max(Counter(ranks).values()):
      case 5 | 4 | 3:
        return 'Three of a Kind'
      case 2:
        return 'Pair'
      case _:
        return 'High Card'

```

## 2470. Number of Subarrays With LCM Equal to K_2470.py
```python
class Solution:
  def subarrayLCM(self, nums: List[int], k: int) -> int:
    ans = 0

    for i, runningLcm in enumerate(nums):
      for j in range(i, len(nums)):
        runningLcm = math.lcm(runningLcm, nums[j])
        if runningLcm > k:
          break
        if runningLcm == k:
          ans += 1

    return ans

```

## 892. Surface Area of 3D Shapes_892.py
```python
class Solution:
  def surfaceArea(self, grid: List[List[int]]) -> int:
    ans = 0

    for i in range(len(grid)):
      for j in range(len(grid)):
        if grid[i][j]:
          ans += grid[i][j] * 4 + 2
        if i > 0:
          ans -= min(grid[i][j], grid[i - 1][j]) * 2
        if j > 0:
          ans -= min(grid[i][j], grid[i][j - 1]) * 2

    return ans

```

## 2525. Categorize Box According to Criteria_2525.py
```python
class Solution:
  def categorizeBox(self, length: int, width: int, height: int, mass: int) -> str:
    isBulky = length >= 10000 or width >= 10000 or height >= 10000 or length * \
        width * height >= 1_000_000_000
    isHeavy = mass >= 100
    if isBulky and isHeavy:
      return 'Both'
    if isBulky:
      return 'Bulky'
    if isHeavy:
      return 'Heavy'
    return 'Neither'

```

## 270. Closest Binary Search Tree Value_270.py
```python
class Solution:
  def closestValue(self, root: Optional[TreeNode], target: float) -> int:
    # If target < root.val, search the left subtree.
    if target < root.val and root.left:
      left = self.closestValue(root.left, target)
      if abs(left - target) <= abs(root.val - target):
        return left

    # If target > root.val, search the right subtree.
    if target > root.val and root.right:
      right = self.closestValue(root.right, target)
      if abs(right - target) < abs(root.val - target):
        return right

    return root.val

```

## 2491. Divide Players Into Teams of Equal Skill_2491.py
```python
class Solution:
  def dividePlayers(self, skill: List[int]) -> int:
    n = len(skill)
    teamSkill = sum(skill) // (n // 2)
    ans = 0
    count = collections.Counter(skill)

    for s, freq in count.items():
      requiredSkill = teamSkill - s
      if count[requiredSkill] != freq:
        return -1
      ans += s * requiredSkill * freq

    return ans // 2

```

## 2216. Minimum Deletions to Make Array Beautiful_2216.py
```python
class Solution:
  def minDeletion(self, nums: List[int]) -> int:
    ans = 0

    for i in range(len(nums) - 1):
      # i - ans := the index after deletion
      if nums[i] == nums[i + 1] and (i - ans) % 2 == 0:
        ans += 1

    # Add one if the length after deletion is odd
    return ans + ((len(nums) - ans) & 1)

```

## 1880. Check if Word Equals Summation of Two Words_1880.py
```python
class Solution:
  def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:
    first = self._getNumber(firstWord)
    second = self._getNumber(secondWord)
    target = self._getNumber(targetWord)
    return first + second == target

  def _getNumber(self, word: str) -> int:
    num = 0
    for c in word:
      num = num * 10 + (ord(c) - ord('a'))
    return num

```

## 3075. Maximize Happiness of Selected Children_3075.py
```python
class Solution:
  def maximumHappinessSum(self, happiness: List[int], k: int) -> int:
    ans = 0
    decremented = 0

    happiness.sort(reverse=True)

    for i in range(k):
      ans += max(0, happiness[i] - decremented)
      decremented += 1

    return ans

```

## 1233. Remove Sub-Folders from the Filesystem_1233.py
```python
class Solution:
  def removeSubfolders(self, folder: List[str]) -> List[str]:
    ans = []
    prev = ""

    folder.sort()

    for f in folder:
      if len(prev) > 0 and f.startswith(prev) and f[len(prev)] == '/':
        continue
      ans.append(f)
      prev = f

    return ans

```

## 2367. Number of Arithmetic Triplets_2367.py
```python
class Solution:
  def arithmeticTriplets(self, nums: List[int], diff: int) -> int:
    kMax = 200
    ans = 0
    count = [False] * (kMax + 1)

    for num in nums:
      if num >= 2 * diff and count[num - diff] and count[num - 2 * diff]:
        ans += 1
      count[num] = True

    return ans

```

## 1663. Smallest String With A Given Numeric Value_1663.py
```python
class Solution:
  def getSmallestString(self, n: int, k: int) -> str:
    ans = []

    for i in range(n):
      remainingLetters = n - 1 - i
      rank = max(1, k - remainingLetters * 26)
      ans.append(chr(ord('a') + rank - 1))
      k -= rank

    return ''.join(ans)

```

## 1360. Number of Days Between Two Dates_1360.py
```python
class Solution:
  def daysBetweenDates(self, date1: str, date2: str) -> int:
    days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

    def isLeapYear(year: int) -> bool:
      return year % 4 == 0 and year % 100 != 0 or year % 400 == 0

    def daysFrom1971(date: str) -> int:
      year, month, day = map(int, date.split('-'))
      return 365 * (year - 1971) + sum(map(isLeapYear, range(1971, year))) + \
          sum(days[:month]) + day + (month > 2 and isLeapYear(year))

    return abs(daysFrom1971(date1) - daysFrom1971(date2))

```

## 2110. Number of Smooth Descent Periods of a Stock_2110.py
```python
class Solution:
  def getDescentPeriods(self, prices: List[int]) -> int:
    ans = 1  # prices[0]
    dp = 1

    for i in range(1, len(prices)):
      if prices[i] == prices[i - 1] - 1:
        dp += 1
      else:
        dp = 1
      ans += dp

    return ans

```

## 2095. Delete the Middle Node of a Linked List_2095.py
```python
class Solution:
  def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:
    dummy = ListNode(0, head)
    slow = dummy
    fast = dummy

    while fast.next and fast.next.next:
      slow = slow.next
      fast = fast.next.next

    # Delete the middle node.
    slow.next = slow.next.next
    return dummy.next

```

## 138. Copy List with Random Pointer_138.py
```python
class Solution:
  def copyRandomList(self, head: 'Node') -> 'Node':
    if not head:
      return None
    if head in self.map:
      return self.map[head]

    newNode = Node(head.val)
    self.map[head] = newNode
    newNode.next = self.copyRandomList(head.next)
    newNode.random = self.copyRandomList(head.random)
    return newNode

  map = {}

```

## 3199. Count Triplets with Even XOR Set Bits I_3199.py
```python
class Solution:
  def tripletCount(self, a: List[int], b: List[int], c: List[int]) -> int:
    evenA, oddA = self._getEvenOddBitCount(a)
    evenB, oddB = self._getEvenOddBitCount(b)
    evenC, oddC = self._getEvenOddBitCount(c)
    return evenA * oddB * oddC + oddA * evenB * oddC + oddA * oddB * evenC + evenA * evenB * evenC

  def _getEvenOddBitCount(self, nums: List[int]) -> Tuple[int, int]:
    """
    Returns the count of numbers in the `nums` arrays that have even number of
    ones and odd number of ones in their binary representation.
    """
    even = sum(num.bit_count() % 2 == 0 for num in nums)
    return (even, len(nums) - even)

```

## 1010. Pairs of Songs With Total Durations Divisible by 60_1010.py
```python
class Solution:
  def numPairsDivisibleBy60(self, time: List[int]) -> int:
    ans = 0
    count = [0] * 60

    for t in time:
      t %= 60
      ans += count[(60 - t) % 60]
      count[t] += 1

    return ans

```

## 1680. Concatenation of Consecutive Binary Numbers_1680.py
```python
class Solution:
  def concatenatedBinary(self, n: int) -> int:
    kMod = 1_000_000_007
    ans = 0

    def numberOfBits(n: int) -> int:
      return int(math.log2(n)) + 1

    for i in range(1, n + 1):
      ans = ((ans << numberOfBits(i)) + i) % kMod

    return ans

```

## 702. Search in a Sorted Array of Unknown Size_702.py
```python
# """
# This is ArrayReader's API interface.
# You should not implement it, or speculate about its implementation
# """
# Class ArrayReader:
#   def get(self, index: int) -> int:

class Solution:
  def search(self, reader: 'ArrayReader', target: int) -> int:
    l = bisect.bisect_left(range(10**4), target,
                           key=lambda m: reader.get(m))
    return l if reader.get(l) == target else -1

```

## 2384. Largest Palindromic Number_2384.py
```python
class Solution:
  def largestPalindromic(self, num: str) -> str:
    count = collections.Counter(num)
    firstHalf = ''.join(count[i] // 2 * i for i in '9876543210').lstrip('0')
    mid = self._getMid(count)
    return (firstHalf + mid + firstHalf[::-1]) or '0'

  def _getMid(self, count: Dict[str, int]) -> str:
    for c in '9876543210':
      if count[c] & 1:
        return c
    return ''

```

## 3205. Maximum Array Hopping Score I_3205.py
```python
class Solution:
  def maxScore(self, nums: List[int]) -> int:
    n = len(nums)
    # dp[i] := the maximum score to jump from index i to n - 1
    dp = [0] * n

    for i in reversed(range(n)):
      for j in range(i + 1, n):
        # Jump from i to j, and then jump from j to n - 1.
        dp[i] = max(dp[i], (j - i) * nums[j] + dp[j])

    return dp[0]

```

## 1422. Maximum Score After Splitting a String_1422.py
```python
class Solution:
  def maxScore(self, s: str) -> int:
    ans = 0
    zeros = 0
    ones = s.count('1')

    for i in range(len(s) - 1):
      if s[i] == '0':
        zeros += 1
      else:
        ones -= 1
      ans = max(ans, zeros + ones)

    return ans

```

## 396. Rotate Function_396.py
```python
class Solution:
  def maxRotateFunction(self, nums: List[int]) -> int:
    f = sum(i * num for i, num in enumerate(nums))
    ans = f
    summ = sum(nums)

    for a in reversed(nums):
      f += summ - len(nums) * a
      ans = max(ans, f)

    return ans

```

## 2971. Find Polygon With the Largest Perimeter_2971.py
```python
class Solution:
  def largestPerimeter(self, nums: List[int]) -> int:
    prefix = sum(nums)

    for num in sorted(nums, reverse=True):
      prefix -= num
      # Let `num` be the longest side. Check if the sum of all the edges with
      # length no longer than `num` > `num``.
      if prefix > num:
        return prefix + num

    return -1

```

## 2414. Length of the Longest Alphabetical Continuous Substring_2414.py
```python
class Solution:
  def longestContinuousSubstring(self, s: str) -> int:
    ans = 1
    runningLen = 1

    for a, b in zip(s, s[1:]):
      if ord(a) + 1 == ord(b):
        runningLen += 1
        ans = max(ans, runningLen)
      else:
        runningLen = 1

    return ans

```

## 3114. Latest Time You Can Obtain After Replacing Characters_3114.py
```python
class Solution:
  # Similar to 1736. Latest Time by Replacing Hidden Digits
  def findLatestTime(self, s: str) -> str:
    ans = list(s)
    if s[0] == '?':
      ans[0] = '1' if s[1] == '?' or s[1] < '2' else '0'
    if s[1] == '?':
      ans[1] = '1' if ans[0] == '1' else '9'
    if s[3] == '?':
      ans[3] = '5'
    if s[4] == '?':
      ans[4] = '9'
    return ''.join(ans)

```

## 634. Find the Derangement of An Array_634.py
```python
class Solution:
  def findDerangement(self, n: int) -> int:
    kMod = 1_000_000_007

    @functools.lru_cache(None)
    def dp(i: int) -> int:
      if i == 0:
        return 1
      if i == 1:
        return 0
      return (i - 1) * (dp(i - 1) + dp(i - 2)) % kMod

    return dp(n)

```

## 3192. Minimum Operations to Make Binary Array Elements Equal to One II_3192.py
```python
class Solution:
  def minOperations(self, nums: List[int]) -> int:
    ans = 0
    target = 1

    for num in nums:
      if num != target:
        ans += 1
        target ^= 1

    return ans

```

## 670. Maximum Swap_670.py
```python
class Solution:
  def maximumSwap(self, num: int) -> int:
    s = list(str(num))
    dict = {c: i for i, c in enumerate(s)}

    for i, c in enumerate(s):
      for digit in reversed(string.digits):
        if digit <= c:
          break
        if digit in dict and dict[digit] > i:
          s[i], s[dict[digit]] = digit, s[i]
          return int(''.join(s))

    return num

```

## 1650. Lowest Common Ancestor of a Binary Tree III_1650.py
```python
class Solution:
  # Same as 160. Intersection of Two Linked Lists
  def lowestCommonAncestor(self, p: 'Node', q: 'Node') -> 'Node':
    a = p
    b = q

    while a != b:
      a = a.parent if a else q
      b = b.parent if b else p

    return a

```

## 2134. Minimum Swaps to Group All 1's Together II_2134.py
```python
class Solution:
  def minSwaps(self, nums: List[int]) -> int:
    n = len(nums)
    k = nums.count(1)
    ones = 0  # the number of ones in the window
    maxOnes = 0  # the maximum number of ones in the window

    for i in range(n * 2):
      if i >= k and nums[i % n - k]:  # Magic in Python :)
        ones -= 1
      if nums[i % n]:
        ones += 1
      maxOnes = max(maxOnes, ones)

    return k - maxOnes

```

## 413. Arithmetic Slices_413-2.py
```python
class Solution:
  def numberOfArithmeticSlices(self, nums: List[int]) -> int:
    ans = 0
    dp = 0

    for i in range(2, len(nums)):
      if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:
        dp += 1
        ans += dp
      else:
        dp = 0

    return ans

```

## 1160. Find Words That Can Be Formed by Characters_1160.py
```python
class Solution:
  def countCharacters(self, words: List[str], chars: str) -> int:
    ans = 0
    count = collections.Counter(chars)

    for word in words:
      tempCount = count.copy()
      for c in word:
        tempCount[c] -= 1
        if tempCount[c] < 0:
          ans -= len(word)
          break
      ans += len(word)

    return ans

```

## 1629. Slowest Key_1629.py
```python
class Solution:
  def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:
    ans = keysPressed[0]
    maxDuration = releaseTimes[0]

    for i in range(1, len(keysPressed)):
      duration = releaseTimes[i] - releaseTimes[i-1]
      if duration > maxDuration or (duration == maxDuration and keysPressed[i] > ans):
        ans = keysPressed[i]
        maxDuration = duration

    return ans

```

## 3208. Alternating Groups II_3208.py
```python
class Solution:
  def numberOfAlternatingGroups(self, colors: List[int], k: int) -> int:
    n = len(colors)
    ans = 0
    alternating = 1

    for i in range(n + k - 2):
      alternating = 1 if colors[i % n] == colors[(i - 1) % n] \
          else alternating + 1
      if alternating >= k:
        ans += 1

    return ans

```

## 769. Max Chunks To Make Sorted_769.py
```python
class Solution:
  def maxChunksToSorted(self, arr: List[int]) -> int:
    ans = 0
    mx = -math.inf

    for i, a in enumerate(arr):
      mx = max(mx, a)
      if mx == i:
        ans += 1

    return ans

```

## 2785. Sort Vowels in a String_2785.py
```python
class Solution:
  def sortVowels(self, s: str) -> str:
    kVowels = 'aeiouAEIOU'
    ans = []
    vowels = sorted([c for c in s if c in kVowels])

    i = 0  # vowels' index
    for c in s:
      if c in kVowels:
        ans.append(vowels[i])
        i += 1
      else:
        ans.append(c)

    return ''.join(ans)

```

## 705. Design HashSet_705.py
```python
class MyHashSet:
  def __init__(self):
    self.set = [False] * 1000001

  def add(self, key: int) -> None:
    self.set[key] = True

  def remove(self, key: int) -> None:
    self.set[key] = False

  def contains(self, key: int) -> bool:
    return self.set[key]

```

## 1647. Minimum Deletions to Make Character Frequencies Unique_1647.py
```python
class Solution:
  def minDeletions(self, s: str) -> int:
    ans = 0
    count = collections.Counter(s)
    usedFreq = set()

    for freq in count.values():
      while freq > 0 and freq in usedFreq:
        freq -= 1  # Delete ('a' + i).
        ans += 1
      usedFreq.add(freq)

    return ans

```

## 1624. Largest Substring Between Two Equal Characters_1624.py
```python
class Solution:
  def maxLengthBetweenEqualCharacters(self, s: str) -> int:
    ans = -1
    lastSeen = {}

    for i, c in enumerate(s):
      if c not in lastSeen:
        lastSeen[c] = i
      else:
        ans = max(ans, i - lastSeen[c] - 1)

    return ans

```

## 3094. Guess the Number Using Bitwise Questions II_3094.py
```python
# Definition of commonBits API.
# def commonBits(num: int) -> int:

class Solution:
  def findNumber(self) -> int:
    ans = 0
    sameCount = commonBits(0)

    for i in range(31):
      if commonBits(1 << i) > sameCount:
        ans |= 1 << i
      commonBits(1 << i)  # Revert the XOR.

    return ans

```

## 503. Next Greater Element II_503.py
```python
class Solution:
  def nextGreaterElements(self, nums: List[int]) -> List[int]:
    n = len(nums)
    ans = [-1] * n
    stack = []  # a decreasing stack storing indices

    for i in range(n * 2):
      num = nums[i % n]
      while stack and nums[stack[-1]] < num:
        ans[stack.pop()] = num
      if i < n:
        stack.append(i)

    return ans

```

## 1680. Concatenation of Consecutive Binary Numbers_1680-2.py
```python
class Solution:
  def concatenatedBinary(self, n: int) -> int:
    kMod = 1_000_000_007
    ans = 0
    numberOfBits = 0

    for i in range(1, n + 1):
      if i.bit_count() == 1:
        numberOfBits += 1
      ans = ((ans << numberOfBits) + i) % kMod

    return ans

```

## 2249. Count Lattice Points Inside a Circle_2249-2.py
```python
class Solution:
  def countLatticePoints(self, circles: List[List[int]]) -> int:
    points = set()

    # dx := relative to x
    # dy := relative to y
    # So, dx^2 + dy^2 = r^2.
    for x, y, r in circles:
      for dx in range(-r, r + 1):
        yMax = int((r**2 - dx**2)**0.5)
        for dy in range(-yMax, yMax + 1):
          points.add((x + dx, y + dy))

    return len(points)

```

## 87. Scramble String_87.py
```python
class Solution:
  @functools.lru_cache(None)
  def isScramble(self, s1: str, s2: str) -> bool:
    if s1 == s2:
      return True
    if collections.Counter(s1) != collections.Counter(s2):
      return False

    for i in range(1, len(s1)):
      if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):
        return True
      if self.isScramble(s1[:i], s2[len(s2) - i:]) and self.isScramble(s1[i:], s2[:len(s2) - i]):
        return True

    return False

```

## 544. Output Contest Matches_544.py
```python
class Solution:
  def findContestMatch(self, n: int) -> str:
    def generateMatches(matches: List[str]) -> str:
      if len(matches) == 1:
        return matches[0]

      nextMatches = []

      for i in range(len(matches) // 2):
        nextMatches.append(
            '(' + matches[i] + ',' + matches[len(matches) - 1 - i] + ')')

      return generateMatches(nextMatches)

    return generateMatches([str(i + 1) for i in range(n)])

```

## 1154. Day of the Year_1154.py
```python
class Solution:
  def dayOfYear(self, date: str) -> int:
    def isLeapYear(year: int) -> bool:
      return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0

    year = int(date[:4])
    month = int(date[5:7])
    day = int(date[8:])
    days = [31, 29 if isLeapYear(
        year) else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

    return sum(days[:month - 1]) + day

```

## 1039. Minimum Score Triangulation of Polygon_1039.py
```python
class Solution:
  def minScoreTriangulation(self, values: List[int]) -> int:
    n = len(values)
    dp = [[0] * n for _ in range(n)]

    for j in range(2, n):
      for i in range(j - 2, -1, -1):
        dp[i][j] = math.inf
        for k in range(i + 1, j):
          dp[i][j] = min(dp[i][j],
                         dp[i][k] + values[i] * values[k] * values[j] + dp[k][j])

    return dp[0][n - 1]

```

## 2780. Minimum Index of a Valid Split_2780.py
```python
class Solution:
  def minimumIndex(self, nums: List[int]) -> int:
    count1 = collections.Counter()
    count2 = collections.Counter(nums)

    for i, num in enumerate(nums):
      count1[num] = count1[num] + 1
      count2[num] = count2[num] - 1
      if count1[num] * 2 > i + 1 and count2[num] * 2 > len(nums) - i - 1:
        return i

    return -1

```

## 101. Symmetric Tree_101.py
```python
class Solution:
  def isSymmetric(self, root: Optional[TreeNode]) -> bool:
    def isSymmetric(p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
      if not p or not q:
        return p == q

      return p.val == q.val and \
          isSymmetric(p.left, q.right) and \
          isSymmetric(p.right, q.left)

    return isSymmetric(root, root)

```

## 1035. Uncrossed Lines_1035.py
```python
class Solution:
  def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
    m = len(nums1)
    n = len(nums2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
      for j in range(1, n + 1):
        dp[i][j] = dp[i - 1][j - 1] + 1 \
            if nums1[i - 1] == nums2[j - 1] \
            else max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]

```

## 1920. Build Array from Permutation_1920.py
```python
class Solution:
  def buildArray(self, nums: List[int]) -> List[int]:
    n = len(nums)

    for i, num in enumerate(nums):
      nums[i] += n * (nums[num] % n)

    for i in range(n):
      nums[i] //= n

    return nums

```

## 378. Kth Smallest Element in a Sorted Matrix_378-2.py
```python
class Solution:
  def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
    def numsNoGreaterThan(m: int) -> int:
      count = 0
      j = len(matrix[0]) - 1
      # For each row, find the first index j s.t. row[j] <= m s.t. the number of
      # numbers <= m for this row will be j + 1.
      for row in matrix:
        while j >= 0 and row[j] > m:
          j -= 1
        count += j + 1
      return count

    return bisect.bisect_left(range(matrix[0][0], matrix[-1][-1]), k,
                              key=lambda m: numsNoGreaterThan(m)) + matrix[0][0]

```

## 2243. Calculate Digit Sum of a String_2243.py
```python
class Solution:
  def digitSum(self, s: str, k: int) -> str:
    while len(s) > k:
      next = []
      for i in range(0, len(s), k):
        summ = 0
        for j in range(i, min(len(s), i + k)):
          summ += ord(s[j]) - ord('0')
        next.append(str(summ))
      s = ''.join(next)
    return s

```

## 2401. Longest Nice Subarray_2401.py
```python
class Solution:
  def longestNiceSubarray(self, nums: List[int]) -> int:
    ans = 0
    used = 0

    l = 0
    for r, num in enumerate(nums):
      while used & num:
        used ^= nums[l]
        l += 1
      used |= num
      ans = max(ans, r - l + 1)

    return ans

```

## 1716. Calculate Money in Leetcode Bank_1716.py
```python
class Solution:
  def totalMoney(self, n: int) -> int:
    def trapezoid(a: int, b: int) -> int:
      """Returns sum(a..b)."""
      return (a + b) * (b - a + 1) // 2

    weeks = n // 7
    firstWeek = trapezoid(1, 7)
    lastFullWeek = trapezoid(1 + weeks - 1, 7 + weeks - 1)
    remainingDays = trapezoid(1 + weeks, n % 7 + weeks)
    return (firstWeek + lastFullWeek) * weeks // 2 + remainingDays

```

## 2125. Number of Laser Beams in a Bank_2125.py
```python
class Solution:
  def numberOfBeams(self, bank: List[str]) -> int:
    ans = 0
    prevOnes = 0

    for row in bank:
      ones = row.count('1')
      if ones:
        ans += prevOnes * ones
        prevOnes = ones

    return ans

```

## 829. Consecutive Numbers Sum_829.py
```python
class Solution:
  def consecutiveNumbersSum(self, n: int) -> int:
    ans = 0
    i = 1
    triangleNum = 1
    while triangleNum <= n:
      if (n - triangleNum) % i == 0:
        ans += 1
      i += 1
      triangleNum += i
    return ans

```

## 2509. Cycle Length Queries in a Tree_2509.py
```python
class Solution:
  def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:
    def getCycleLength(a: int, b: int):
      cycleLength = 1
      while a != b:
        if a > b:
          a //= 2
        else:
          b //= 2
        cycleLength += 1
      return cycleLength

    return [getCycleLength(*query) for query in queries]

```

## 1427. Perform String Shifts_1427.py
```python
class Solution:
  def stringShift(self, s: str, shift: List[List[int]]) -> str:
    move = 0

    for direction, amount in shift:
      if direction == 0:
        move -= amount
      else:
        move += amount

    move %= len(s)
    return s[-move:] + s[:-move]

```

## 118. Pascal's Triangle_118.py
```python
class Solution:
  def generate(self, numRows: int) -> List[List[int]]:
    ans = []

    for i in range(numRows):
      ans.append([1] * (i + 1))

    for i in range(2, numRows):
      for j in range(1, len(ans[i]) - 1):
        ans[i][j] = ans[i - 1][j - 1] + ans[i - 1][j]

    return ans

```

## 2373. Largest Local Values in a Matrix_2373.py
```python
class Solution:
  def largestLocal(self, grid: List[List[int]]) -> List[List[int]]:
    n = len(grid)
    ans = [[0] * (n - 2) for _ in range(n - 2)]

    for i in range(n - 2):
      for j in range(n - 2):
        for x in range(i, i + 3):
          for y in range(j, j + 3):
            ans[i][j] = max(ans[i][j], grid[x][y])

    return ans

```

## 2526. Find Consecutive Integers from a Data Stream_2526.py
```python
class DataStream:
  def __init__(self, value: int, k: int):
    self.value = value
    self.k = k
    self.q = deque()
    self.count = 0

  def consec(self, num: int) -> bool:
    if len(self.q) == self.k and self.q.popleft() == self.value:
      self.count -= 1
    if num == self.value:
      self.count += 1
    self.q.append(num)
    return self.count == self.k

```

## 485. Max Consecutive Ones_485.py
```python
class Solution:
  def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
    ans = 0
    summ = 0

    for num in nums:
      if num == 0:
        summ = 0
      else:
        summ += num
        ans = max(ans, summ)

    return ans

```

## 3138. Minimum Length of Anagram Concatenation_3138.py
```python
class Solution:
  def minAnagramLength(self, s: str) -> int:
    n = len(s)
    for k in range(1, n + 1):
      if n % k == 0 and self._canFormAnagram(s, k):
        return k
    return n

  def _canFormAnagram(self, s: str, k: int) -> bool:
    """Returns True if we can concatenate an anagram of length k to s."""
    anagramCount = collections.Counter(s[:k])
    return all(collections.Counter(s[i:i + k]) == anagramCount
               for i in range(k, len(s), k))

```

## 2544. Alternating Digit Sum_2544.py
```python
class Solution:
  def alternateDigitSum(self, n: int) -> int:
    ans = 0
    sign = 1

    while n > 0:
      sign *= -1
      ans += n % 10 * sign
      n //= 10

    return sign * ans

```

## 2366. Minimum Replacements to Sort the Array_2366.py
```python
class Solution:
  def minimumReplacement(self, nums: List[int]) -> int:
    ans = 0
    mx = nums[-1]

    for i in range(len(nums) - 2, -1, -1):
      ops = (nums[i] - 1) // mx
      ans += ops
      mx = nums[i] // (ops + 1)

    return ans

```

## 2053. Kth Distinct String in an Array_2053.py
```python
class Solution:
  def kthDistinct(self, arr: List[str], k: int) -> str:
    count = collections.Counter(arr)

    for a in arr:
      if count[a] == 1:
        k -= 1
        if k == 0:
          return a

    return ''

```

## 2075. Decode the Slanted Ciphertext_2075-2.py
```python
class Solution:
  def decodeCiphertext(self, encodedText: str, rows: int) -> str:
    n = len(encodedText)
    cols = n // rows

    ans = []

    for j in range(cols):
      for i in range(j, n, cols + 1):
        ans.append(encodedText[i])

    return ''.join(ans).rstrip()

```

## 2007. Find Original Array From Doubled Array_2007.py
```python
class Solution:
  def findOriginalArray(self, changed: List[int]) -> List[int]:
    ans = []
    q = collections.deque()

    for num in sorted(changed):
      if q and num == q[0]:
        q.popleft()
      else:
        q.append(num * 2)
        ans.append(num)

    return [] if q else ans

```

## 110. Balanced Binary Tree_110.py
```python
class Solution:
  def isBalanced(self, root: Optional[TreeNode]) -> bool:
    if not root:
      return True

    def maxDepth(root: Optional[TreeNode]) -> int:
      if not root:
        return 0
      return 1 + max(maxDepth(root.left), maxDepth(root.right))

    return abs(maxDepth(root.left) - maxDepth(root.right)) <= 1 and \
        self.isBalanced(root.left) and self.isBalanced(root.right)

```

## 540. Single Element in a Sorted Array_540.py
```python
class Solution:
  def singleNonDuplicate(self, nums: List[int]) -> int:
    l = 0
    r = len(nums) - 1

    while l < r:
      m = (l + r) // 2
      if m % 2 == 1:
        m -= 1
      if nums[m] == nums[m + 1]:
        l = m + 2
      else:
        r = m

    return nums[l]

```

## 1186. Maximum Subarray Sum with One Deletion_1186.py
```python
class Solution:
  # Very similar to 53. Maximum Subarray
  def maximumSum(self, arr: List[int]) -> int:
    # dp[0][i] := the maximum sum subarray ending in i (no deletion)
    # dp[1][i] := the maximum sum subarray ending in i (at most 1 deletion)
    dp = [[0] * len(arr) for _ in range(2)]

    dp[0][0] = arr[0]
    dp[1][0] = arr[0]
    for i in range(1, len(arr)):
      dp[0][i] = max(arr[i], dp[0][i - 1] + arr[i])
      dp[1][i] = max(arr[i], dp[1][i - 1] + arr[i], dp[0][i - 1])

    return max(dp[1])

```

## 690. Employee Importance_690.py
```python
class Solution:
  def getImportance(self, employees: List['Employee'], id: int) -> int:
    idToEmployee = {employee.id: employee for employee in employees}

    def dfs(id: int) -> int:
      values = idToEmployee[id].importance
      for subId in idToEmployee[id].subordinates:
        values += dfs(subId)
      return values

    return dfs(id)

```

## 2028. Find Missing Observations_2028.py
```python
class Solution:
  def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:
    targetSum = (len(rolls) + n) * mean
    missingSum = targetSum - sum(rolls)
    if missingSum > n * 6 or missingSum < n:
      return []

    ans = [missingSum // n] * n
    for i in range(missingSum % n):
      ans[i] += 1

    return ans

```

## 1855. Maximum Distance Between a Pair of Values_1855-2.py
```python
class Solution:
  def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
    i = 0
    j = 0

    while i < len(nums1) and j < len(nums2):
      if nums1[i] > nums2[j]:
        i += 1
      j += 1

    return 0 if i == j else j - i - 1

```

## 1788. Maximize the Beauty of the Garden_1788.py
```python
class Solution:
  def maximumBeauty(self, flowers: List[int]) -> int:
    ans = -math.inf
    prefix = 0
    flowerToPrefix = collections.defaultdict(int)

    for flower in flowers:
      if flower in flowerToPrefix:
        ans = max(ans, prefix - flowerToPrefix[flower] + flower * 2)
      prefix += max(0, flower)
      flowerToPrefix.setdefault(flower, prefix)

    return ans

```

## 2323. Find Minimum Time to Finish All Jobs II_2323.py
```python
class Solution:
  def minimumTime(self, jobs: List[int], workers: List[int]) -> int:
    ans = 0

    jobs.sort()
    workers.sort()

    for job, worker in zip(jobs, workers):
      ans = max(ans, (job - 1) // worker + 1)

    return ans

```

## 230. Kth Smallest Element in a BST_230.py
```python
class Solution:
  def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
    def countNodes(root: Optional[TreeNode]) -> int:
      if not root:
        return 0
      return 1 + countNodes(root.left) + countNodes(root.right)

    leftCount = countNodes(root.left)

    if leftCount == k - 1:
      return root.val
    if leftCount >= k:
      return self.kthSmallest(root.left, k)
    return self.kthSmallest(root.right, k - 1 - leftCount)  # leftCount < k

```

## 1180. Count Substrings with Only One Distinct Letter_1180.py
```python
class Solution:
  def countLetters(self, s: str) -> int:
    ans = 0
    dp = 0  # the length of the running letter
    letter = '@'  # the running letter

    for c in s:
      if c == letter:
        dp += 1
      else:
        dp = 1
        letter = c
      ans += dp  # Add the number of substrings ending in the current letter.

    return ans

```

## 2038. Remove Colored Pieces if Both Neighbors are the Same Color_2038.py
```python
class Solution:
  def winnerOfGame(self, colors: str) -> bool:
    countAAA = 0
    countBBB = 0

    for a, b, c in zip(colors, colors[1:], colors[2:]):
      if 'A' == a == b == c:
        countAAA += 1
      elif 'B' == a == b == c:
        countBBB += 1

    return countAAA > countBBB

```

## 325. Maximum Size Subarray Sum Equals k_325.py
```python
class Solution:
  def maxSubArrayLen(self, nums: List[int], k: int) -> int:
    ans = 0
    prefix = 0
    prefixToIndex = {0: -1}

    for i, num in enumerate(nums):
      prefix += num
      target = prefix - k
      if target in prefixToIndex:
        ans = max(ans, i - prefixToIndex[target])
      if prefix not in prefixToIndex:
        prefixToIndex[prefix] = i

    return ans

```

## 2779. Maximum Beauty of an Array After Applying Operation_2779.py
```python
class Solution:
  def maximumBeauty(self, nums: List[int], k: int) -> int:
    ans = 0

    nums.sort()

    l = 0
    for r in range(len(nums)):
      while nums[r] - nums[l] > 2 * k:
        l += 1
      ans = max(ans, r - l + 1)

    return ans

```

## 1856. Maximum Subarray Min-Product_1856.py
```python
class Solution:
  def maxSumMinProduct(self, nums: List[int]) -> int:
    ans = 0
    stack = []
    prefix = [0] + list(itertools.accumulate(nums))

    for i in range(len(nums) + 1):
      while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):
        minVal = nums[stack.pop()]
        summ = prefix[i] - prefix[stack[-1] + 1] if stack else prefix[i]
        ans = max(ans, minVal * summ)
      stack.append(i)

    return ans % int(1e9 + 7)

```

## 169. Majority Element_169.py
```python
class Solution:
  def majorityElement(self, nums: List[int]) -> int:
    ans = None
    count = 0

    for num in nums:
      if count == 0:
        ans = num
      count += (1 if num == ans else -1)

    return ans

```

## 2457. Minimum Addition to Make Integer Beautiful_2457.py
```python
class Solution:
  def makeIntegerBeautiful(self, n: int, target: int) -> int:
    ans = 0
    power = 1

    # e.g. n = 123. After tunning off the last bit by adding 7, n = 130.
    # Effectively, we can think n as 13. That's why we do n = (n / 10) + 1.
    while sum(map(int, str(n))) > target:
      # the cost to turn off the last digit
      ans += power * (10 - n % 10)
      n = n // 10 + 1
      power *= 10

    return ans

```

## 2108. Find First Palindromic String in the Array_2108.py
```python
class Solution:
  def firstPalindrome(self, words: List[str]) -> str:
    def isPalindrome(s: str) -> bool:
      i = 0
      j = len(s) - 1
      while i < j:
        if s[i] != s[j]:
          return False
        i += 1
        j -= 1
      return True
    return next((word for word in words if isPalindrome(word)), '')

```

## 2958. Length of Longest Subarray With at Most K Frequency_2958.py
```python
class Solution:
  def maxSubarrayLength(self, nums: List[int], k: int) -> int:
    ans = 0
    count = collections.Counter()

    l = 0
    for r, num in enumerate(nums):
      count[num] += 1
      while count[num] == k + 1:
        count[nums[l]] -= 1
        l += 1
      ans = max(ans, r - l + 1)

    return ans

```

## 2743. Count Substrings Without Repeating Character_2743.py
```python
class Solution:
  def numberOfSpecialSubstrings(self, s: str) -> int:
    ans = 0
    count = collections.Counter()

    l = 0
    for r, c in enumerate(s):
      count[c] += 1
      while count[c] == 2:
        count[s[l]] -= 1
        l += 1
      ans += r - l + 1

    return ans

```

## 2789. Largest Element in an Array after Merge Operations_2789.py
```python
class Solution:
  def maxArrayValue(self, nums: List[int]) -> int:
    ans = nums[-1]

    for i in range(len(nums) - 2, -1, -1):
      if nums[i] > ans:
        ans = nums[i]
      else:
        ans += nums[i]

    return ans

```

## 3174. Clear Digits_3174.py
```python
class Solution:
  def clearDigits(self, s: str) -> str:
    ans = []

    for c in s:
      if c.isdigit():
        # Since `ans` only contains non-digit characters, removing the last
        # character is equivalent to deleting the closest non-digit character.
        ans.pop()
      else:
        ans.append(c)

    return ''.join(ans)

```

## 1614. Maximum Nesting Depth of the Parentheses_1614.py
```python
class Solution:
  def maxDepth(self, s: str) -> int:
    ans = 0
    opened = 0

    for c in s:
      if c == '(':
        opened += 1
        ans = max(ans, opened)
      elif c == ')':
        opened -= 1

    return ans

```

## 472. Concatenated Words_472.py
```python
class Solution:
  def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
    wordSet = set(words)

    @functools.lru_cache(None)
    def isConcat(word: str) -> bool:
      for i in range(1, len(word)):
        prefix = word[:i]
        suffix = word[i:]
        if prefix in wordSet and (suffix in wordSet or isConcat(suffix)):
          return True

      return False

    return [word for word in words if isConcat(word)]

```

## 430. Flatten a Multilevel Doubly Linked List_430.py
```python
class Solution:
  def flatten(self, head: 'Node') -> 'Node':
    def flatten(head: 'Node', rest: 'Node') -> 'Node':
      if not head:
        return rest

      head.next = flatten(head.child, flatten(head.next, rest))
      if head.next:
        head.next.prev = head
      head.child = None
      return head

    return flatten(head, None)

```

## 2178. Maximum Split of Positive Even Integers_2178.py
```python
class Solution:
  def maximumEvenSplit(self, finalSum: int) -> List[int]:
    if finalSum % 2 == 1:
      return []

    ans = []
    needSum = finalSum
    even = 2

    while needSum - even >= even + 2:
      ans.append(even)
      needSum -= even
      even += 2

    return ans + [needSum]

```

## 2406. Divide Intervals Into Minimum Number of Groups_2406.py
```python
class Solution:
  # Similar to 253. Meeting Rooms II
  def minGroups(self, intervals: List[List[int]]) -> int:
    minHeap = []  # Stores `right`s.

    for left, right in sorted(intervals):
      if minHeap and left > minHeap[0]:
        # There is no overlaps, so we can reuse the same group.
        heapq.heappop(minHeap)
      heapq.heappush(minHeap, right)

    return len(minHeap)

```

## 2042. Check if Numbers Are Ascending in a Sentence_2042.py
```python
class Solution:
  def areNumbersAscending(self, s: str) -> bool:
    prev = 0

    for token in s.split():
      if token.isdigit():
        num = int(token)
        if num <= prev:
          return False
        prev = num

    return True

```

## 1328. Break a Palindrome_1328.py
```python
class Solution:
  def breakPalindrome(self, palindrome: str) -> str:
    if len(palindrome) == 1:
      return ''

    ans = list(palindrome)

    for i in range(len(palindrome) // 2):
      if palindrome[i] != 'a':
        ans[i] = 'a'
        return ''.join(ans)

    ans[-1] = 'b'
    return ''.join(ans)

```

## 868. Binary Gap_868.py
```python
class Solution:
  def binaryGap(self, n: int) -> int:
    ans = 0
    d = -32  # the distance between any two 1s

    while n:
      if n % 2 == 1:
        ans = max(ans, d)
        d = 0
      n //= 2
      d += 1

    return ans

```

## 1653. Minimum Deletions to Make String Balanced_1653.py
```python
class Solution:
  # Same as 926. Flip String to Monotone Increasing
  def minimumDeletions(self, s: str) -> int:
    dp = 0  # the number of characters to be deleted to make subso far balanced
    countB = 0

    for c in s:
      if c == 'a':
        # 1. Delete 'a'.
        # 2. Keep 'a' and delete the previous 'b's.
        dp = min(dp + 1, countB)
      else:
        countB += 1

    return dp

```

## 2652. Sum Multiples_2652-2.py
```python
class Solution:
  def sumOfMultiples(self, n: int) -> int:
    # Returns the sum of multiples of value in [1, n].
    def sumOfMultiples(value: int) -> int:
      lo = value
      hi = (n // value) * value
      count = (hi - lo) // value + 1
      return (lo + hi) * count // 2

    return sumOfMultiples(3) + sumOfMultiples(5) + sumOfMultiples(7) \
        - (sumOfMultiples(15) + sumOfMultiples(21) + sumOfMultiples(35)) \
        + sumOfMultiples(105)

```

## 2189. Number of Ways to Build House of Cards_2189.py
```python
class Solution:
  def houseOfCards(self, n: int) -> int:
    # dp[i] := the number of valid result for i cards
    dp = [1] + [0] * n

    for baseCards in range(2, n + 1, 3):
      for i in range(n, baseCards - 1, -1):
        # Use `baseCards` as the base, so we're left with `i - baseCards` cards.
        dp[i] += dp[i - baseCards]

    return dp[n]

```

## 3191. Minimum Operations to Make Binary Array Elements Equal to One I_3191.py
```python
class Solution:
  def minOperations(self, nums: List[int]) -> int:
    ans = 0

    for i in range(len(nums) - 2):
      if nums[i] == 0:
        nums[i + 1] ^= 1
        nums[i + 2] ^= 1
        ans += 1

    return -1 if nums[-1] == 0 or nums[-2] == 0 else ans

```

## 2966. Divide Array Into Arrays With Max Difference_2966.py
```python
class Solution:
  def divideArray(self, nums: List[int], k: int) -> List[List[int]]:
    ans = []

    nums.sort()

    for i in range(2, len(nums), 3):
      if nums[i] - nums[i - 2] > k:
        return []
      ans.append([nums[i - 2], nums[i - 1], nums[i]])

    return ans

```

## 1415. The k-th Lexicographical String of All Happy Strings of Length n_1415.py
```python
class Solution:
  def getHappyString(self, n: int, k: int) -> str:
    nextLetters = {'a': 'bc', 'b': 'ac', 'c': 'ab'}
    q = collections.deque(['a', 'b', 'c'])

    while len(q[0]) != n:
      u = q.popleft()
      for nextLetter in nextLetters[u[-1]]:
        q.append(u + nextLetter)

    return '' if len(q) < k else q[k - 1]

```

## 1300. Sum of Mutated Array Closest to Target_1300.py
```python
class Solution:
  def findBestValue(self, arr: List[int], target: int) -> int:
    prefix = 0

    arr.sort()

    for i, a in enumerate(arr):
      ans = round((target - prefix) / (len(arr) - i))
      if ans <= a:
        return ans
      prefix += a

    return arr[-1]

```

## 419. Battleships in a Board_419.py
```python
class Solution:
  def countBattleships(self, board: List[List[str]]) -> int:
    ans = 0

    for i, row in enumerate(board):
      for j, cell in enumerate(row):
        if cell == '.':
          continue
        if i > 0 and board[i - 1][j] == 'X':
          continue
        if j > 0 and board[i][j - 1] == 'X':
          continue
        ans += 1

    return ans

```

## 2592. Maximize Greatness of an Array_2592.py
```python
class Solution:
  def maximizeGreatness(self, nums: List[int]) -> int:
    ans = 0

    nums.sort()

    for num in nums:
      if num > nums[ans]:
        ans += 1

    return ans

```

## 331. Verify Preorder Serialization of a Binary Tree_331.py
```python
class Solution:
  def isValidSerialization(self, preorder: str) -> bool:
    degree = 1  # out-degree (children) - in-degree (parent)

    for node in preorder.split(','):
      degree -= 1
      if degree < 0:
        return False
      if node != '#':
        degree += 2

    return degree == 0

```

## 1186. Maximum Subarray Sum with One Deletion_1186-2.py
```python
class Solution:
  # Very similar to 53. Maximum Subarray
  def maximumSum(self, arr: List[int]) -> int:
    ans = -math.inf
    zero = -math.inf  # no deletion
    one = -math.inf   # <= 1 deletion

    for a in arr:
      one = max(a, one + a, zero)
      zero = max(a, zero + a)
      ans = max(ans, one)

    return ans

```

## 1927. Sum Game_1927.py
```python
class Solution:
  def sumGame(self, num: str) -> bool:
    n = len(num)
    ans = 0.0

    def getExpectation(c: str) -> float:
      return 4.5 if c == '?' else ord(c) - ord('0')

    for i in range(n // 2):
      ans += getExpectation(num[i])

    for i in range(n // 2, n):
      ans -= getExpectation(num[i])

    return ans != 0.0

```

## 1904. The Number of Full Rounds You Have Played_1904.py
```python
class Solution:
  def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:
    start = self._getMinutes(loginTime)
    finish = self._getMinutes(logoutTime)
    if start > finish:
      finish += 60 * 24

    return max(0, finish // 15 - (start + 14) // 15)

  def _getMinutes(self, time: str) -> int:
    h, m = map(int, time.split(':'))
    return 60 * h + m

```

## 2610. Convert an Array Into a 2D Array With Conditions_2610.py
```python
class Solution:
  def findMatrix(self, nums: List[int]) -> List[List[int]]:
    # The number of rows we need equals the maximum frequency.
    ans = []
    count = [0] * (len(nums) + 1)

    for num in nums:
      count[num] += 1
      # Construct `ans` on demand.
      if count[num] > len(ans):
        ans.append([])
      ans[count[num] - 1].append(num)

    return ans

```

## 1547. Minimum Cost to Cut a Stick_1547.py
```python
class Solution:
  def minCost(self, n: int, cuts: List[int]) -> int:
    A = sorted([0] + cuts + [n])

    @functools.lru_cache(None)
    def dp(i, j):
      if j - i <= 1:
        return 0

      return min(A[j] - A[i] + dp(i, k) + dp(k, j) for k in range(i + 1, j))

    return dp(0, len(A) - 1)

```

## 2013. Detect Squares_2013.py
```python
class DetectSquares:
  def __init__(self):
    self.pointCount = collections.Counter()

  def add(self, point: List[int]) -> None:
    self.pointCount[tuple(point)] += 1

  def count(self, point: List[int]) -> int:
    x1, y1 = point
    ans = 0
    for (x3, y3), c in self.pointCount.items():
      if x1 != x3 and abs(x1 - x3) == abs(y1 - y3):
        ans += c * self.pointCount[(x1, y3)] * self.pointCount[(x3, y1)]
    return ans

```

## 566. Reshape the Matrix_566.py
```python
class Solution:
  def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:
    if nums == [] or r * c != len(nums) * len(nums[0]):
      return nums

    ans = [[0 for j in range(c)] for i in range(r)]
    k = 0

    for row in nums:
      for num in row:
        ans[k // c][k % c] = num
        k += 1

    return ans

```

## 1272. Remove Interval_1272.py
```python
class Solution:
  def removeInterval(self, intervals: List[List[int]], toBeRemoved: List[int]) -> List[List[int]]:
    ans = []

    for a, b in intervals:
      if a >= toBeRemoved[1] or b <= toBeRemoved[0]:
        ans.append([a, b])
      else:  # a < toBeRemoved[1] and b > toBeRemoved[0]
        if a < toBeRemoved[0]:
          ans.append([a, toBeRemoved[0]])
        if b > toBeRemoved[1]:
          ans.append([toBeRemoved[1], b])

    return ans

```

## 2438. Range Product Queries of Powers_2438.py
```python
class Solution:
  def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:
    kMod = 1_000_000_007
    kMaxBit = 30
    ans = []
    powers = [1 << i for i in range(kMaxBit) if n >> i & 1]

    for left, right in queries:
      prod = 1
      for i in range(left, right + 1):
        prod *= powers[i]
        prod %= kMod
      ans.append(prod)

    return ans

```

## 88. Merge Sorted Array_88.py
```python
class Solution:
  def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
    i = m - 1  # nums1's index (the actual nums)
    j = n - 1  # nums2's index
    k = m + n - 1  # nums1's index (the next filled position)

    while j >= 0:
      if i >= 0 and nums1[i] > nums2[j]:
        nums1[k] = nums1[i]
        k -= 1
        i -= 1
      else:
        nums1[k] = nums2[j]
        k -= 1
        j -= 1

```

## 1283. Find the Smallest Divisor Given a Threshold_1283.py
```python
class Solution:
  def smallestDivisor(self, nums: List[int], threshold: int) -> int:
    l = 1
    r = max(nums)

    while l < r:
      m = (l + r) // 2
      if sum((num - 1) // m + 1 for num in nums) <= threshold:
        r = m
      else:
        l = m + 1

    return l

```

## 2408. Design SQL_2408.py
```python
class SQL:
  def __init__(self, names: List[str], columns: List[int]):
    self.db: Dict[str, List[List[str]]] = collections.defaultdict(list)

  def insertRow(self, name: str, row: List[str]) -> None:
    self.db[name].append(row)

  def deleteRow(self, name: str, rowId: int) -> None:
    pass

  def selectCell(self, name: str, rowId: int, columnId: int) -> str:
    return self.db[name][rowId - 1][columnId - 1]

```

## 2957. Remove Adjacent Almost-Equal Characters_2957.py
```python
class Solution:
  def removeAlmostEqualCharacters(self, word: str) -> int:
    ans = 0
    i = 1
    while i < len(word):
      if abs(ord(word[i]) - ord(word[i - 1])) <= 1:
        ans += 1
        i += 2
      else:
        i += 1
    return ans

```

## 2831. Find the Longest Equal Subarray_2831.py
```python
class Solution:
  def longestEqualSubarray(self, nums: List[int], k: int) -> int:
    ans = 0
    count = collections.Counter()

    l = 0
    for r, num in enumerate(nums):
      count[num] += 1
      ans = max(ans, count[num])
      while r - l + 1 - k > ans:
        count[nums[l]] -= 1
        l += 1

    return ans

```

## 910. Smallest Range II_910.py
```python
class Solution:
  def smallestRangeII(self, nums: List[int], k: int) -> int:
    nums.sort()

    ans = nums[-1] - nums[0]
    left = nums[0] + k
    right = nums[-1] - k

    for a, b in itertools.pairwise(nums):
      mn = min(left, b - k)
      mx = max(right, a + k)
      ans = min(ans, mx - mn)

    return ans

```

## 2405. Optimal Partition of String_2405.py
```python
class Solution:
  def partitionString(self, s: str) -> int:
    ans = 1
    used = 0

    for c in s:
      i = ord(c) - ord('a')
      if used >> i & 1:
        used = 1 << i
        ans += 1
      else:
        used |= 1 << i

    return ans

```

## 2464. Minimum Subarrays in a Valid Split_2464.py
```python
class Solution:
  def validSubarraySplit(self, nums: List[int]) -> int:
    # dp[i] := the minimum number of subarrays to validly split nums[0..i]
    dp = [math.inf] * len(nums)

    for i, num in enumerate(nums):
      for j in range(i + 1):
        if math.gcd(nums[j], num) > 1:
          dp[i] = min(dp[i], 1 if j == 0 else dp[j - 1] + 1)

    return -1 if dp[-1] == math.inf else dp[-1]

```

## 2260. Minimum Consecutive Cards to Pick Up_2260.py
```python
class Solution:
  def minimumCardPickup(self, cards: List[int]) -> int:
    ans = math.inf
    lastSeen = {}

    for i, card in enumerate(cards):
      if card in lastSeen:
        ans = min(ans, i - lastSeen[card] + 1)
      lastSeen[card] = i

    return -1 if ans == math.inf else ans

```

## 240. Search a 2D Matrix II_240.py
```python
class Solution:
  def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
    r = 0
    c = len(matrix[0]) - 1

    while r < len(matrix) and c >= 0:
      if matrix[r][c] == target:
        return True
      if target < matrix[r][c]:
        c -= 1
      else:
        r += 1

    return False

```

## 1183. Maximum Number of Ones_1183-2.py
```python
class Solution:
  def maximumNumberOfOnes(self, width: int, height: int, sideLength: int, maxOnes: int) -> int:
    subCount = []

    def getCount(length: int, index: int) -> int:
      return (length - index - 1) // sideLength + 1

    for i in range(sideLength):
      for j in range(sideLength):
        subCount.append(getCount(width, i) * getCount(height, j))

    return sum(sorted(subCount, reverse=True)[:maxOnes])

```

## 747. Largest Number At Least Twice of Others_747.py
```python
class Solution:
  def dominantIndex(self, nums: List[int]) -> int:
    mx = 0
    secondMax = 0

    for i, num in enumerate(nums):
      if num > mx:
        secondMax = mx
        mx = num
        ans = i
      elif num > secondMax:
        secondMax = num

    return ans if mx >= 2 * secondMax else -1

```

## 2486. Append Characters to String to Make Subsequence_2486.py
```python
class Solution:
  def appendCharacters(self, s: str, t: str) -> int:
    i = 0  # t's index

    for c in s:
      if c == t[i]:
        i += 1
        if i == len(t):
          return 0

    return len(t) - i

```

## 1296. Divide Array in Sets of K Consecutive Numbers_1296.py
```python
class Solution:
  def isPossibleDivide(self, nums: List[int], k: int) -> bool:
    count = collections.Counter(nums)

    for start in sorted(count):
      value = count[start]
      if value > 0:
        for i in range(start, start + k):
          count[i] -= value
          if count[i] < 0:
            return False

    return True

```

## 1151. Minimum Swaps to Group All 1's Together_1151.py
```python
class Solution:
  def minSwaps(self, data: List[int]) -> int:
    k = data.count(1)
    ones = 0  # the number of ones in the window
    maxOnes = 0  # the maximum number of ones in the window

    for i, num in enumerate(data):
      if i >= k and data[i - k]:
        ones -= 1
      if num:
        ones += 1
      maxOnes = max(maxOnes, ones)

    return k - maxOnes

```

## 535. Encode and Decode TinyURL_535.py
```python
class Codec:
  alphabets = string.ascii_letters + '0123456789'
  urlToCode = {}
  codeToUrl = {}

  def encode(self, longUrl: str) -> str:
    while longUrl not in self.urlToCode:
      code = ''.join(random.choice(self.alphabets) for _ in range(6))
      if code not in self.codeToUrl:
        self.codeToUrl[code] = longUrl
        self.urlToCode[longUrl] = code
    return 'http://tinyurl.com/' + self.urlToCode[longUrl]

  def decode(self, shortUrl: str) -> str:
    return self.codeToUrl[shortUrl[-6:]]

```

## 997. Find the Town Judge_997.py
```python
class Solution:
  def findJudge(self, n: int, trust: List[List[int]]) -> int:
    count = [0] * (n + 1)

    for a, b in trust:
      count[a] -= 1
      count[b] += 1

    for i in range(1, n + 1):
      if count[i] == n - 1:
        return i

    return -1

```

## 2379. Minimum Recolors to Get K Consecutive Black Blocks_2379.py
```python
class Solution:
  def minimumRecolors(self, blocks: str, k: int) -> int:
    countB = 0
    maxCountB = 0

    for i, block in enumerate(blocks):
      if block == 'B':
        countB += 1
      if i >= k and blocks[i - k] == 'B':
        countB -= 1
      maxCountB = max(maxCountB, countB)

    return k - maxCountB

```

## 2201. Count Artifacts That Can Be Extracted_2201.py
```python
class Solution:
  def digArtifacts(self, n: int, artifacts: List[List[int]], dig: List[List[int]]) -> int:
    digged = set((r, c) for r, c in dig)

    def canExtract(a: List[int]) -> bool:
      for i in range(a[0], a[2] + 1):
        for j in range(a[1], a[3] + 1):
          if (i, j) not in digged:
            return False
      return True

    return sum(canExtract(a) for a in artifacts)

```

## 2289. Steps to Make Array Non-decreasing_2289.py
```python
class Solution:
  def totalSteps(self, nums: List[int]) -> int:
    # dp[i] := the number of steps to remove nums[i]
    dp = [0] * len(nums)
    stack = []

    for i, num in enumerate(nums):
      step = 1
      while stack and nums[stack[-1]] <= num:
        step = max(step, dp[stack.pop()] + 1)
      if stack:
        dp[i] = step
      stack.append(i)

    return max(dp)

```

## 2210. Count Hills and Valleys in an Array_2210.py
```python
class Solution:
  def countthe hillthe valley(self, nums: List[int]) -> int:
    ans = 0
    left = nums[0]

    for i in range(1, len(nums) - 1):
      # the hill or valley
      if left < nums[i] and nums[i] > nums[i + 1] or \
              left > nums[i] and nums[i] < nums[i + 1]:
        ans += 1
        left = nums[i]

    return ans

```

## 554. Brick Wall_554.py
```python
class Solution:
  def leastBricks(self, wall: List[List[int]]) -> int:
    maxFreq = 0
    count = collections.defaultdict(int)

    for row in wall:
      prefix = 0
      for i in range(len(row) - 1):
        prefix += row[i]
        count[prefix] += 1
        maxFreq = max(maxFreq, count[prefix])

    return len(wall) - maxFreq

```

## 311. Sparse Matrix Multiplication_311.py
```python
class Solution:
  def multiply(self, mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]:
    m = len(mat1)
    n = len(mat2)
    l = len(mat2[0])
    ans = [[0] * l for _ in range(m)]

    for i in range(m):
      for j in range(l):
        for k in range(n):
          ans[i][j] += mat1[i][k] * mat2[k][j]

    return ans

```

## 2535. Difference Between Element Sum and Digit Sum of an Array_2535.py
```python
class Solution:
  def differenceOfSum(self, nums: List[int]) -> int:
    elementSum = sum(nums)
    digitSum = self._getAllDigitSum(nums)
    return abs(elementSum - digitSum)

  def _getAllDigitSum(self, nums: List[int]) -> int:
    return sum(self._getDigitSum(num) for num in nums)

  def _getDigitSum(self, num: int) -> int:
    return sum(int(digit) for digit in str(num))

```

## 2731. Movement of Robots_2731.py
```python
class Solution:
  def sumDistance(self, nums: List[int], s: str, d: int) -> int:
    kMod = 1_000_000_007
    ans = 0
    prefix = 0
    pos = sorted([num - d if c == 'L' else num + d
                  for num, c in zip(nums, s)])

    for i, p in enumerate(pos):
      ans = ((ans + i * p - prefix) % kMod + kMod) % kMod
      prefix = ((prefix + p) % kMod + kMod) % kMod

    return ans

```

## 2079. Watering Plants_2079.py
```python
class Solution:
  def wateringPlants(self, plants: List[int], capacity: int) -> int:
    ans = 0
    currCapacity = 0

    for i, plant in enumerate(plants):
      if currCapacity + plant <= capacity:
        currCapacity += plant
      else:
        currCapacity = plant  # Reset
        ans += i * 2

    return ans + len(plants)

```

## 6. ZigZag Conversion_6.py
```python
class Solution:
  def convert(self, s: str, numRows: int) -> str:
    rows = [''] * numRows
    k = 0
    direction = (numRows == 1) - 1

    for c in s:
      rows[k] += c
      if k == 0 or k == numRows - 1:
        direction *= -1
      k += direction

    return ''.join(rows)

```

## 369. Plus One Linked List_369.py
```python
class Solution:
  def plusOne(self, head: ListNode) -> ListNode:
    if not head:
      return ListNode(1)
    if self._addOne(head) == 1:
      return ListNode(1, head)
    return head

  def _addOne(self, node: ListNode) -> int:
    carry = self._addOne(node.next) if node.next else 1
    summ = node.val + carry
    node.val = summ % 10
    return summ // 10

```

## 1981. Minimize the Difference Between Target and Chosen Elements_1981.py
```python
class Solution:
  def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:
    minSum = sum(min(row) for row in mat)
    if minSum >= target:  # No need to consider any larger combination.
      return minSum - target

    @functools.lru_cache(None)
    def dp(i: int, summ: int) -> int:
      if i == len(mat):
        return abs(summ - target)
      return min(dp(i + 1, summ + num) for num in mat[i])

    return dp(0, 0)

```

## 2437. Number of Valid Clock Times_2437.py
```python
class Solution:
  def countTime(self, time: str) -> int:
    ans = 1
    if time[3] == '?':
      ans *= 6
    if time[4] == '?':
      ans *= 10

    if time[0] == '?' and time[1] == '?':
      return ans * 24
    if time[0] == '?':
      return ans * 3 if time[1] < '4' else ans * 2
    if time[1] == '?':
      return ans * 4 if time[0] == '2' else ans * 10
    return ans

```

## 134. Gas Station_134.py
```python
class Solution:
  def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
    ans = 0
    net = 0
    summ = 0

    # Try to start from each index.
    for i in range(len(gas)):
      net += gas[i] - cost[i]
      summ += gas[i] - cost[i]
      if summ < 0:
        summ = 0
        ans = i + 1  # Start from the next index.

    return -1 if net < 0 else ans

```

## 1535. Find the Winner of an Array Game_1535.py
```python
class Solution:
  def getWinner(self, arr: List[int], k: int) -> int:
    ans = arr[0]
    wins = 0

    i = 1
    while i < len(arr) and wins < k:
      if arr[i] > ans:
        ans = arr[i]
        wins = 1
      else:
        wins += 1
      i += 1

    return ans

```

## 2826. Sorting Three Groups_2826.py
```python
class Solution:
  def minimumOperations(self, nums: List[int]) -> int:
    # dp[i] := the longest non-decreasing subsequence so far with numbers in [1..i]
    dp = [0] * 4

    for num in nums:
      dp[num] += 1  # Append num to the sequence so far.
      dp[2] = max(dp[2], dp[1])
      dp[3] = max(dp[3], dp[2])

    return len(nums) - dp[3]

```

## 2862. Maximum Element-Sum of a Complete Subset of Indices_2862-2.py
```python
class Solution:
  def maximumSum(self, nums: List[int]) -> int:
    ans = 0

    for oddPower in range(1, len(nums) + 1):
      summ = 0
      for num in range(1, len(nums) + 1):
        if num * num * oddPower > len(nums):
          break
        summ += nums[oddPower * num * num - 1]
      ans = max(ans, summ)

    return ans

```

## 153. Find Minimum in Rotated Sorted Array_153.py
```python
class Solution:
  def findMin(self, nums: List[int]) -> int:
    l = 0
    r = len(nums) - 1

    while l < r:
      m = (l + r) // 2
      if nums[m] < nums[r]:
        r = m
      else:
        l = m + 1

    return nums[l]

```

## 3120. Count the Number of Special Characters I_3120.py
```python
class Solution:
  def numberOfSpecialChars(self, word: str) -> int:
    lower = collections.defaultdict(bool)
    upper = collections.defaultdict(bool)

    for c in word:
      if c.islower():
        lower[c] = True
      else:
        upper[c] = True

    return sum(lower[a] and upper[b]
               for a, b in zip(string.ascii_lowercase,
                               string.ascii_uppercase))

```

## 800. Similar RGB Color_800.py
```python
class Solution:
  def similarRGB(self, color: str) -> str:
    kShorthands = ['00', '11', '22', '33', '44', '55', '66', '77', '88', '99',
                   'aa', 'bb', 'cc', 'dd', 'ee', 'ff']
    ans = ['#']

    for i in range(1, len(color), 2):
      currValue = int(color[i:i + 2], 16)
      closestShorthand = min(kShorthands,
                             key=lambda shorthand: (currValue - int(shorthand, 16))**2)
      ans.append(closestShorthand)

    return ''.join(ans)

```

## 165. Compare Version Numbers_165.py
```python
class Solution:
  def compareVersion(self, version1: str, version2: str) -> int:
    levels1 = version1.split('.')
    levels2 = version2.split('.')
    length = max(len(levels1), len(levels2))

    for i in range(length):
      v1 = int(levels1[i]) if i < len(levels1) else 0
      v2 = int(levels2[i]) if i < len(levels2) else 0
      if v1 < v2:
        return -1
      if v1 > v2:
        return 1

    return 0

```

## 373. Find K Pairs with Smallest Sums_373.py
```python
class Solution:
  def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
    minHeap = []

    for i in range(min(k, len(nums1))):
      heapq.heappush(minHeap, (nums1[i] + nums2[0], i, 0))

    ans = []
    while minHeap and len(ans) < k:
      _, i, j = heapq.heappop(minHeap)
      ans.append([nums1[i], nums2[j]])
      if j + 1 < len(nums2):
        heapq.heappush(minHeap, (nums1[i] + nums2[j + 1], i, j + 1))

    return ans

```

## 2507. Smallest Value After Replacing With Sum of Prime Factors_2507.py
```python
class Solution:
  def smallestValue(self, n: int) -> int:
    def getPrimeSum(n: int) -> int:
      primeSum = 0
      for i in range(2, n + 1):
        while n % i == 0:
          n //= i
          primeSum += i
      return primeSum

    primeSum = getPrimeSum(n)
    while n != primeSum:
      n = primeSum
      primeSum = getPrimeSum(n)
    return n

```

## 2109. Adding Spaces to a String_2109.py
```python
class Solution:
  def addSpaces(self, s: str, spaces: List[int]) -> str:
    ans = []
    j = 0  # spaces' index

    for i, c in enumerate(s):
      if j < len(spaces) and i == spaces[j]:
        ans.append(' ')
        j += 1
      ans.append(c)

    return ''.join(ans)

```

## 3215. Count Triplets with Even XOR Set Bits II_3215.py
```python
class Solution:
  # Same as 3199. Count Triplets with Even XOR Set Bits I
  def tripletCount(self, a: List[int], b: List[int], c: List[int]) -> int:
    evenA, oddA = self._getEvenOddBitCount(a)
    evenB, oddB = self._getEvenOddBitCount(b)
    evenC, oddC = self._getEvenOddBitCount(c)
    return evenA * oddB * oddC + oddA * evenB * oddC + oddA * oddB * evenC + evenA * evenB * evenC

  def _getEvenOddBitCount(self, nums: List[int]) -> Tuple[int, int]:
    """
    Returns the count of numbers in the `nums` arrays that have even number of
    ones and odd number of ones in their binary representation.
    """
    even = sum(num.bit_count() % 2 == 0 for num in nums)
    return (even, len(nums) - even)

```

## 942. DI String Match_942.py
```python
class Solution:
  def diStringMatch(self, s: str) -> List[int]:
    ans = []
    mn = 0
    mx = len(s)

    for c in s:
      if c == 'I':
        ans.append(mn)
        mn += 1
      else:
        ans.append(mx)
        mx -= 1

    return ans + [mn]

```

## 2424. Longest Uploaded Prefix_2424.py
```python
class LUPrefix:
  def __init__(self, n: int):
    self.seen = set()
    self.longestPrefix = 0

  def upload(self, video: int) -> None:
    self.seen.add(video)
    while self.longestPrefix + 1 in self.seen:
      self.longestPrefix += 1

  def longest(self) -> int:
    return self.longestPrefix

```

## 2522. Partition String Into Substrings With Values at Most K_2522.py
```python
class Solution:
  def minimumPartition(self, s: str, k: int) -> int:
    ans = 1
    curr = 0

    for c in s:
      curr = curr * 10 + int(c)
      if curr > k:
        curr = int(c)
        ans += 1
      if curr > k:
        return -1

    return ans

```

## 871. Minimum Number of Refueling Stops_871.py
```python
class Solution:
  def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:
    # dp[i] := the farthest position we can reach w / i refuels
    dp = [startFuel] + [0] * len(stations)

    for i, station in enumerate(stations):
      for j in range(i + 1, 0, -1):
        if dp[j - 1] >= station[0]:
          dp[j] = max(dp[j], dp[j - 1] + station[1])

    for i, d in enumerate(dp):
      if d >= target:
        return i

    return -1

```

## 811. Subdomain Visit Count_811.py
```python
class Solution:
  def subdomainVisits(self, cpdomains: List[str]) -> List[str]:
    ans = []
    count = collections.Counter()

    for cpdomain in cpdomains:
      num, domains = cpdomain.split()
      num, domains = int(num), domains.split('.')
      for i in reversed(range(len(domains))):
        count['.'.join(domains[i:])] += num

    return [str(freq) + ' ' + domain for domain, freq in count.items()]

```

## 592. Fraction Addition and Subtraction_592.py
```python
class Solution:
  def fractionAddition(self, expression: str) -> str:
    ints = list(map(int, re.findall('[+-]?[0-9]+', expression)))
    A = 0
    B = 1

    for a, b in zip(ints[::2], ints[1::2]):
      A = A * b + a * B
      B *= b
      g = math.gcd(A, B)
      A //= g
      B //= g

    return str(A) + '/' + str(B)

```

## 246. Strobogrammatic Number_246.py
```python
class Solution:
  def isStrobogrammatic(self, num: str) -> bool:
    rotated = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}
    l = 0
    r = len(num) - 1

    while l <= r:
      if num[r] not in rotated:
        return False
      if num[l] != rotated[num[r]]:
        return False
      l += 1
      r -= 1

    return True

```

## 115. Distinct Subsequences_115-2.py
```python
class Solution:
  def numDistinct(self, s: str, t: str) -> int:
    m = len(s)
    n = len(t)
    dp = [1] + [0] * n

    for i in range(1, m + 1):
      for j in range(n, 1 - 1, -1):
        if s[i - 1] == t[j - 1]:
          dp[j] += dp[j - 1]

    return dp[n]

```

## 274. H-Index_274-2.py
```python
class Solution:
  def hIndex(self, citations: List[int]) -> int:
    n = len(citations)

    citations.sort()

    for i, citation in enumerate(citations):
      if citation >= n - i:
        return n - i

    return 0

```

## 2681. Power of Heroes_2681.py
```python
class Solution:
  def sumOfPower(self, nums: List[int]) -> int:
    kMod = 1_000_000_007
    ans = 0
    summ = 0

    for num in sorted(nums):
      ans += (num + summ) * num**2
      ans %= kMod
      summ = (summ * 2 + num) % kMod

    return ans

```

## 1893. Check if All the Integers in a Range Are Covered_1893-2.py
```python
class Solution:
  def isCovered(self, ranges: List[List[int]], left: int, right: int) -> bool:
    seen = [0] * 52

    for l, r in ranges:
      seen[l] += 1
      seen[r + 1] -= 1

    for i in range(1, 52):
      seen[i] += seen[i - 1]

    return all(seen[i] for i in range(left, right + 1))

```

## 2451. Odd String Difference_2451.py
```python
class Solution:
  def oddString(self, words: List[str]) -> str:
    def getDiff(s: str) -> List[int]:
      return [ord(b) - ord(a) for a, b in zip(s, s[1:])]

    wordAndDiffTuples = [(word, tuple(getDiff(word))) for word in words]
    diffTupleCount = collections.Counter()

    for _, diffTuple in wordAndDiffTuples:
      diffTupleCount[diffTuple] += 1

    for word, diffTuple in wordAndDiffTuples:
      if diffTupleCount[diffTuple] == 1:
        return word

```

## 2027. Minimum Moves to Convert String_2027.py
```python
class Solution:
  def minimumMoves(self, s: str) -> int:
    ans = 0

    i = 0
    while i < len(s):
      if s[i] == 'O':
        i += 1
      else:
        ans += 1
        i += 3

    return ans

```

## 951. Flip Equivalent Binary Trees_951.py
```python
class Solution:
  def flipEquiv(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:
    if not root1:
      return not root2
    if not root2:
      return not root1
    if root1.val != root2.val:
      return False
    return self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right) or \
        self.flipEquiv(root1.left, root2.right) and self.flipEquiv(
        root1.right, root2.left)

```

## 1156. Swap For Longest Repeated Character Substring_1156.py
```python
class Solution:
  def maxRepOpt1(self, text: str) -> int:
    count = collections.Counter(text)
    groups = [[c, len(list(group))]
              for c, group in itertools.groupby(text)]
    ans = max(min(length + 1, count[c]) for c, length in groups)

    for i in range(1, len(groups) - 1):
      if groups[i - 1][0] == groups[i + 1][0] and groups[i][1] == 1:
        ans = max(
            ans, min(groups[i - 1][1] + groups[i + 1][1] + 1, count[groups[i - 1][0]]))

    return ans

```

## 922. Sort Array By Parity II_922.py
```python
class Solution:
  def sortArrayByParityII(self, nums: List[int]) -> List[int]:
    n = len(nums)

    i = 0
    j = 1
    while i < n:
      while i < n and nums[i] % 2 == 0:
        i += 2
      while j < n and nums[j] % 2 == 1:
        j += 2
      if i < n:
        nums[i], nums[j] = nums[j], nums[i]

    return nums

```

## 435. Non-overlapping Intervals_435.py
```python
class Solution:
  def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
    ans = 0
    currentEnd = -math.inf

    for interval in sorted(intervals, key=lambda x: x[1]):
      if interval[0] >= currentEnd:
        currentEnd = interval[1]
      else:
        ans += 1

    return ans

```

## 1048. Longest String Chain_1048.py
```python
class Solution:
  def longestStrChain(self, words: List[str]) -> int:
    wordsSet = set(words)

    @functools.lru_cache(None)
    def dp(s: str) -> int:
      """Returns the longest chain where s is the last word."""
      ans = 1
      for i in range(len(s)):
        pred = s[:i] + s[i + 1:]
        if pred in wordsSet:
          ans = max(ans, dp(pred) + 1)
      return ans

    return max(dp(word) for word in words)

```

## 2119. A Number After a Double Reversal_2119.py
```python
class Solution:
  def isSameAfterReversals(self, num: int) -> bool:
    def getReversed(num: int) -> int:
      reversed = 0
      while num > 0:
        reversed = reversed * 10 + num % 10
        num //= 10
      return reversed

    reversed1 = getReversed(num)
    reversed2 = getReversed(reversed1)
    return reversed2 == num

```

## 3181. Maximum Total Reward Using Operations II_3181.py
```python
class Solution:
  # Same as 3180. Maximum Total Reward Using Operations I
  def maxTotalReward(self, rewardValues: List[int]) -> int:
    dp = 1  # the possible rewards (initially, 0 is achievable)

    for num in sorted(rewardValues):
      # Remove the numbers >= the current number.
      smallerNums = dp & ((1 << num) - 1)
      dp |= smallerNums << num

    return dp.bit_length() - 1

```

## 654. Maximum Binary Tree_654.py
```python
class Solution:
  def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:
    def build(i: int, j: int) -> Optional[TreeNode]:
      if i > j:
        return None

      maxNum = max(nums[i:j + 1])
      maxIndex = nums.index(maxNum)

      root = TreeNode(maxNum)
      root.left = build(i, maxIndex - 1)
      root.right = build(maxIndex + 1, j)
      return root

    return build(0, len(nums) - 1)

```

## 309. Best Time to Buy and Sell Stock with Cooldown_309.py
```python
class Solution:
  def maxProfit(self, prices: List[int]) -> int:
    sell = 0
    hold = -math.inf
    prev = 0

    for price in prices:
      cache = sell
      sell = max(sell, hold + price)
      hold = max(hold, prev - price)
      prev = cache

    return sell

```

## 3148. Maximum Difference Score in a Grid_3148.py
```python
class Solution:
  def maxScore(self, grid: List[List[int]]) -> int:
    kMax = 200000
    ans = -kMax

    for i, row in enumerate(grid):
      for j, num in enumerate(row):
        prevMin = min(grid[i - 1][j] if i > 0 else kMax,
                      grid[i][j - 1] if j > 0 else kMax)
        ans = max(ans, num - prevMin)
        grid[i][j] = min(num, prevMin)

    return ans

```

## 2483. Minimum Penalty for a Shop_2483.py
```python
class Solution:
  def bestClosingTime(self, customers: str) -> int:
    # Instead of computing the minimum penalty, we can compute the maximum profit.
    ans = 0
    profit = 0
    maxProfit = 0

    for i, customer in enumerate(customers):
      profit += 1 if customer == 'Y' else -1
      if profit > maxProfit:
        maxProfit = profit
        ans = i + 1

    return ans

```

## 2874. Maximum Value of an Ordered Triplet II_2874.py
```python
class Solution:
  # Same as 2873. Maximum Value of an Ordered Triplet I
  def maximumTripletValue(self, nums: List[int]) -> int:
    ans = 0
    maxDiff = 0  # max(nums[i] - nums[j])
    maxNum = 0   # max(nums[i])

    for num in nums:
      ans = max(ans, maxDiff * num)         # num := nums[k]
      maxDiff = max(maxDiff, maxNum - num)  # num := nums[j]
      maxNum = max(maxNum, num)             # num := nums[i]

    return ans

```

## 198. House Robber_198-2.py
```python
class Solution:
  def rob(self, nums: List[int]) -> int:
    prev1 = 0  # dp[i - 1]
    prev2 = 0  # dp[i - 2]

    for num in nums:
      dp = max(prev1, prev2 + num)
      prev2 = prev1
      prev1 = dp

    return prev1

```

## 754. Reach a Number_754.py
```python
class Solution:
  def reachNumber(self, target: int) -> int:
    ans = 0
    pos = 0
    target = abs(target)

    while pos < target:
      ans += 1
      pos += ans

    while (pos - target) % 2 == 1:
      ans += 1
      pos += ans

    return ans

```

## 1711. Count Good Meals_1711.py
```python
class Solution:
  def countPairs(self, deliciousness: List[int]) -> int:
    kMod = 10**9 + 7
    kMaxBit = 20 + 1
    ans = 0
    count = collections.Counter()

    for d in deliciousness:
      for i in range(kMaxBit + 1):
        power = 1 << i
        ans += count[power - d]
        ans %= kMod
      count[d] += 1

    return ans

```

## 187. Repeated DNA Sequences_187.py
```python
class Solution:
  def findRepeatedDnaSequences(self, s: str) -> List[str]:
    ans = set()
    seen = set()

    for i in range(len(s) - 9):
      seq = s[i:i + 10]
      if seq in seen:
        ans.add(seq)
      seen.add(seq)

    return list(ans)

```

## 862. Shortest Subarray with Sum at Least K_862.py
```python
class Solution:
  def shortestSubarray(self, nums: List[int], k: int) -> int:
    n = len(nums)
    ans = n + 1
    dq = collections.deque()
    prefix = [0] + list(itertools.accumulate(nums))

    for i in range(n + 1):
      while dq and prefix[i] - prefix[dq[0]] >= k:
        ans = min(ans, i - dq.popleft())
      while dq and prefix[i] <= prefix[dq[-1]]:
        dq.pop()
      dq.append(i)

    return ans if ans <= n else -1

```

## 1871. Jump Game VII_1871.py
```python
class Solution:
  def canReach(self, s: str, minJump: int, maxJump: int) -> bool:
    count = 0
    dp = [True] + [False] * (len(s) - 1)

    for i in range(minJump, len(s)):
      count += dp[i - minJump]
      if i - maxJump > 0:
        count -= dp[i - maxJump - 1]
      dp[i] = count and s[i] == '0'

    return dp[-1]

```

## 2744. Find Maximum Number of String Pairs_2744.py
```python
class Solution:
  def maximumNumberOfStringPairs(self, words: List[str]) -> int:
    ans = 0
    seen = [False] * (26 * 26)

    def val(c: str) -> int:
      return ord(c) - ord('a')

    for word in words:
      if seen[val(word[1]) * 26 + val(word[0])]:
        ans += 1
      seen[val(word[0]) * 26 + val(word[1])] = True

    return ans

```

## 347. Top K Frequent Elements_347-2.py
```python
class Solution:
  def topKFrequent(self, nums: List[int], k: int) -> List[int]:
    ans = []
    bucket = [[] for _ in range(len(nums) + 1)]

    for num, freq in collections.Counter(nums).items():
      bucket[freq].append(num)

    for b in reversed(bucket):
      ans += b
      if len(ans) == k:
        return ans

```

## 2599. Make the Prefix Sum Non-negative_2599.py
```python
class Solution:
  def makePrefSumNonNegative(self, nums: List[int]) -> int:
    ans = 0
    prefix = 0
    minHeap = []

    for num in nums:
      prefix += num
      if num < 0:
        heapq.heappush(minHeap, num)
      while prefix < 0:
        prefix -= heapq.heappop(minHeap)
        ans += 1

    return ans

```

## 2857. Count Pairs of Points With Distance k_2857.py
```python
class Solution:
  def countPairs(self, coordinates: List[List[int]], k: int) -> int:
    ans = 0

    for x in range(k + 1):
      y = k - x
      count = collections.Counter()
      for xi, yi in coordinates:
        ans += count[(xi ^ x, yi ^ y)]
        count[(xi, yi)] += 1

    return ans

```

## 1963. Minimum Number of Swaps to Make the String Balanced_1963.py
```python
class Solution:
  def minSwaps(self, s: str) -> int:
    # Cancel out all the matched pairs, then we'll be left with ']]]..[[['.
    # The answer is ceil(# of unmatched pairs // 2).
    unmatched = 0

    for c in s:
      if c == '[':
        unmatched += 1
      elif unmatched > 0:  # c == ']' and there's a match.
        unmatched -= 1

    return (unmatched + 1) // 2

```

## 447. Number of Boomerangs_447.py
```python
class Solution:
  def numberOfBoomerangs(self, points: List[List[int]]) -> int:
    ans = 0

    for x1, y1 in points:
      count = collections.Counter()
      for x2, y2 in points:
        ans += 2 * count[(x1 - x2)**2 + (y1 - y2)**2]
        count[(x1 - x2)**2 + (y1 - y2)**2] += 1

    return ans

```

## 2825. Make String a Subsequence Using Cyclic Increments_2825.py
```python
class Solution:
  def canMakeSubsequence(self, str1: str, str2: str) -> bool:
    i = 0  # str2's index

    for c in str1:
      if c == str2[i] or chr(ord('a') + ((ord(c) - ord('a') + 1) % 26)) == str2[i]:
        i += 1
        if i == len(str2):
          return True

    return False

```

## 1155. Number of Dice Rolls With Target Sum_1155.py
```python
class Solution:
  def numRollsToTarget(self, n: int, k: int, target: int) -> int:
    kMod = 1_000_000_007
    dp = [1] + [0] * target

    for _ in range(n):  # n dices
      newDp = [0] * (target + 1)
      for i in range(1, k + 1):  # numbers 1, 2, ..., f
        for t in range(i, target + 1):  # all the possible targets
          newDp[t] += dp[t - i]
          newDp[t] %= kMod
      dp = newDp

    return dp[target]

```

## 154. Find Minimum in Rotated Sorted Array II_154.py
```python
class Solution:
  def findMin(self, nums: List[int]) -> int:
    l = 0
    r = len(nums) - 1

    while l < r:
      m = (l + r) // 2
      if nums[m] == nums[r]:
        r -= 1
      elif nums[m] < nums[r]:
        r = m
      else:
        l = m + 1

    return nums[l]

```

## 94. Binary Tree Inorder Traversal_94.py
```python
class Solution:
  def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
    ans = []
    stack = []

    while root or stack:
      while root:
        stack.append(root)
        root = root.left
      root = stack.pop()
      ans.append(root.val)
      root = root.right

    return ans

```

## 1064. Fixed Point_1064.py
```python
class Solution:
  def fixedPoint(self, arr: List[int]) -> int:
    l = 0
    r = len(arr) - 1

    # Since arr[i] is strictly increasing, arr[i] - i will also be increasing.
    # Therefore, binary search `arr` for the first arr[i] - i = 0.
    while l < r:
      m = (l + r) // 2
      if arr[m] - m >= 0:
        r = m
      else:
        l = m + 1

    return l if arr[l] == l else -1

```

## 20. Valid Parentheses_20.py
```python
class Solution:
  def isValid(self, s: str) -> bool:
    stack = []

    for c in s:
      if c == '(':
        stack.append(')')
      elif c == '{':
        stack.append('}')
      elif c == '[':
        stack.append(']')
      elif not stack or stack.pop() != c:
        return False

    return not stack

```

## 1130. Minimum Cost Tree From Leaf Values_1130-2.py
```python
class Solution:
  def mctFromLeafValues(self, arr: List[int]) -> int:
    ans = 0
    stack = [math.inf]

    for a in arr:
      while stack and stack[-1] <= a:
        mid = stack.pop()
        # Multiply mid with next greater element in the array,
        # On the left (stack[-1]) or on the right (current number a)
        ans += min(stack[-1], a) * mid
      stack.append(a)

    return ans + sum(a * b for a, b in zip(stack[1:], stack[2:]))

```

## 3. Longest Substring Without Repeating Characters_3-2.py
```python
class Solution:
  def lengthOfLongestSubstring(self, s: str) -> int:
    ans = 0
    # The substring s[j + 1..i] has no repeating characters.
    j = -1
    # lastSeen[c] := the index of the last time c appeared
    lastSeen = {}

    for i, c in enumerate(s):
      # Update j to lastSeen[c], so the window must start from j + 1.
      j = max(j, lastSeen.get(c, -1))
      ans = max(ans, i - j)
      lastSeen[c] = i

    return ans

```

## 189. Rotate Array_189.py
```python
class Solution:
  def rotate(self, nums: List[int], k: int) -> None:
    k %= len(nums)
    self.reverse(nums, 0, len(nums) - 1)
    self.reverse(nums, 0, k - 1)
    self.reverse(nums, k, len(nums) - 1)

  def reverse(self, nums: List[int], l: int, r: int) -> None:
    while l < r:
      nums[l], nums[r] = nums[r], nums[l]
      l += 1
      r -= 1

```

## 1338. Reduce Array Size to The Half_1338.py
```python
class Solution:
  def minSetSize(self, arr: List[int]) -> int:
    n = len(arr)

    count = collections.Counter(arr).most_common()
    count.sort(key=lambda c: -c[1])

    summ = 0
    for i, c in enumerate(count):
      summ += c[1]
      if summ >= n // 2:
        return i + 1

```

## 3074. Apple Redistribution into Boxes_3074.py
```python
class Solution:
  def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:
    appleSum = sum(apple)
    capacitySum = 0

    for i, c in enumerate(sorted(capacity, reverse=True)):
      capacitySum += c
      if capacitySum >= appleSum:
        return i + 1

    return len(capacity)

```

## 1056. Confusing Number_1056.py
```python
class Solution:
  def confusingNumber(self, n: int) -> bool:
    s = str(n)
    rotated = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}
    rotatedNum = []

    for c in s[::-1]:
      if c not in rotated:
        return False
      rotatedNum.append(rotated[c])

    return ''.join(rotatedNum) != s

```

## 3136. Valid Word_3136.py
```python
class Solution:
  def isValid(self, word: str) -> bool:
    kVowels = 'aeiouAEIOU'

    def isConsonant(c: str) -> bool:
      return c.isalpha() and c not in kVowels

    return len(word) >= 3 and \
        all(c.isalnum() for c in word) and \
        any(c in kVowels for c in word) and \
        any(isConsonant(c) for c in word)

```

## 3171. Find Subarray With Bitwise AND Closest to K_3171.py
```python
class Solution:
  # Same as 1521. Find a Value of a Mysterious Function Closest to Target
  def minimumDifference(self, nums: List[int], k: int) -> int:
    ans = math.inf
    dp = set()  # all the values of subarrays that end in the current number

    for num in nums:
      # Extend each subarray that ends in the dpious number. Due to
      # monotonicity of the AND operation, the size of `next_set` will be at most
      # bin(num).count('1') + 1.
      dp = {num} | {val & num for val in dp}
      ans = min(ans, min(abs(k - val) for val in dp))

    return ans

```

## 2839. Check if Strings Can be Made Equal With Operations I_2839.py
```python
class Solution:
  def canBeEqual(self, s1: str, s2: str) -> bool:
    def swappedStrings(s: str) -> List[str]:
      chars = list(s)
      return [chars,
              ''.join([chars[2], chars[1], chars[0], chars[3]]),
              ''.join([chars[0], chars[3], chars[2], chars[1]]),
              ''.join([chars[2], chars[3], chars[0], chars[1]])]

    return any(a == b
               for a in swappedStrings(s1)
               for b in swappedStrings(s2))

```

## 238. Product of Array Except Self_238-2.py
```python
class Solution:
  def productExceptSelf(self, nums: List[int]) -> List[int]:
    n = len(nums)
    ans = [1] * n

    # Use ans as the prefix product array.
    for i in range(1, n):
      ans[i] = ans[i - 1] * nums[i - 1]

    suffix = 1  # suffix product
    for i, num in reversed(list(enumerate(nums))):
      ans[i] *= suffix
      suffix *= num

    return ans

```

## 2645. Minimum Additions to Make Valid String_2645.py
```python
class Solution:
  def addMinimum(self, word: str) -> int:
    letters = ['a', 'b', 'c']
    ans = 0
    i = 0

    while i < len(word):
      for c in letters:
        if i < len(word) and word[i] == c:
          i += 1
        else:
          ans += 1

    return ans

```

## 1220. Count Vowels Permutation_1220.py
```python
class Solution:
  def countVowelPermutation(self, n: int) -> int:
    kMod = 1_000_000_007
    dp = {'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1}

    for _ in range(n - 1):
      newDp = {'a': dp['e'] + dp['i'] + dp['u'],
               'e': dp['a'] + dp['i'],
               'i': dp['e'] + dp['o'],
               'o': dp['i'],
               'u': dp['i'] + dp['o']}
      dp = newDp

    return sum(dp.values()) % kMod

```

## 795. Number of Subarrays with Bounded Maximum_795.py
```python
class Solution:
  def numSubarrayBoundedMax(self, nums: List[int], left: int, right: int) -> int:
    ans = 0
    l = -1
    r = -1

    for i, num in enumerate(nums):
      if num > right:  # Handle the reset value.
        l = i
      if num >= left:  # Handle the reset and the needed value.
        r = i
      ans += r - l

    return ans

```

## 1456. Maximum Number of Vowels in a Substring of Given Length_1456.py
```python
class Solution:
  def maxVowels(self, s: str, k: int) -> int:
    ans = 0
    mx = 0
    kVowels = 'aeiou'

    for i, c in enumerate(s):
      if c in kVowels:
        mx += 1
      if i >= k and s[i - k] in kVowels:
        mx -= 1
      ans = max(ans, mx)

    return ans

```

## 3002. Maximum Size of a Set After Removals_3002.py
```python
class Solution:
  def maximumSetSize(self, nums1: List[int], nums2: List[int]) -> int:
    set1 = set(nums1)
    set2 = set(nums2)
    common = set1.intersection(set2)

    n = len(nums1)
    n1 = len(set1)
    n2 = len(set2)
    nc = len(common)
    maxUniqueNums1 = min(n1 - nc, n // 2)
    maxUniqueNums2 = min(n2 - nc, n // 2)
    return min(n, maxUniqueNums1 + maxUniqueNums2 + nc)

```

## 2330. Valid Palindrome IV_2330.py
```python
class Solution:
  def makePalindrome(self, s: str) -> bool:
    change = 0
    l = 0
    r = len(s) - 1

    while l < r:
      if s[l] != s[r]:
        change += 1
        if change > 2:
          return False
      l += 1
      r -= 1

    return True

```

## 2302. Count Subarrays With Score Less Than K_2302.py
```python
class Solution:
  def countSubarrays(self, nums: List[int], k: int) -> int:
    ans = 0
    summ = 0

    l = 0
    for r, num in enumerate(nums):
      summ += num
      while summ * (r - l + 1) >= k:
        summ -= nums[l]
        l += 1
      ans += r - l + 1

    return ans

```

## 3201. Find the Maximum Length of Valid Subsequence I_3201.py
```python
class Solution:
  def maximumLength(self, nums: List[int]) -> int:
    # dp[i][j] := the maximum length of a valid subsequence, where the last
    # number mod k equal to i and the next desired number mod k equal to j
    dp = [[0] * 2 for _ in range(2)]

    # Extend the pattern xyxyxy...xy.
    for x in nums:
      for y in range(2):
        dp[x % 2][y] = dp[y][x % 2] + 1

    return max(map(max, dp))

```

## 2219. Maximum Sum Score of Array_2219.py
```python
class Solution:
  def maximumSumScore(self, nums: List[int]) -> int:
    ans = -math.inf
    prefix = 0
    summ = sum(nums)

    for num in nums:
      prefix += num
      ans = max(ans, prefix, summ - prefix + num)

    return ans

```

## 1043. Partition Array for Maximum Sum_1043.py
```python
class Solution:
  def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:
    n = len(arr)
    dp = [0] * (n + 1)

    for i in range(1, n + 1):
      mx = -math.inf
      for j in range(1, min(i, k) + 1):
        mx = max(mx, arr[i - j])
        dp[i] = max(dp[i], dp[i - j] + mx * j)

    return dp[n]

```

## 2263. Make Array Non-decreasing or Non-increasing_2263.py
```python
class Solution:
  def convertArray(self, nums: List[int]) -> int:
    def cost(nums: List[int]) -> int:
      ans = 0
      minHeap = []

      # Greedily make `nums` non-increasing.
      for num in nums:
        if minHeap and minHeap[0] < num:
          ans += num - heapq.heappushpop(minHeap, num)
        heapq.heappush(minHeap, num)

      return ans

    return min(cost(nums), cost([-num for num in nums]))

```

## 1370. Increasing Decreasing String_1370.py
```python
class Solution:
  def sortString(self, s: str) -> str:
    ans = []
    count = collections.Counter(s)

    while count:
      for chars in string.ascii_lowercase, reversed(string.ascii_lowercase):
        ans += [c for c in chars if c in count]
        count -= dict.fromkeys(count, 1)

    return ''.join(ans)

```

## 2511. Maximum Enemy Forts That Can Be Captured_2511.py
```python
class Solution:
  def captureForts(self, forts: List[int]) -> int:
    ans = 0

    j = 0
    for i, fort in enumerate(forts):
      if fort != 0:  # -1 or 1
        if fort == -forts[j]:
          ans = max(ans, i - j - 1)
        j = i

    return ans

```

## 617. Merge Two Binary Trees_617.py
```python
class Solution:
  def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
    if not root1 and not root2:
      return None
    val = (root1.val if root1 else 0) + (root2.val if root2 else 0)
    root = TreeNode(val)
    root.left = self.mergeTrees(root1.left if root1 else None,
                                root2.left if root2 else None)
    root.right = self.mergeTrees(root1.right if root1 else None,
                                 root2.right if root2 else None)
    return root

```

## 2697. Lexicographically Smallest Palindrome_2697.py
```python
class Solution:
  def makeSmallestPalindrome(self, s: str) -> str:
    chars = list(s)
    i = 0
    j = len(s) - 1

    while i < j:
      minChar = min(chars[i], chars[j])
      chars[i] = minChar
      chars[j] = minChar
      i += 1
      j -= 1

    return ''.join(chars)

```

## 905. Sort Array By Parity_905.py
```python
class Solution:
  def sortArrayByParity(self, nums: List[int]) -> List[int]:
    l = 0
    r = len(nums) - 1

    while l < r:
      if nums[l] % 2 == 1 and nums[r] % 2 == 0:
        nums[l], nums[r] = nums[r], nums[l]
      if nums[l] % 2 == 0:
        l += 1
      if nums[r] % 2 == 1:
        r -= 1

    return nums

```

## 2389. Longest Subsequence With Limited Sum_2389.py
```python
class Solution:
  def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:
    nums.sort()

    def numOfElementsLessThan(query: int) -> int:
      summ = 0
      for i, num in enumerate(nums):
        summ += num
        if summ > query:
          return i
      return len(nums)

    return [numOfElementsLessThan(query) for query in queries]

```

## 3231. Minimum Number of Increasing Subsequence to Be Removed_3231.py
```python
class Solution:
  def minOperations(self, nums: List[int]) -> int:
    return self._lengthOfLIS(nums[::-1])

  def _lengthOfLIS(self, nums: List[int]) -> int:
    # tails[i] := the minimum tail of all the increasing subsequences having
    # length i + 1
    tails = []
    for num in nums:
      if not tails or num >= tails[-1]:
        tails.append(num)
      else:
        tails[bisect.bisect_right(tails, num)] = num
    return len(tails)

```

## 1005. Maximize Sum Of Array After K Negations_1005.py
```python
class Solution:
  def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:
    nums.sort()

    for i, num in enumerate(nums):
      if num > 0 or k == 0:
        break
      nums[i] = -num
      k -= 1

    return sum(nums) - (k % 2) * min(nums) * 2

```

## 1111. Maximum Nesting Depth of Two Valid Parentheses Strings_1111.py
```python
class Solution:
  def maxDepthAfterSplit(self, seq: str) -> List[int]:
    ans = []
    depth = 1

    # Put all odd-depth parentheses in one group and even-depth parentheses in the other group.
    for c in seq:
      if c == '(':
        depth += 1
        ans.append(depth % 2)
      else:
        ans.append(depth % 2)
        depth -= 1

    return ans

```

## 253. Meeting Rooms II_253.py
```python
class Solution:
  def minMeetingRooms(self, intervals: List[List[int]]) -> int:
    minHeap = []  # Store the end times of each room.

    for start, end in sorted(intervals):
      # There's no overlap, so we can reuse the same room.
      if minHeap and start >= minHeap[0]:
        heapq.heappop(minHeap)
      heapq.heappush(minHeap, end)

    return len(minHeap)

```

## 944. Delete Columns to Make Sorted_944.py
```python
class Solution:
  def minDeletionSize(self, strs: List[str]) -> int:
    ans = 0

    for j in range(len(strs[0])):
      for i in range(len(strs) - 1):
        if strs[i][j] > strs[i + 1][j]:
          ans += 1
          break

    return ans

```

## 3202. Find the Maximum Length of Valid Subsequence II_3202.py
```python
class Solution:
  # Similar to 3201. Find the Maximum Length of Valid Subsequence I
  def maximumLength(self, nums: List[int], k: int) -> int:
    # dp[i][j] := the maximum length of a valid subsequence, where the last
    # number mod k equal to i and the next desired number mod k equal to j
    dp = [[0] * k for _ in range(k)]

    # Extend the pattern xyxyxy...xy.
    for x in nums:
      for y in range(k):
        dp[x % k][y] = dp[y][x % k] + 1

    return max(map(max, dp))

```

## 2080. Range Frequency Queries_2080.py
```python
class RangeFreqQuery:
  def __init__(self, arr: List[int]):
    self.valueToIndices = collections.defaultdict(list)
    for i, a in enumerate(arr):
      self.valueToIndices[a].append(i)

  def query(self, left: int, right: int, value: int) -> int:
    indices = self.valueToIndices[value]
    i = bisect_left(indices, left)
    j = bisect_right(indices, right)
    return j - i

```

## 1605. Find Valid Matrix Given Row and Column Sums_1605.py
```python
class Solution:
  def restoreMatrix(self, rowSum: List[int], colSum: List[int]) -> List[List[int]]:
    m = len(rowSum)
    n = len(colSum)
    ans = [[0] * n for _ in range(m)]

    for i in range(m):
      for j in range(n):
        ans[i][j] = min(rowSum[i], colSum[j])
        rowSum[i] -= ans[i][j]
        colSum[j] -= ans[i][j]

    return ans

```

## 84. Largest Rectangle in Histogram_84.py
```python
class Solution:
  def largestRectangleArea(self, heights: List[int]) -> int:
    ans = 0
    stack = []

    for i in range(len(heights) + 1):
      while stack and (i == len(heights) or heights[stack[-1]] > heights[i]):
        h = heights[stack.pop()]
        w = i - stack[-1] - 1 if stack else i
        ans = max(ans, h * w)
      stack.append(i)

    return ans

```

## 2782. Number of Unique Categories_2782.py
```python
# Definition for a category handler.
# class CategoryHandler:
#   def haveSameCategory(self, a: int, b: int) -> bool:
#     pass

class Solution:
  def numberOfCategories(self, n: int, categoryHandler: Optional['CategoryHandler']) -> int:
    ans = 0

    for i in range(n):
      if not any(categoryHandler.haveSameCategory(i, j) for j in range(i)):
        ans += 1

    return ans

```

## 781. Rabbits in Forest_781.py
```python
class Solution:
  def numRabbits(self, answers: List[int]) -> int:
    ans = 0
    count = collections.Counter()

    for answer in answers:
      if count[answer] % (answer + 1) == 0:
        ans += answer + 1
      count[answer] += 1

    return ans

```

## 3096. Minimum Levels to Gain More Points_3096.py
```python
class Solution:
  def minimumLevels(self, possible: List[int]) -> int:
    n = len(possible)
    nums = [num if num == 1 else -1 for num in possible]
    prefix = list(itertools.accumulate(nums, initial=0))

    for i in range(1, n):
      if prefix[i] > prefix[n] - prefix[i]:
        return i

    return -1

```

## 2992. Number of Self-Divisible Permutations_2992.py
```python
class Solution:
  def selfDivisiblePermutationCount(self, n: int) -> int:
    def dfs(num: int, used: int) -> int:
      if num > n:
        return 1

      count = 0
      for i in range(1, n + 1):
        if (used >> i & 1) == 0 and (num % i == 0 or i % num == 0):
          count += dfs(num + 1, used | 1 << i)

      return count

    return dfs(1, 0)

```

## 848. Shifting Letters_848.py
```python
class Solution:
  def shiftingLetters(self, s: str, shifts: List[int]) -> str:
    ans = []

    for i in reversed(range(len(shifts) - 1)):
      shifts[i] += shifts[i + 1]

    for c, shift in zip(s, shifts):
      ans.append(chr((ord(c) - ord('a') + shift) % 26 + ord('a')))

    return ''.join(ans)

```

## 2944. Minimum Number of Coins for Fruits_2944.py
```python
class Solution:
  def minimumCoins(self, prices: List[int]) -> int:
    n = len(prices)
    # Convert to 0-indexed for easy computation.
    # dp[i] := the minimum number of coins to acquire fruits[i:]
    dp = [math.inf] * n + [0]

    for i in range(n - 1, -1, -1):
      # Convert back to 1-indexed.
      for j in range(i + 1, min((i + 1) * 2 + 1, n + 1)):
        dp[i] = min(dp[i], prices[i] + dp[j])

    return dp[0]

```

## 991. Broken Calculator_991.py
```python
class Solution:
  def brokenCalc(self, startValue: int, target: int) -> int:
    ops = 0

    while startValue < target:
      if target % 2 == 0:
        target //= 2
      else:
        target += 1
      ops += 1

    return ops + startValue - target

```

## 831. Masking Personal Information_831.py
```python
class Solution:
  def maskPII(self, s: str) -> str:
    atIndex = s.find('@')
    if atIndex != -1:
      s = s.lower()
      return s[0] + '*' * 5 + s[atIndex - 1:]

    ans = ''.join(c for c in s if c.isdigit())

    if len(ans) == 10:
      return '***-***-' + ans[-4:]
    return '+' + '*' * (len(ans) - 10) + '-***-***-' + ans[-4:]

```

## 279. Perfect Squares_279.py
```python
class Solution:
  def numSquares(self, n: int) -> int:
    dp = [n] * (n + 1)  # 1^2 x n
    dp[0] = 0  # no way
    dp[1] = 1  # 1^2

    for i in range(2, n + 1):
      j = 1
      while j * j <= i:
        dp[i] = min(dp[i], dp[i - j * j] + 1)
        j += 1

    return dp[n]

```

## 452. Minimum Number of Arrows to Burst Balloons_452.py
```python
class Solution:
  def findMinArrowShots(self, points: List[List[int]]) -> int:
    ans = 0
    arrowX = -math.inf

    for point in sorted(points, key=lambda x: x[1]):
      if point[0] > arrowX:
        ans += 1
        arrowX = point[1]

    return ans

```

## 141. Linked List Cycle_141.py
```python
class Solution:
  def hasCycle(self, head: ListNode) -> bool:
    slow = head
    fast = head

    while fast and fast.next:
      slow = slow.next
      fast = fast.next.next
      if slow == fast:
        return True

    return False

```

## 2790. Maximum Number of Groups With Increasing Length_2790.py
```python
class Solution:
  def maxIncreasingGroups(self, usageLimits: List[int]) -> int:
    ans = 1  # the next target length
    availableLimits = 0

    for usageLimit in sorted(usageLimits):
      availableLimits += usageLimit
      # Can create groups 1, 2, ..., ans.
      if availableLimits >= ans * (ans + 1) // 2:
        ans += 1

    return ans - 1

```

## 2395. Find Subarrays With Equal Sum_2395.py
```python
class Solution:
  def findSubarrays(self, nums: List[int]) -> bool:
    seen = set()

    for a, b in zip(nums, nums[1:]):
      summ = a + b
      if summ in seen:
        return True
      seen.add(summ)

    return False

```

## 2856. Minimum Array Length After Pair Removals_2856.py
```python
class Solution:
  def minLengthAfterRemovals(self, nums: List[int]) -> int:
    n = len(nums)
    count = collections.Counter(nums)
    maxFreq = max(count.values())

    # The number with the maximum frequency cancel all the other numbers.
    if maxFreq <= n / 2:
      return n % 2
    # The number with the maximum frequency cancel all the remaining numbers.
    return maxFreq - (n - maxFreq)

```

## 1143. Longest Common Subsequence_1143.py
```python
class Solution:
  def longestCommonSubsequence(self, text1: str, text2: str) -> int:
    m = len(text1)
    n = len(text2)
    # dp[i][j] := the length of LCS(text1[0..i), text2[0..j))
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m):
      for j in range(n):
        dp[i + 1][j + 1] = \
            1 + dp[i][j] if text1[i] == text2[j] \
            else max(dp[i][j + 1], dp[i + 1][j])

    return dp[m][n]

```

## 375. Guess Number Higher or Lower II_375-2.py
```python
class Solution:
  def getMoneyAmount(self, n: int) -> int:
    # dp[i][j] := the minimum money you need to guarantee a win of picking i..j
    dp = [[0] * (n + 2) for _ in range(n + 2)]

    for d in range(1, n + 1):
      for i in range(1, n - d + 1):
        j = i + d
        dp[i][j] = math.inf
        for k in range(i, j + 1):
          dp[i][j] = min(dp[i][j], max(dp[i][k - 1], dp[k + 1][j]) + k)

    return dp[1][n]

```

## 2521. Distinct Prime Factors of Product of Array_2521.py
```python
class Solution:
  def distinctPrimeFactors(self, nums: List[int]) -> int:
    primes = set()

    for num in nums:
      self._addPrimeFactors(primes, num)

    return len(primes)

  def _addPrimeFactors(self, primes: Set[int], num: int) -> None:
    for divisor in range(2, num + 1):
      if num % divisor == 0:
        primes.add(divisor)
        while num % divisor == 0:
          num //= divisor

```

## 1184. Distance Between Bus Stops_1184.py
```python
class Solution:
  def distanceBetweenBusStops(self, distance: List[int], start: int, destination: int) -> int:
    clockwise = 0
    counterclockwise = 0

    if start > destination:
      start, destination = destination, start

    for i, d in enumerate(distance):
      if i >= start and i < destination:
        clockwise += d
      else:
        counterclockwise += d

    return min(clockwise, counterclockwise)

```

## 451. Sort Characters By Frequency_451.py
```python
class Solution:
  def frequencySort(self, s: str) -> str:
    ans = []
    buckets = [[] for _ in range(len(s) + 1)]

    for c, freq in collections.Counter(s).items():
      buckets[freq].append(c)

    for freq in reversed(range(len(buckets))):
      for c in buckets[freq]:
        ans.append(c * freq)

    return ''.join(ans)

```

## 2770. Maximum Number of Jumps to Reach the Last Index_2770.py
```python
class Solution:
  def maximumJumps(self, nums: List[int], target: int) -> int:
    n = len(nums)
    # dp[i] := the maximum number of jumps to reach i from 0
    dp = [-1] * n
    dp[0] = 0

    for j in range(1, n):
      for i in range(j):
        if dp[i] != -1 and abs(nums[j] - nums[i]) <= target:
          dp[j] = max(dp[j], dp[i] + 1)

    return dp[-1]

```

## 624. Maximum Distance in Arrays_624.py
```python
class Solution:
  def maxDistance(self, arrays: List[List[int]]) -> int:
    ans = 0
    mn = 10000
    mx = -10000

    for A in arrays:
      ans = max(ans, A[-1] - mn, mx - A[0])
      mn = min(mn, A[0])
      mx = max(mx, A[-1])

    return ans

```

## 2099. Find Subsequence of Length K With the Largest Sum_2099.py
```python
class Solution:
  def maxSubsequence(self, nums: List[int], k: int) -> List[int]:
    ans = []
    threshold = sorted(nums)[-k]
    larger = sum(num > threshold for num in nums)
    equal = k - larger

    for num in nums:
      if num > threshold:
        ans.append(num)
      elif num == threshold and equal:
        ans.append(num)
        equal -= 1

    return ans

```

## 424. Longest Repeating Character Replacement_424-2.py
```python
class Solution:
  def characterReplacement(self, s: str, k: int) -> int:
    maxCount = 0
    count = collections.Counter()

    # l and r track the maximum window instead of the valid window.
    l = 0
    for r, c in enumerate(s):
      count[c] += 1
      maxCount = max(maxCount, count[c])
      while maxCount + k < r - l + 1:
        count[s[l]] -= 1
        l += 1

    return r - l + 1

```

## 856. Score of Parentheses_856.py
```python
class Solution:
  def scoreOfParentheses(self, s: str) -> int:
    ans = 0
    layer = 0

    for a, b in itertools.pairwise(s):
      if a + b == '()':
        ans += 1 << layer
      layer += 1 if a == '(' else -1

    return ans

```

## 985. Sum of Even Numbers After Queries_985.py
```python
class Solution:
  def sumEvenAfterQueries(self, nums: List[int], queries: List[List[int]]) -> List[int]:
    ans = []
    summ = sum(a for a in nums if a % 2 == 0)

    for val, index in queries:
      if nums[index] % 2 == 0:
        summ -= nums[index]
      nums[index] += val
      if nums[index] % 2 == 0:
        summ += nums[index]
      ans.append(summ)

    return ans

```

## 1207. Unique Number of Occurrences_1207.py
```python
class Solution:
  def uniqueOccurrences(self, arr: List[int]) -> bool:
    count = collections.Counter(arr)
    occurrences = set()

    for value in count.values():
      if value in occurrences:
        return False
      occurrences.add(value)

    return True

```

## 2964. Number of Divisible Triplet Sums_2964.py
```python
class Solution:
  # Similar to 1995. Count Special Quadruplets
  def divisibleTripletCount(self, nums: List[int], d: int) -> int:
    ans = 0
    count = collections.Counter()

    for j in range(len(nums) - 1, 0, -1):  # `j` also represents k.
      for i in range(j - 1, -1, -1):
        ans += count[-(nums[i] + nums[j]) % d]
      count[nums[j] % d] += 1  # j := k

    return ans

```

## 2938. Separate Black and White Balls_2938.py
```python
class Solution:
  def minimumSteps(self, s: str) -> int:
    ans = 0
    ones = 0

    for c in s:
      if c == '1':
        ones += 1
      else:  # Move 1s to the front of the current '0'.
        ans += ones

    return ans

```

## 1385. Find the Distance Value Between Two Arrays_1385.py
```python
class Solution:
  def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:
    ans = 0

    arr2.sort()

    for a in arr1:
      i = bisect.bisect_left(arr2, a)
      if (i == len(arr2) or arr2[i] - a > d) and (i == 0 or a - arr2[i - 1] > d):
        ans += 1

    return ans

```

## 2918. Minimum Equal Sum of Two Arrays After Replacing Zeros_2918.py
```python
class Solution:
  def minSum(self, nums1: List[int], nums2: List[int]) -> int:
    sum1 = sum(nums1)
    sum2 = sum(nums2)
    zero1 = nums1.count(0)
    zero2 = nums2.count(0)
    if zero1 == 0 and sum1 < sum2 + zero2:
      return -1
    if zero2 == 0 and sum2 < sum1 + zero1:
      return -1
    return max(sum1 + zero1, sum2 + zero2)

```

## 300. Longest Increasing Subsequence_300-2.py
```python
class Solution:
  def lengthOfLIS(self, nums: List[int]) -> int:
    # tails[i] := the minimum tails of all the increasing subsequences having
    # length i + 1
    tails = []

    for num in nums:
      if not tails or num > tails[-1]:
        tails.append(num)
      else:
        tails[bisect.bisect_left(tails, num)] = num

    return len(tails)

```

## 2593. Find Score of an Array After Marking All Elements_2593.py
```python
class Solution:
  def findScore(self, nums: List[int]) -> int:
    ans = 0
    seen = set()

    for num, i in sorted([(num, i) for i, num in enumerate(nums)]):
      if i in seen:
        continue
      seen.add(i - 1)
      seen.add(i + 1)
      seen.add(i)
      ans += num

    return ans

```

## 2270. Number of Ways to Split Array_2270.py
```python
class Solution:
  def waysToSplitArray(self, nums: List[int]) -> int:
    ans = 0
    prefix = 0
    suffix = sum(nums)

    for i in range(len(nums) - 1):
      prefix += nums[i]
      suffix -= nums[i]
      if prefix >= suffix:
        ans += 1

    return ans

```

## 2644. Find the Maximum Divisibility Score_2644.py
```python
class Solution:
  def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:
    ans = -1
    maxScore = -1

    for divisor in divisors:
      score = sum([1 for num in nums if num % divisor == 0])
      if score > maxScore:
        ans = divisor
        maxScore = score
      elif score == maxScore:
        ans = min(ans, divisor)

    return ans

```

## 63. Unique Paths II_63.py
```python
class Solution:
  def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
    m = len(obstacleGrid)
    n = len(obstacleGrid[0])
    # dp[i][j] := the number of unique paths from (0, 0) to (i, j)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    dp[0][1] = 1  # Can also set dp[1][0] = 1.

    for i in range(1, m + 1):
      for j in range(1, n + 1):
        if obstacleGrid[i - 1][j - 1] == 0:
          dp[i][j] = dp[i - 1][j] + dp[i][j - 1]

    return dp[m][n]

```

## 2909. Minimum Sum of Mountain Triplets II_2909.py
```python
class Solution:
  # Same as 2908. Minimum Sum of Mountain Triplets I
  def minimumSum(self, nums: List[int]) -> int:
    ans = math.inf
    minPrefix = list(itertools.accumulate(nums, min))
    minSuffix = list(itertools.accumulate(reversed(nums), min))[::-1]

    for i, num in enumerate(nums):
      if num > minPrefix[i] and num > minSuffix[i]:
        ans = min(ans, num + minPrefix[i] + minSuffix[i])

    return -1 if ans == math.inf else ans

```

## 98. Validate Binary Search Tree_98.py
```python
class Solution:
  def isValidBST(self, root: Optional[TreeNode]) -> bool:
    def isValidBST(root: Optional[TreeNode],
                   minNode: Optional[TreeNode], maxNode: Optional[TreeNode]) -> bool:
      if not root:
        return True
      if minNode and root.val <= minNode.val:
        return False
      if maxNode and root.val >= maxNode.val:
        return False

      return isValidBST(root.left, minNode, root) and \
          isValidBST(root.right, root, maxNode)

    return isValidBST(root, None, None)

```

## 56. Merge Intervals_56.py
```python
class Solution:
  def merge(self, intervals: List[List[int]]) -> List[List[int]]:
    ans = []

    for interval in sorted(intervals):
      if not ans or ans[-1][1] < interval[0]:
        ans.append(interval)
      else:
        ans[-1][1] = max(ans[-1][1], interval[1])

    return ans

```

## 500. Keyboard Row_500.py
```python
class Solution:
  def findWords(self, words: List[str]) -> List[str]:
    ans = []
    rows = [set('qwertyuiop'), set('asdfghjkl'), set('zxcvbnm')]

    for word in words:
      lowerWord = set(word.lower())
      if any(lowerWord <= row for row in rows):
        ans.append(word)

    return ans

```

## 3128. Right Triangles_3128.py
```python
class Solution:
  def numberOfRightTriangles(self, grid: List[List[int]]) -> int:
    rows = [0] * len(grid)
    cols = [0] * len(grid[0])

    for i, row in enumerate(grid):
      for j, num in enumerate(row):
        if num == 1:
          rows[i] += 1
          cols[j] += 1

    return sum((rows[i] - 1) * (cols[j] - 1)
               for i, row in enumerate(grid)
               for j, num in enumerate(row)
               if num == 1)

```

## 3107. Minimum Operations to Make Median of Array Equal to K_3107.py
```python
class Solution:
  def minOperationsToMakeMedianK(self, nums: List[int], k: int) -> int:
    n = len(nums)
    ans = 0

    nums.sort()

    for i in range(n // 2 + 1):
      ans += max(0, nums[i] - k)

    for i in range(n // 2, n):
      ans += max(0, k - nums[i])

    return ans

```

## 962. Maximum Width Ramp_962.py
```python
class Solution:
  def maxWidthRamp(self, nums: List[int]) -> int:
    ans = 0
    stack = []

    for i, num in enumerate(nums):
      if stack == [] or num <= nums[stack[-1]]:
        stack.append(i)

    for i, num in reversed(list(enumerate(nums))):
      while stack and num >= nums[stack[-1]]:
        ans = max(ans, i - stack.pop())

    return ans

```

## 2495. Number of Subarrays Having Even Product_2495.py
```python
class Solution:
  def evenProduct(self, nums: List[int]) -> int:
    ans = 0
    numsBeforeEven = 0  # inclusively

    # e.g. nums = [1, 0, 1, 1, 0].
    # After meeting the first 0, set `numsBeforeEven` to 2. So, the number
    # between index 1 to index 3 (the one before next 0) will contribute 2 to
    # `ans`.
    for i, num in enumerate(nums):
      if num % 2 == 0:
        numsBeforeEven = i + 1
      ans += numsBeforeEven

    return ans

```

## 1974. Minimum Time to Type Word Using Special Typewriter_1974.py
```python
class Solution:
  def minTimeToType(self, word: str) -> int:
    moves = 0
    letter = 'a'

    for c in word:
      diff = abs(ord(c) - ord(letter))
      moves += min(diff, 26 - diff)
      letter = c

    return moves + len(word)

```

## 1612. Check If Two Expression Trees are Equivalent_1612.py
```python
class Solution:
  def checkEquivalence(self, root1: 'Node', root2: 'Node') -> bool:
    count = collections.Counter()

    def dfs(root: 'Node', add: int) -> None:
      if not root:
        return
      if 'a' <= root.val <= 'z':
        count[root.val] += add
      dfs(root.left, add)
      dfs(root.right, add)

    dfs(root1, 1)
    dfs(root2, -1)
    return all(value == 0 for value in count.values())

```

## 2588. Count the Number of Beautiful Subarrays_2588.py
```python
class Solution:
  def beautifulSubarrays(self, nums: List[int]) -> int:
    # A subarray is beautiful if xor(subarray) = 0.
    ans = 0
    prefix = 0
    prefixCount = collections.Counter({0: 1})

    for num in nums:
      prefix ^= num
      ans += prefixCount[prefix]
      prefixCount[prefix] += 1

    return ans

```

## 3144. Minimum Substring Partition of Equal Character Frequency_3144.py
```python
class Solution:
  def minimumSubstringsInPartition(self, s: str) -> int:
    n = len(s)
    # dp[i] := the minimum number of substrings in s[0..i]
    dp = [n] * n

    for i in range(n):
      count = collections.Counter()
      for j in range(i, -1, -1):
        count[s[j]] += 1
        # word[j..i] is balanced.
        if min(count.values()) == max(count.values()):
          dp[i] = min(dp[i], 1 + dp[j - 1] if j > 0 else 1)

    return dp[-1]

```

## 2432. The Employee That Worked on the Longest Task_2432.py
```python
class Solution:
  def hardestWorker(self, n: int, logs: List[List[int]]) -> int:
    ans = logs[0][0]
    maxWorkingTime = logs[0][1]

    for (_, prevLeaveTime), (id, leaveTime) in zip(logs, logs[1:]):
      workingTime = leaveTime - prevLeaveTime
      if workingTime > maxWorkingTime:
        ans = id
        maxWorkingTime = workingTime
      elif workingTime == maxWorkingTime:
        ans = min(ans, id)

    return ans

```

## 1089. Duplicate Zeros_1089.py
```python
class Solution:
  def duplicateZeros(self, arr: List[int]) -> None:
    zeros = arr.count(0)
    i = len(arr) - 1
    j = len(arr) + zeros - 1

    while i < j:
      if j < len(arr):
        arr[j] = arr[i]
      if arr[i] == 0:
        j -= 1
        if j < len(arr):
          arr[j] = arr[i]
      i -= 1
      j -= 1

```

## 2320. Count Number of Ways to Place Houses_2320.py
```python
class Solution:
  def countHousePlacements(self, n: int) -> int:
    kMod = 1_000_000_007
    house = 1  # the number of ways ending in a house
    space = 1  # the number of ways ending in a space
    total = house + space

    for _ in range(2, n + 1):
      house = space
      space = total
      total = (house + space) % kMod

    return total**2 % kMod

```

## 2899. Last Visited Integers_2899.py
```python
class Solution:
  def lastVisitedIntegers(self, words: List[str]) -> List[int]:
    ans = []
    nums = []
    k = 0

    for word in words:
      if word == 'prev':
        k += 1
        ans.append(-1 if k > len(nums) else nums[-k])
      else:
        k = 0
        nums.append(int(word))

    return ans

```

## 974. Subarray Sums Divisible by K_974.py
```python
class Solution:
  def subarraysDivByK(self, nums: List[int], k: int) -> int:
    ans = 0
    prefix = 0
    count = [0] * k
    count[0] = 1

    for num in nums:
      prefix = (prefix + num % k + k) % k
      ans += count[prefix]
      count[prefix] += 1

    return ans

```

## 375. Guess Number Higher or Lower II_375.py
```python
class Solution:
  def getMoneyAmount(self, n: int) -> int:
    @functools.lru_cache(None)
    def dp(i: int, j: int) -> int:
      """Returns the minimum money you need to guarantee a win of picking i..j.
      """
      if i >= j:
        return 0
      return min(max(dp(i, k - 1), dp(k + 1, j)) + k
                 for k in range(i, j + 1))

    return dp(1, n)

```

## 1983. Widest Pair of Indices With Equal Range Sum_1983.py
```python
class Solution:
  def widestPairOfIndices(self, nums1: List[int], nums2: List[int]) -> int:
    ans = 0
    prefix = 0
    prefixToIndex = {0: -1}

    for i, (num1, num2) in enumerate(zip(nums1, nums2)):
      prefix += num1 - num2
      ans = max(ans, i - prefixToIndex.setdefault(prefix, i))

    return ans

```

## 1547. Minimum Cost to Cut a Stick_1547-2.py
```python
class Solution:
  def minCost(self, n: int, cuts: List[int]) -> int:
    A = sorted([0] + cuts + [n])

    dp = [[0] * len(A) for _ in range(len(A))]

    for d in range(2, len(A)):
      for i in range(len(A) - d):
        j = i + d
        dp[i][j] = math.inf
        for k in range(i + 1, j):
          dp[i][j] = min(dp[i][j], A[j] - A[i] + dp[i][k] + dp[k][j])

    return dp[0][len(A) - 1]

```

## 139. Word Break_139-2.py
```python
class Solution:
  def wordBreak(self, s: str, wordDict: List[str]) -> bool:
    wordSet = set(wordDict)

    @functools.lru_cache(None)
    def wordBreak(i: int) -> bool:
      """Returns True if s[i..n) can be segmented."""
      if i == len(s):
        return True
      return any(s[i:j] in wordSet and wordBreak(j) for j in range(i + 1, len(s) + 1))

    return wordBreak(0)

```

## 969. Pancake Sorting_969.py
```python
class Solution:
  def pancakeSort(self, arr: List[int]) -> List[int]:
    ans = []

    for target in range(len(arr), 0, -1):
      index = arr.index(target)
      arr[:index + 1] = arr[:index + 1][::-1]
      arr[:target] = arr[:target][::-1]
      ans.append(index + 1)
      ans.append(target)

    return ans

```

## 2295. Replace Elements in an Array_2295.py
```python
class Solution:
  def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:
    numToIndex = {num: i for i, num in enumerate(nums)}

    for original, replaced in operations:
      index = numToIndex[original]
      nums[index] = replaced
      del numToIndex[original]
      numToIndex[replaced] = index

    return nums

```

## 2832. Maximal Range That Each Element Is Maximum in It_2832.py
```python
class Solution:
  def maximumLengthOfRanges(self, nums: List[int]) -> List[int]:
    ans = [0] * len(nums)
    stack = []  # a decreasing stack

    for i in range(len(nums) + 1):
      while stack and (i == len(nums) or nums[stack[-1]] < nums[i]):
        index = stack.pop()
        left = stack[-1] if stack else -1
        ans[index] = i - left - 1
      stack.append(i)

    return ans

```

## 3082. Find the Sum of the Power of All Subsequences_3082-3.py
```python
class Solution:
  def sumOfPower(self, nums: List[int], k: int) -> int:
    kMod = 1_000_000_007
    # dp[i] := the number of subsequences in nums so far that sums to k
    dp = [1] + [0] * k

    for num in nums:
      for i in range(k, -1, -1):
        if i < num:
          dp[i] = (dp[i] * 2) % kMod
        else:
          dp[i] = (dp[i] * 2 + dp[i - num]) % kMod

    return dp[k]

```

## 891. Sum of Subsequence Widths_891.py
```python
class Solution:
  def sumSubseqWidths(self, nums: List[int]) -> int:
    kMod = 1_000_000_007
    n = len(nums)
    ans = 0
    exp = 1

    nums.sort()

    for i in range(n):
      ans += (nums[i] - nums[n - 1 - i]) * exp
      ans %= kMod
      exp = exp * 2 % kMod

    return ans

```

## 1153. String Transforms Into Another String_1153.py
```python
class Solution:
  def canConvert(self, str1: str, str2: str) -> bool:
    if str1 == str2:
      return True

    mappings = {}

    for a, b in zip(str1, str2):
      if mappings.get(a, b) != b:
        return False
      mappings[a] = b

    # No letter in the str1 maps to > 1 letter in the str2 and there is at
    # lest one temporary letter can break any loops.
    return len(set(str2)) < 26

```

## 339. Nested List Weight Sum_339-2.py
```python
class Solution:
  def depthSum(self, nestedList: List[NestedInteger]) -> int:
    ans = 0

    def dfs(nestedList: List[NestedInteger], depth: int) -> None:
      nonlocal ans
      for ni in nestedList:
        if ni.isInteger():
          ans += ni.getInteger() * depth
        else:
          dfs(ni.getList(), depth + 1)

    dfs(nestedList, 1)
    return ans

```

## 439. Ternary Expression Parser_439.py
```python
class Solution:
  def parseTernary(self, expression: str) -> str:
    c = expression[self.i]

    if self.i + 1 == len(expression) or expression[self.i + 1] == ':':
      self.i += 2
      return str(c)

    self.i += 2
    first = self.parseTernary(expression)
    second = self.parseTernary(expression)

    return first if c == 'T' else second

  i = 0

```

## 1170. Compare Strings by Frequency of the Smallest Character_1170.py
```python
class Solution:
  def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:
    ans = []
    wordsFreq = sorted([word.count(min(word)) for word in words])

    for q in queries:
      count = q.count(min(q))
      index = bisect.bisect(wordsFreq, count)
      ans.append(len(words) - index)

    return ans

```

## 513. Find Bottom Left Tree Value_513.py
```python
class Solution:
  def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
    q = collections.deque([root])

    while q:
      root = q.popleft()
      if root.right:
        q.append(root.right)
      if root.left:
        q.append(root.left)

    return root.val

```

## 206. Reverse Linked List_206-2.py
```python
class Solution:
  def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
    prev = None
    curr = head

    while curr:
      next = curr.next
      curr.next = prev
      prev = curr
      curr = next

    return prev

```

## 2016. Maximum Difference Between Increasing Elements_2016.py
```python
class Solution:
  def maximumDifference(self, nums: List[int]) -> int:
    ans = -1
    mn = nums[0]

    for i in range(len(nums)):
      if nums[i] > mn:
        ans = max(ans, nums[i] - mn)
      mn = min(mn, nums[i])

    return ans

```

## 2431. Maximize Total Tastiness of Purchased Fruits_2431-2.py
```python
class Solution:
  def maxTastiness(self, price: List[int], tastiness: List[int], maxAmount: int, maxCoupons: int) -> int:
    # dp[j][k] := the maximum tastiness of price so far with j amount of money and k coupons
    dp = [[0] * (maxCoupons + 1) for _ in range(maxAmount + 1)]

    for p, t in zip(price, tastiness):
      for j in range(maxAmount, p // 2 - 1, -1):
        for k in range(maxCoupons, -1, -1):
          buyWithCoupon = 0 if k == 0 else dp[j - p // 2][k - 1] + t
          buyWithoutCoupon = 0 if j < p else dp[j - p][k] + t
          dp[j][k] = max(dp[j][k], buyWithCoupon, buyWithoutCoupon)

    return dp[maxAmount][maxCoupons]

```

## 1855. Maximum Distance Between a Pair of Values_1855.py
```python
class Solution:
  def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
    ans = 0
    i = 0
    j = 0

    while i < len(nums1) and j < len(nums2):
      if nums1[i] > nums2[j]:
        i += 1
      else:
        ans = max(ans, j - i)
        j += 1

    return ans

```

## 516. Longest Palindromic Subsequence_516.py
```python
class Solution:
  def longestPalindromeSubseq(self, s: str) -> int:
    @functools.lru_cache(None)
    def dp(i: int, j: int) -> int:
      """Returns the length of LPS(s[i..j])."""
      if i > j:
        return 0
      if i == j:
        return 1
      if s[i] == s[j]:
        return 2 + dp(i + 1, j - 1)
      return max(dp(i + 1, j), dp(i, j - 1))

    return dp(0, len(s) - 1)

```

## 3113. Find the Number of Subarrays Where Boundary Elements Are Maximum_3113.py
```python
class Solution:
  def numberOfSubarrays(self, nums: List[int]) -> int:
    ans = 0
    stack = []

    for num in nums:
      while stack and stack[-1][0] < num:
        stack.pop()
      if not stack or stack[-1][0] != num:
        stack.append([num, 0])
      stack[-1][1] += 1
      ans += stack[-1][1]

    return ans

```

## 1235. Maximum Profit in Job Scheduling_1235-2.py
```python
class Solution:
  def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:
    # dp[i] := the maximum profit to schedule jobs[i..n)
    dp = [0] * (len(startTime) + 1)
    jobs = sorted([(s, e, p) for s, e, p in zip(startTime, endTime, profit)])

    for i in range(len(startTime)):
      startTime[i] = jobs[i][0]

    for i in reversed(range(len(startTime))):
      j = bisect.bisect_left(startTime, jobs[i][1])
      dp[i] = max(jobs[i][2] + dp[j], dp[i + 1])

    return dp[0]

```

## 3196. Maximize Total Cost of Alternating Subarrays_3196.py
```python
class Solution:
  def maximumTotalCost(self, nums: List[int]) -> int:
    keep = nums[0]  # the maximum cost if the last number is kept
    flip = nums[0]  # the maximum cost if the last number is flipped

    for i in range(1, len(nums)):
      keepCurr = max(keep, flip) + nums[i]
      flipCurr = keep - nums[i]
      keep = keepCurr
      flip = flipCurr

    return max(keep, flip)

```

## 553. Optimal Division_553.py
```python
class Solution:
  def optimalDivision(self, nums: List[int]) -> str:
    ans = str(nums[0])

    if len(nums) == 1:
      return ans
    if len(nums) == 2:
      return ans + '/' + str(nums[1])

    ans += '/(' + str(nums[1])
    for i in range(2, len(nums)):
      ans += '/' + str(nums[i])
    ans += ')'
    return ans

```

## 2391. Minimum Amount of Time to Collect Garbage_2391.py
```python
class Solution:
  def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:
    prefix = list(itertools.accumulate(travel))

    def getTime(c: str) -> int:
      characterCount = 0
      lastIndex = -1
      for i, s in enumerate(garbage):
        if any(g == c for g in s):
          lastIndex = i
        characterCount += s.count(c)
      return characterCount + (0 if lastIndex <= 0 else prefix[lastIndex - 1])

    return getTime('M') + getTime('P') + getTime('G')

```

## 2748. Number of Beautiful Pairs_2748.py
```python
class Solution:
  def countBeautifulPairs(self, nums: List[int]) -> int:
    def firstDigit(num: int) -> int:
      return int(str(num)[0])

    def lastDigit(num: int) -> int:
      return num % 10

    return sum(math.gcd(firstDigit(nums[i]), lastDigit(nums[j])) == 1
               for i in range(len(nums))
               for j in range(i + 1, len(nums)))

```

## 2548. Maximum Price to Fill a Bag_2548.py
```python
class Solution:
  def maxPrice(self, items: List[List[int]], capacity: int) -> float:
    ans = 0

    # Sort items based on price//weight.
    for price, weight in sorted(items, key=lambda x: -x[0] / x[1]):
      # The bag is filled.
      if capacity <= weight:
        return ans + price * capacity / weight
      ans += price
      capacity -= weight

    return -1

```

## 2145. Count the Hidden Sequences_2145-2.py
```python
class Solution:
  def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:
    prefix = 0
    mn = 0  # Starts from 0.
    mx = 0  # Starts from 0.

    for d in differences:
      prefix += d
      mn = min(mn, prefix)
      mx = max(mx, prefix)

    return max(0, (upper - lower) - (mx - mn) + 1)

```

## 1564. Put Boxes Into the Warehouse I_1564.py
```python
class Solution:
  def maxBoxesInWarehouse(self, boxes: List[int], warehouse: List[int]) -> int:
    realWarehouse = [warehouse[0]]

    for i in range(1, len(warehouse)):
      realWarehouse.append(min(realWarehouse[-1], warehouse[i]))

    boxes.sort()
    i = 0  # boxes' index
    for height in reversed(realWarehouse):
      if i < len(boxes) and boxes[i] <= height:
        i += 1

    return i

```

## 1358. Number of Substrings Containing All Three Characters_1358-2.py
```python
class Solution:
  # Similar to 3. Longest SubWithout Repeating Characters
  def numberOfSubstrings(self, s: str) -> int:
    ans = 0
    # lastSeen[c] := the index of the last time c appeared
    lastSeen = {c: -1 for c in 'abc'}

    for i, c in enumerate(s):
      lastSeen[c] = i
      # s[0..i], s[1..i], s[min(lastSeen)..i] are satisfied strings.
      ans += 1 + min(lastSeen.values())

    return ans

```

## 2514. Count Anagrams_2514.py
```python
class Solution:
  def countAnagrams(self, s: str) -> int:
    ans = 1

    for word in s.split():
      ans = ans * math.factorial(len(word))
      count = collections.Counter(word)
      for freq in count.values():
        ans //= math.factorial(freq)

    return ans % 1_000_000_007

```

## 1796. Second Largest Digit in a String_1796.py
```python
class Solution:
  def secondHighest(self, s: str) -> int:
    maxDigit = -1
    secondMaxDigit = -1

    for c in s:
      if c.isdigit():
        d = int(c)
        if d > maxDigit:
          secondMaxDigit = maxDigit
          maxDigit = d
        elif maxDigit > d > secondMaxDigit:
          secondMaxDigit = d

    return secondMaxDigit

```

## 3035. Maximum Palindromes After Operations_3035.py
```python
class Solution:
  def maxPalindromesAfterOperations(self, words: List[str]) -> int:
    ans = 0
    count = collections.Counter(''.join(words))
    pairs = sum(value // 2 for value in count.values())

    for length in sorted(len(word) for word in words):
      needPairs = length // 2
      if pairs < needPairs:
        return ans
      ans += 1
      pairs -= needPairs

    return ans

```

## 204. Count Primes_204.py
```python
class Solution:
  def countPrimes(self, n: int) -> int:
    if n <= 2:
      return 0
    return sum(self._sieveEratosthenes(n))

  def _sieveEratosthenes(self, n: int) -> List[bool]:
    isPrime = [True] * n
    isPrime[0] = False
    isPrime[1] = False
    for i in range(2, int(n**0.5) + 1):
      if isPrime[i]:
        for j in range(i * i, n, i):
          isPrime[j] = False
    return isPrime

```

## 3090. Maximum Length Substring With Two Occurrences_3090.py
```python
class Solution:
  def maximumLengthSubstring(self, s: str) -> int:
    ans = 0
    count = collections.Counter()

    l = 0
    for r, c in enumerate(s):
      count[c] += 1
      while count[c] > 2:
        count[s[l]] -= 1
        l += 1
      ans = max(ans, r - l + 1)

    return ans

```

## 852. Peak Index in a Mountain Array_852.py
```python
class Solution:
  def peakIndexInMountainArray(self, arr: List[int]) -> int:
    l = 0
    r = len(arr) - 1

    while l < r:
      m = (l + r) // 2
      if arr[m] >= arr[m + 1]:
        r = m
      else:
        l = m + 1

    return l

```

## 695. Max Area of Island_695.py
```python
class Solution:
  def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
    def dfs(i: int, j: int) -> int:
      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):
        return 0
      if grid[i][j] != 1:
        return 0

      grid[i][j] = 2

      return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1)

    return max(dfs(i, j) for i in range(len(grid)) for j in range(len(grid[0])))

```

## 478. Generate Random Point in a Circle_478.py
```python
class Solution:
  def __init__(self, radius: float, x_center: float, y_center: float):
    self.radius = radius
    self.x_center = x_center
    self.y_center = y_center

  def randPoint(self) -> List[float]:
    length = math.sqrt(random.uniform(0, 1)) * self.radius
    degree = random.uniform(0, 1) * 2 * math.pi
    x = self.x_center + length * math.cos(degree)
    y = self.y_center + length * math.sin(degree)
    return [x, y]

```

## 2404. Most Frequent Even Element_2404.py
```python
class Solution:
  def mostFrequentEven(self, nums: List[int]) -> int:
    ans = -1
    count = collections.Counter()

    for num in nums:
      if num % 2 == 1:
        continue
      count[num] += 1
      newCount = count[num]
      maxCount = count[ans]
      if newCount > maxCount or newCount == maxCount and num < ans:
        ans = num

    return ans

```

## 2063. Vowels of All Substrings_2063.py
```python
class Solution:
  def countVowels(self, word: str) -> int:
    # dp[i] := the sum of the number of vowels of word[0..i), ...,
    # word[i - 1..i)
    dp = [0] * (len(word) + 1)

    for i, c in enumerate(word):
      dp[i + 1] = dp[i]
      if c in 'aeiou':
        dp[i + 1] += i + 1

    return sum(dp)

```

## 2810. Faulty Keyboard_2810.py
```python
class Solution:
  def finalString(self, s: str) -> str:
    dq = collections.deque()
    inversed = False

    for c in s:
      if c == 'i':
        inversed = not inversed
      elif inversed:
        dq.appendleft(c)
      else:
        dq.append(c)

    return ''.join(reversed(dq)) if inversed else ''.join(dq)

```

## 2689. Extract Kth Character From The Rope Tree_2589-2.py
```python
class Solution:
  def getKthCharacter(self, root: Optional[object], k: int) -> str:
    """:type root: Optional[RopeTreeNode]"""
    while root.len > 0:
      leftLen = 0 if root.left is None \
          else max(root.left.len, len(root.left.val))
      if leftLen >= k:
        root = root.left
      else:
        root = root.right
        k -= leftLen
    return root.val[k - 1]

```

## 2439. Minimize Maximum of Array_2439.py
```python
class Solution:
  def minimizeArrayValue(self, nums: List[int]) -> int:
    ans = 0
    prefix = 0

    for i, num in enumerate(nums):
      prefix += num
      prefixAvg = math.ceil(prefix / (i + 1))
      ans = max(ans, prefixAvg)

    return ans

```

## 238. Product of Array Except Self_238.py
```python
class Solution:
  def productExceptSelf(self, nums: List[int]) -> List[int]:
    n = len(nums)
    prefix = [1] * n  # prefix product
    suffix = [1] * n  # suffix product

    for i in range(1, n):
      prefix[i] = prefix[i - 1] * nums[i - 1]

    for i in reversed(range(n - 1)):
      suffix[i] = suffix[i + 1] * nums[i + 1]

    return [prefix[i] * suffix[i] for i in range(n)]

```

## 817. Linked List Components_817.py
```python
class Solution:
  def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:
    ans = 0
    numsSet = set(nums)

    while head:
      if head.val in numsSet and (head.next == None or head.next.val not in numsSet):
        ans += 1
      head = head.next

    return ans

```

## 2022. Convert 1D Array Into 2D Array_2022.py
```python
class Solution:
  def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:
    if len(original) != m * n:
      return []

    ans = [[0] * n for _ in range(m)]

    for i, num in enumerate(original):
      ans[i // n][i % n] = num

    return ans

```

## 2415. Reverse Odd Levels of Binary Tree_2415.py
```python
class Solution:
  def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
    def dfs(left: Optional[TreeNode], right: Optional[TreeNode], isOddLevel: bool) -> None:
      if not left:
        return
      if isOddLevel:
        left.val, right.val = right.val, left.val
      dfs(left.left, right.right, not isOddLevel)
      dfs(left.right, right.left, not isOddLevel)

    dfs(root.left, root.right, True)
    return root

```

## 35. Search Insert Position_35.py
```python
class Solution:
  def searchInsert(self, nums: List[int], target: int) -> int:
    l = 0
    r = len(nums)

    while l < r:
      m = (l + r) // 2
      if nums[m] == target:
        return m
      if nums[m] < target:
        l = m + 1
      else:
        r = m

    return l

```

## 1828. Queries on Number of Points Inside a Circle_1828.py
```python
class Solution:
  def countPoints(self, points: List[List[int]], queries: List[List[int]]) -> List[int]:
    ans = []

    for xj, yj, rj in queries:
      count = 0
      for xi, yi in points:
        if (xi - xj)**2 + (yi - yj)**2 <= rj**2:
          count += 1
      ans.append(count)

    return ans

```

## 2350. Shortest Impossible Sequence of Rolls_2350.py
```python
class Solution:
  def shortestSequence(self, rolls: List[int], k: int) -> int:
    ans = 1  # the the next target length
    seen = set()

    for roll in rolls:
      seen.add(roll)
      if len(seen) == k:
        # Have all combinations that form `ans` length, and we are going to
        # extend the sequence to `ans + 1` length.
        ans += 1
        seen.clear()

    return ans

```

## 2682. Find the Losers of the Circular Game_2682.py
```python
class Solution:
  def circularGameLosers(self, n: int, k: int) -> List[int]:
    seen = [False] * n
    friendIndex = 0
    turn = 1

    while not seen[friendIndex]:
      seen[friendIndex] = True
      friendIndex += turn * k
      friendIndex %= n
      turn += 1

    return [friendIndex + 1
            for friendIndex in range(n)
            if not seen[friendIndex]]

```

## 1608. Special Array With X Elements Greater Than or Equal X_1608.py
```python
class Solution:
  def specialArray(self, nums: List[int]) -> int:
    nums.sort()

    if nums[0] >= len(nums):
      return len(nums)

    for i, (a, b) in enumerate(itertools.pairwise(nums)):
      count = len(nums) - i - 1
      if a < count and b >= count:
        return count

    return -1

```

## 915. Partition Array into Disjoint Intervals_915.py
```python
class Solution:
  def partitionDisjoint(self, nums: List[int]) -> int:
    n = len(nums)
    mn = [0] * (n - 1) + [nums[-1]]
    mx = -math.inf

    for i in range(n - 2, - 1, -1):
      mn[i] = min(mn[i + 1], nums[i])

    for i, num in enumerate(nums):
      mx = max(mx, num)
      if mx <= mn[i + 1]:
        return i + 1

```

## 2585. Number of Ways to Earn Points_2585-2.py
```python
class Solution:
  def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:
    kMod = 1_000_000_007
    # dp[j] := the number of ways to earn j points with the types so far
    dp = [1] + [0] * target

    for count, mark in types:
      for j in range(target, -1, -1):
        for solved in range(1, count + 1):
          if j - solved * mark >= 0:
            dp[j] += dp[j - solved * mark]
            dp[j] %= kMod

    return dp[target]

```

## 2087. Minimum Cost Homecoming of a Robot in a Grid_2087.py
```python
class Solution:
  def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:
    ans = 0
    i, j = startPos
    x, y = homePos

    while i != x:
      i += 1 if i < x else -1
      ans += rowCosts[i]

    while j != y:
      j += 1 if j < y else -1
      ans += colCosts[j]

    return ans

```

## 692. Top K Frequent Words_692.py
```python
class Solution:
  def topKFrequent(self, words: List[str], k: int) -> List[str]:
    ans = []
    bucket = [[] for _ in range(len(words) + 1)]

    for word, freq in collections.Counter(words).items():
      bucket[freq].append(word)

    for b in reversed(bucket):
      for word in sorted(b):
        ans.append(word)
        if len(ans) == k:
          return ans

```

## 674. Longest Continuous Increasing Subsequence_674.py
```python
class Solution:
  def findLengthOfLCIS(self, nums: List[int]) -> int:
    ans = 0
    j = 0

    for i in range(len(nums)):
      if i > 0 and nums[i] <= nums[i - 1]:
        j = i
      ans = max(ans, i - j + 1)

    return ans

```

## 2078. Two Furthest Houses With Different Colors_2078.py
```python
class Solution:
  def maxDistance(self, colors: List[int]) -> int:
    # The maximum distance always includes either the first or the last house.
    n = len(colors)
    i = 0  # the leftmost index, where colors[i] != colors[-1]
    j = n - 1  # the rightmost index, where colors[j] != colors[0]
    while colors[i] == colors[-1]:
      i += 1
    while colors[j] == colors[0]:
      j -= 1
    return max(n - 1 - i, j)

```

## 1309. Decrypt String from Alphabet to Integer Mapping_1309.py
```python
class Solution:
  def freqAlphabets(self, s: str) -> str:
    ans = ''
    i = 0

    while i < len(s):
      if i + 2 < len(s) and s[i + 2] == '#':
        ans += chr(int(s[i:i + 2]) + ord('a') - 1)
        i += 3
      else:
        ans += chr(int(s[i]) + ord('a') - 1)
        i += 1

    return ans

```

## 3010. Divide an Array Into Subarrays With Minimum Cost I_3010.py
```python
class Solution:
  def minimumCost(self, nums: List[int]) -> int:
    kMax = 50
    min1 = kMax
    min2 = kMax

    for i in range(1, len(nums)):
      if nums[i] < min1:
        min2 = min1
        min1 = nums[i]
      elif nums[i] < min2:
        min2 = nums[i]

    return nums[0] + min1 + min2

```

## 477. Total Hamming Distance_477.py
```python
class Solution:
  def totalHammingDistance(self, nums: List[int]) -> int:
    kMaxBit = 30
    ans = 0

    for i in range(kMaxBit):
      ones = sum(num & (1 << i) > 0 for num in nums)
      zeros = len(nums) - ones
      ans += ones * zeros

    return ans

```

## 2730. Find the Longest Semi-Repetitive Substring_2730.py
```python
class Solution:
  def longestSemiRepetitiveSubstring(self, s: str) -> int:
    ans = 1
    prevStart = 0
    start = 0

    for i in range(1, len(s)):
      if s[i] == s[i - 1]:
        if prevStart > 0:
          start = prevStart
        prevStart = i
      ans = max(ans, i - start + 1)

    return ans

```

## 2181. Merge Nodes in Between Zeros_2181.py
```python
class Solution:
  def mergeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:
    if not head:
      return None
    if not head.next.val:
      node = ListNode(head.val)
      node.next = self.mergeNodes(head.next.next)
      return node

    next = self.mergeNodes(head.next)
    next.val += head.val
    return next

```

## 376. Wiggle Subsequence_376.py
```python
class Solution:
  def wiggleMaxLength(self, nums: List[int]) -> int:
    increasing = 1
    decreasing = 1

    for a, b in itertools.pairwise(nums):
      if b > a:
        increasing = decreasing + 1
      elif b < a:
        decreasing = increasing + 1

    return max(increasing, decreasing)

```

## 858. Mirror Reflection_858.py
```python
class Solution:
  def mirrorReflection(self, p: int, q: int) -> int:
    while p % 2 == 0 and q % 2 == 0:
      p //= 2
      q //= 2

    if p % 2 == 0:
      return 2
    if q % 2 == 0:
      return 0
    return 1

```

## 1544. Make The String Great_1544.py
```python
class Solution:
  def makeGood(self, s: str) -> str:
    ans = []
    for c in s:
      if ans and self._is_bad_pair(ans[-1], c):
        ans.pop()
      else:
        ans.append(c)
    return ''.join(ans)

  def _is_bad_pair(self, a: str, b: str) -> bool:
    return a != b and a.lower() == b.lower()

```

## 1710. Maximum Units on a Truck_1710.py
```python
class Solution:
  def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:
    ans = 0

    for boxes, units in sorted(boxTypes, key=lambda x: -x[1]):
      if boxes >= truckSize:
        return ans + truckSize * units
      ans += boxes * units
      truckSize -= boxes

    return ans

```

## 239. Sliding Window Maximum_239.py
```python
class Solution:
  def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
    ans = []
    maxQ = collections.deque()

    for i, num in enumerate(nums):
      while maxQ and maxQ[-1] < num:
        maxQ.pop()
      maxQ.append(num)
      if i >= k and nums[i - k] == maxQ[0]:  # out-of-bounds
        maxQ.popleft()
      if i >= k - 1:
        ans.append(maxQ[0])

    return ans

```

## 349. Intersection of Two Arrays_349.py
```python
class Solution:
  def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
    ans = []
    nums1 = set(nums1)

    for num in nums2:
      if num in nums1:
        ans.append(num)
        nums1.remove(num)

    return ans

```

## 841. Keys and Rooms_841.py
```python
class Solution:
  def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
    seen = [False] * len(rooms)

    def dfs(node: int) -> None:
      seen[node] = True
      for child in rooms[node]:
        if not seen[child]:
          dfs(child)

    dfs(0)
    return all(seen)

```

## 941. Valid Mountain Array_941.py
```python
class Solution:
  def validMountainArray(self, arr: List[int]) -> bool:
    if len(arr) < 3:
      return False

    l = 0
    r = len(arr) - 1

    while l + 1 < len(arr) and arr[l] < arr[l + 1]:
      l += 1
    while r > 0 and arr[r] < arr[r - 1]:
      r -= 1

    return l > 0 and r < len(arr) - 1 and l == r

```

## 2048. Next Greater Numerically Balanced Number_2048.py
```python
class Solution:
  def nextBeautifulNumber(self, n: int) -> int:
    def isBalance(num: int) -> bool:
      count = [0] * 10
      while num:
        if num % 10 == 0:
          return False
        count[num % 10] += 1
        num //= 10
      return all(c == i for i, c in enumerate(count) if c)

    n += 1
    while not isBalance(n):
      n += 1
    return n

```

## 1464. Maximum Product of Two Elements in an Array_1464.py
```python
class Solution:
  def maxProduct(self, nums: List[int]) -> int:
    max1 = 0
    max2 = 0

    for num in nums:
      if num > max1:
        max2, max1 = max1, num
      elif num > max2:
        max2 = num

    return (max1 - 1) * (max2 - 1)

```

## 2202. Maximize the Topmost Element After K Moves_2202.py
```python
class Solution:
  def maximumTop(self, nums: List[int], k: int) -> int:
    n = len(nums)
    # After taking k elements, if we're left something, then we return nums[k]
    # Otherwise, return -1.
    if k == 0 or k == 1:
      return -1 if n == k else nums[k]
    # Remove then add even number of times.
    if n == 1:
      return -1 if k & 1 else nums[0]
    # Take min(n, k - 1) elements and put the largest one back.
    mx = max(nums[:min(n, k - 1)])
    if k >= n:
      return mx
    return max(mx, nums[k])

```

## 397. Integer Replacement_397.py
```python
class Solution:
  def integerReplacement(self, n: int) -> int:
    ans = 0

    while n > 1:
      if n % 2 == 0:  # `n` ends in 0.
        n >>= 1
      elif n == 3 or (n >> 1 & 1) == 0:  # `n` = 3 or ends in 0b01.
        n -= 1
      else:  # `n` ends in 0b11.
        n += 1
      ans += 1

    return ans

```

## 1673. Find the Most Competitive Subsequence_1673.py
```python
class Solution:
  def mostCompetitive(self, nums: List[int], k: int) -> List[int]:
    ans = []

    for i, num in enumerate(nums):
      # If |ans| - 1 + |nums[i..n)| >= k, then it means we still have enough
      # numbers, and we can safely pop an element from ans.
      while ans and ans[-1] > nums[i] and len(ans) - 1 + len(nums) - i >= k:
        ans.pop()
      if len(ans) < k:
        ans.append(nums[i])

    return ans

```

## 1749. Maximum Absolute Sum of Any Subarray_1749-2.py
```python
class Solution:
  def maxAbsoluteSum(self, nums):
    summ = 0
    maxPrefix = 0
    minPrefix = 0

    for num in nums:
      summ += num
      maxPrefix = max(maxPrefix, summ)
      minPrefix = min(minPrefix, summ)

    return maxPrefix - minPrefix

```

## 1004. Max Consecutive Ones III_1004.py
```python
class Solution:
  def longestOnes(self, nums: List[int], k: int) -> int:
    ans = 0

    l = 0
    for r, num in enumerate(nums):
      if num == 0:
        k -= 1
      while k < 0:
        if nums[l] == 0:
          k += 1
        l += 1
      ans = max(ans, r - l + 1)

    return ans

```

## 509. Fibonacci Number_509.py
```python
class Solution:
  def fib(self, n: int) -> int:
    if n < 2:
      return n

    dp = [0, 0, 1]

    for i in range(2, n + 1):
      dp[0] = dp[1]
      dp[1] = dp[2]
      dp[2] = dp[0] + dp[1]

    return dp[2]

```

