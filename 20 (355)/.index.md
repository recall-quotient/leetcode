## 132. Palindrome Partitioning II_132.py
```python
class Solution:
  def minCut(self, s: str) -> int:
    n = len(s)
    # isPalindrome[i][j] := True if s[i..j] is a palindrome
    isPalindrome = [[True] * n for _ in range(n)]
    # dp[i] := the minimum cuts needed for a palindrome partitioning of s[0..i]
    dp = [n] * n

    for l in range(2, n + 1):
      i = 0
      for j in range(l - 1, n):
        isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i + 1][j - 1]
        i += 1

    for i in range(n):
      if isPalindrome[0][i]:
        dp[i] = 0
        continue

      # Try all the possible partitions.
      for j in range(i):
        if isPalindrome[j + 1][i]:
          dp[i] = min(dp[i], dp[j] + 1)

    return dp[-1]

```

## 1190. Reverse Substrings Between Each Pair of Parentheses_1190-2.py
```python
class Solution:
  def reverseParentheses(self, s: str) -> str:
    ans = []
    stack = []
    pair = {}

    for i, c in enumerate(s):
      if c == '(':
        stack.append(i)
      elif c == ')':
        j = stack.pop()
        pair[i] = j
        pair[j] = i

    i = 0
    d = 1
    while i < len(s):
      if s[i] in '()':
        i = pair[i]
        d = -d
      else:
        ans.append(s[i])
      i += d

    return ''.join(ans)

```

## 2409. Count Days Spent Together_2409.py
```python
class Solution:
  def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:
    days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

    def toDays(s: str) -> int:
      month = int(s[:2])
      day = int(s[3:])
      prevDays = 0
      for m in range(1, month):
        prevDays += days[m]
      return prevDays + day

    arriveA = toDays(arriveAlice)
    leaveA = toDays(leaveAlice)
    arriveB = toDays(arriveBob)
    leaveB = toDays(leaveBob)
    ans = 0

    for day in range(1, 366):
      if arriveA <= day and day <= leaveA and arriveB <= day and day <= leaveB:
        ans += 1

    return ans

```

## 2047. Number of Valid Words in a Sentence_2047.py
```python
class Solution:
  def countValidWords(self, sentence: str) -> int:
    def isValid(token: str) -> bool:
      countHyphen = 0
      for i, c in enumerate(token):
        if c.isdigit():
          return False
        if c == '-':
          if i == 0 or not token[i - 1].isalpha():
            return False
          if i == len(token) - 1 or not token[i + 1].isalpha():
            return False
          if countHyphen == 1:
            return False
          countHyphen += 1
        if c in ['!', '.', ',']:
          if i != len(token) - 1:
            return False
      return True

    return sum(isValid(token) for token in sentence.split())

```

## 1740. Find Distance in a Binary Tree_1740.py
```python
class Solution:
  def findDistance(self, root: TreeNode, p: int, q: int) -> int:
    def getLCA(root, p, q):
      if not root or root.val == p or root.val == q:
        return root

      l = getLCA(root.left, p, q)
      r = getLCA(root.right, p, q)

      if l and r:
        return root
      return l or r

    def dist(lca, target):
      if not lca:
        return 10000
      if lca.val == target:
        return 0
      return 1 + min(dist(lca.left, target), dist(lca.right, target))

    lca = getLCA(root, p, q)
    return dist(lca, p) + dist(lca, q)

```

## 253. Meeting Rooms II_253-2.py
```python
class Solution:
  def minMeetingRooms(self, intervals: List[List[int]]) -> int:
    n = len(intervals)
    ans = 0
    starts = []
    ends = []

    for start, end in intervals:
      starts.append(start)
      ends.append(end)

    starts.sort()
    ends.sort()

    j = 0
    for i in range(n):
      if starts[i] < ends[j]:
        ans += 1
      else:
        j += 1

    return ans

```

## 2242. Maximum Score of a Node Sequence_2242.py
```python
class Solution:
  def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:
    n = len(scores)
    ans = -1
    graph = [[] for _ in range(n)]

    for u, v in edges:
      graph[u].append((scores[v], v))
      graph[v].append((scores[u], u))

    for i in range(n):
      graph[i] = heapq.nlargest(3, graph[i])

    # To find the target sequence: a - u - v - b, enumerate each edge (u, v),
    # and find a (u's child) and b (v's child). That's why we find the 3
    # children that have the highest scores because one of the 3 children is
    # guaranteed to be valid.
    for u, v in edges:
      for scoreA, a in graph[u]:
        for scoreB, b in graph[v]:
          if a != b and a != v and b != u:
            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)

    return ans

```

## 1103. Distribute Candies to People_1103.py
```python
class Solution:
  def distributeCandies(self, candies: int, n: int) -> List[int]:
    ans = [0] * n
    rows = int((-n + (n**2 + 8 * n**2 * candies)**0.5) / (2 * n**2))
    accumN = rows * (rows - 1) * n // 2

    for i in range(n):
      ans[i] = accumN + rows * (i + 1)

    givenCandies = (n**2 * rows**2 + n * rows) // 2
    candies -= givenCandies
    lastGiven = rows * n
    i = 0

    while candies > 0:
      lastGiven += 1
      actualGiven = min(lastGiven, candies)
      candies -= actualGiven
      ans[i] += actualGiven
      i += 1

    return ans

```

## 2417. Closest Fair Integer_2417.py
```python
class Solution:
  def closestFair(self, n: int) -> int:
    digitsCount = len(str(n))
    return self._getEvenDigits(n) if digitsCount % 2 == 0 \
        else self._getOddDigits(digitsCount)

  def _getOddDigits(self, digitsCount: int) -> int:
    zeros = (digitsCount + 1) // 2
    ones = (digitsCount - 1) // 2
    return int('1' + '0' * zeros + '1' * ones)

  def _getEvenDigits(self, n: int) -> int:
    digitsCount = len(str(n))
    maxNum = int('1' + '0' * digitsCount)
    for num in range(n, maxNum):
      if self._isValidNum(num):
        return num
    return self._getOddDigits(digitsCount + 1)

  def _isValidNum(self, num: int) -> bool:
    count = 0
    for c in str(num):
      count += 1 if (ord(c) - ord('0')) % 2 == 0 else -1
    return count == 0

```

## 1297. Maximum Number of Occurrences of a Substring_1297.py
```python
class Solution:
  def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:
    # Greedily consider strings with `minSize`, so ignore `maxSize`.
    ans = 0
    letters = 0
    count = collections.Counter()
    substringCount = collections.Counter()

    l = 0
    for r, c in enumerate(s):
      count[c] += 1
      if count[c] == 1:
        letters += 1
      while letters > maxLetters or r - l + 1 > minSize:
        count[s[l]] -= 1
        if count[s[l]] == 0:
          letters -= 1
        l += 1
      if r - l + 1 == minSize:
        sub = s[l:l + minSize]
        substringCount[sub] += 1
        ans = max(ans, substringCount[sub])

    return ans

```

## 3071. Minimum Operations to Write the Letter Y on a Grid_3071.py
```python
class Solution:
  def minimumOperationsToWriteY(self, grid: List[List[int]]) -> int:
    n = len(grid)
    mid = n // 2

    def getOperations(a: int, b: int) -> int:
      """Returns the number of operations to turn Y into a and non-Y into b."""
      operations = 0
      for i, row in enumerate(grid):
        for j, num in enumerate(row):
          # For the 'Y' pattern, before the midpoint, check the diagonal and
          # anti-diagonal. After the midpoint, check the middle column.
          if (i < mid and (i == j or i + j == n - 1)) or i >= mid and j == mid:
            if num != a:
              operations += 1
          elif num != b:
            operations += 1
      return operations

    return min(getOperations(0, 1), getOperations(0, 2),
               getOperations(1, 0), getOperations(1, 2),
               getOperations(2, 0), getOperations(2, 1))

```

## 932. Beautiful Array_932.py
```python
class Solution:
  def beautifulArray(self, n: int) -> List[int]:
    A = [i for i in range(1, n + 1)]

    def partition(l: int, r: int, mask: int) -> int:
      nextSwapped = l
      for i in range(l, r + 1):
        if A[i] & mask:
          A[i], A[nextSwapped] = A[nextSwapped], A[i]
          nextSwapped += 1
      return nextSwapped - 1

    def divide(l: int, r: int, mask: int) -> None:
      if l >= r:
        return
      m = partition(l, r, mask)
      divide(l, m, mask << 1)
      divide(m + 1, r, mask << 1)

    divide(0, n - 1, 1)
    return A

```

## 2604. Minimum Time to Eat All Grains_2604.py
```python
class Solution:
  def minimumTime(self, hens: List[int], grains: List[int]) -> int:
    hens.sort()
    grains.sort()

    def canEat(time: int) -> bool:
      """Returns True if `hens` can eat all `grains` within `time`."""
      i = 0  # grains[i] := next grain to be ate
      for hen in hens:
        rightMoves = time
        if grains[i] < hen:
          # `hen` needs go back to eat `grains[i]`.
          leftMoves = hen - grains[i]
          if leftMoves > time:
            return False
          leftThenRight = time - 2 * leftMoves
          rightThenLeft = (time - leftMoves) // 2
          rightMoves = max(0, leftThenRight, rightThenLeft)
        i = bisect.bisect_right(grains, hen + rightMoves)
        if i == len(grains):
          return True
      return False

    maxMoves = int(1.5 * (max(hens + grains) - min(hens + grains)))
    return bisect.bisect_left(range(maxMoves), True, key=lambda m: canEat(m))

```

## 2021. Brightest Position on Street_2021.py
```python
from sortedcontainers import SortedDict


class Solution:
  def brightestPosition(self, lights: List[List[int]]) -> int:
    ans = math.inf
    maxBrightness = -1
    currBrightness = 0
    line = SortedDict()

    for position, rg in lights:
      start = position - rg
      end = position + rg + 1
      line[start] = line.get(start, 0) + 1
      line[end] = line.get(end, 0) - 1

    for pos, brightness in line.items():
      currBrightness += brightness
      if currBrightness > maxBrightness:
        maxBrightness = currBrightness
        ans = pos

    return ans

```

## 103. Binary Tree Zigzag Level Order Traversal_103-2.py
```python
class Solution:
  def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
    if not root:
      return []

    ans = []
    q = collections.deque([root])
    isLeftToRight = True

    while q:
      size = len(q)
      currLevel = [0] * size
      for i in range(size):
        node = q.popleft()
        index = i if isLeftToRight else size - i - 1
        currLevel[index] = node.val
        if node.left:
          q.append(node.left)
        if node.right:
          q.append(node.right)
      ans.append(currLevel)
      isLeftToRight = not isLeftToRight

    return ans

```

## 1636. Sort Array by Increasing Frequency_1636.py
```python
class T:
  def __init__(self, num: int, freq: int):
    self.num = num
    self.freq = freq

  def __lt__(self, other):
    if self.freq == other.freq:
      return self.num > other.num
    return self.freq < other.freq


class Solution:
  def frequencySort(self, nums: List[int]) -> List[int]:
    ans = []
    heap = []

    for num, freq in collections.Counter(nums).items():
      heapq.heappush(heap, T(num, freq))

    while len(heap) > 0:
      num = heap[0].num
      freq = heapq.heappop(heap).freq
      ans.extend([num] * freq)

    return ans

```

## 2896. Apply Operations to Make Two Strings Equal_2896-3.py
```python
class Solution:
  def minOperations(self, s1: str, s2: str, x: int) -> int:
    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))
                   if a != b]
    if not diffIndices:
      return 0
    # It's impossible to make two strings equal if there are odd number of
    # differences.
    if len(diffIndices) & 1:
      return -1

    #         dp := the minimum cost to correct diffIndices[i:]
    #     dpNext := the minimum cost to correct diffIndices[i + 1:]
    # dpNextNext := the minimum cost to correct diffIndices[i + 2:]
    dpNext = x / 2
    dpNextNext = 0

    for i in reversed(range(len(diffIndices) - 1)):
      dp = min(dpNext + x / 2,
               dpNextNext + diffIndices[i + 1] - diffIndices[i])
      dpNextNext = dpNext
      dpNext = dp

    return int(dp)

```

## 42. Trapping Rain Water_42-2.py
```python
class Solution:
  def trap(self, height: List[int]) -> int:
    if not height:
      return 0

    ans = 0
    l = 0
    r = len(height) - 1
    maxL = height[l]
    maxR = height[r]

    while l < r:
      if maxL < maxR:
        ans += maxL - height[l]
        l += 1
        maxL = max(maxL, height[l])
      else:
        ans += maxR - height[r]
        r -= 1
        maxR = max(maxR, height[r])

    return ans

```

## 1236. Web Crawler_1236.py
```python
# """
# This is HtmlParser's API interface.
# You should not implement it, or speculate about its implementation
# """
# Class HtmlParser(object):
#   def getUrls(self, url: str) -> List[str]:

class Solution:
  def crawl(self, startUrl: str, htmlParser: 'HtmlParser') -> List[str]:
    q = collections.deque([startUrl])
    seen = {startUrl}
    hostname = startUrl.split('/')[2]

    while q:
      currUrl = q.popleft()
      for url in htmlParser.getUrls(currUrl):
        if url in seen:
          continue
        if hostname in url:
          q.append(url)
          seen.add(url)

    return seen

```

## 2337. Move Pieces to Obtain a String_2337.py
```python
class Solution:
  def canChange(self, start: str, target: str) -> bool:
    n = len(start)
    i = 0  # start's index
    j = 0  # target's index

    while i <= n and j <= n:
      while i < n and start[i] == '_':
        i += 1
      while j < n and target[j] == '_':
        j += 1
      if i == n or j == n:
        return i == n and j == n
      if start[i] != target[j]:
        return False
      if start[i] == 'R' and i > j:
        return False
      if start[i] == 'L' and i < j:
        return False
      i += 1
      j += 1

    return True

```

## 2661. First Completely Painted Row or Column_2661.py
```python
class Solution:
  def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:
    m = len(mat)
    n = len(mat[0])
    # rows[i] := the number of painted grid in the i-th row
    rows = [0] * m
    # cols[j] := the number of painted grid in the j-th column
    cols = [0] * n
    # numToRow[num] := the i-th row of `num` in `mat`
    numToRow = [0] * (m * n + 1)
    # numToCol[num] := the j-th column of `num` in `mat`
    numToCol = [0] * (m * n + 1)

    for i, row in enumerate(mat):
      for j, num in enumerate(row):
        numToRow[num] = i
        numToCol[num] = j

    for i, a in enumerate(arr):
      rows[numToRow[a]] += 1
      if rows[numToRow[a]] == n:
        return i
      cols[numToCol[a]] += 1
      if cols[numToCol[a]] == m:
        return i

```

## 249. Group Shifted Strings_249.py
```python
class Solution:
  def groupStrings(self, strings: List[str]) -> List[List[str]]:
    keyToStrings = collections.defaultdict(list)

    def getKey(s: str) -> str:
      """
      Returns the key of 's' by pairwise calculation of differences.
      e.g. getKey("abc") -> "1,1" because diff(a, b) = 1 and diff(b, c) = 1.
      """
      diffs = []

      for i in range(1, len(s)):
        diff = (ord(s[i]) - ord(s[i - 1]) + 26) % 26
        diffs.append(str(diff))

      return ','.join(diffs)

    for s in strings:
      keyToStrings[getKey(s)].append(s)

    return keyToStrings.values()

```

## 860. Lemonade Change_860.py
```python
class Solution:
  def lemonadeChange(self, bills: List[int]) -> bool:
    count5 = 0
    count10 = 0

    for bill in bills:
      if bill == 5:
        count5 += 1
      elif bill == 10:
        count5 -= 1
        count10 += 1
      else:  # bill == 20
        if count10 > 0:
          count10 -= 1
          count5 -= 1
        else:
          count5 -= 3
      if count5 < 0:
        return False

    return True

```

## 1541. Minimum Insertions to Balance a Parentheses String_1541.py
```python
class Solution:
  def minInsertions(self, s: str) -> int:
    neededRight = 0   # Increment by 2 for each '('.
    missingLeft = 0   # Increment by 1 for each missing '('.
    missingRight = 0  # Increment by 1 for each missing ')'.

    for c in s:
      if c == '(':
        if neededRight % 2 == 1:
          # e.g. '()(...'
          missingRight += 1
          neededRight -= 1
        neededRight += 2
      else:  # c == ')'
        neededRight -= 1
        if neededRight < 0:
          # e.g. '()))...'
          missingLeft += 1
          neededRight += 2

    return neededRight + missingLeft + missingRight

```

## 2497. Maximum Star Sum of a Graph_2497.py
```python
class Solution:
  def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:
    n = len(vals)
    ans = -math.inf
    graph = [[] for _ in range(n)]

    for u, v in edges:
      graph[u].append((v, vals[v]))
      graph[v].append((u, vals[u]))

    for i, starSum in enumerate(vals):
      maxHeap = []
      for _, val in graph[i]:
        if val > 0:
          heapq.heappush(maxHeap, -val)
      j = 0
      while j < k and maxHeap:
        starSum -= heapq.heappop(maxHeap)
        j += 1
      ans = max(ans, starSum)

    return ans

```

## 2271. Maximum White Tiles Covered by a Carpet_2271.py
```python
class Solution:
  def maximumWhiteTiles(self, tiles: List[List[int]], carpetLen: int) -> int:
    if any(tile[1] - tile[0] + 1 >= carpetLen for tile in tiles):
      return carpetLen

    ans = 0
    prefix = [0] * (len(tiles) + 1)

    tiles.sort()
    starts = [tile[0] for tile in tiles]

    for i, tile in enumerate(tiles):
      length = tile[1] - tile[0] + 1
      prefix[i + 1] = prefix[i] + length

    for i, (s, _) in enumerate(tiles):
      carpetEnd = s + carpetLen - 1
      endIndex = bisect_right(starts, carpetEnd) - 1
      notCover = max(0, tiles[endIndex][1] - carpetEnd)
      ans = max(ans, prefix[endIndex + 1] - prefix[i] - notCover)

    return ans

```

## 2463. Minimum Total Distance Traveled_2463.py
```python
class Solution:
  def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:
    robot.sort()
    factory.sort()

    @functools.lru_cache(None)
    def dp(i: int, j: int, k: int) -> int:
      """
      Returns the minimum distance to fix robot[i..n) with factory[j..n), where
      factory[j] already fixed k robots.
      """
      if i == len(robot):
        return 0
      if j == len(factory):
        return math.inf
      skipFactory = dp(i, j + 1, 0)
      position, limit = factory[j]
      useFactory = dp(i + 1, j, k + 1) + abs(robot[i] - position) \
          if limit > k else math.inf
      return min(skipFactory, useFactory)

    return dp(0, 0, 0)

```

## 1604. Alert Using Same Key-Card Three or More Times in a One Hour Period_1604.py
```python
class Solution:
  def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:
    nameToMinutes = collections.defaultdict(list)

    for name, time in zip(keyName, keyTime):
      minutes = self._getMinutes(time)
      nameToMinutes[name].append(minutes)

    return sorted([name for name, minutes in nameToMinutes.items()
                   if self._hasAlert(minutes)])

  def _hasAlert(self, minutes: List[int]) -> bool:
    if len(minutes) > 70:
      return True
    minutes.sort()
    for i in range(2, len(minutes)):
      if minutes[i - 2] + 60 >= minutes[i]:
        return True
    return False

  def _getMinutes(self, time: str) -> int:
    h, m = map(int, time.split(':'))
    return 60 * h + m

```

## 1492. The kth Factor of n_1492.py
```python
class Solution:
  def kthFactor(self, n: int, k: int) -> int:
    # If i is a divisor of n, then n // i is also a divisor of n. So, we can
    # find all the divisors of n by processing the numbers <= sqrt(n).
    factor = 1
    i = 0  # the i-th factor

    while factor < math.isqrt(n):
      if n % factor == 0:
        i += 1
        if i == k:
          return factor
      factor += 1

    factor = n // factor
    while factor >= 1:
      if n % factor == 0:
        i += 1
        if i == k:
          return n // factor
      factor -= 1

    return -1

```

## 1834. Single-Threaded CPU_1834.py
```python
class Solution:
  def getOrder(self, tasks: List[List[int]]) -> List[int]:
    n = len(tasks)
    A = [[*task, i] for i, task in enumerate(tasks)]
    ans = []
    minHeap = []
    i = 0  # tasks' index
    time = 0  # the current time

    A.sort()

    while i < n or minHeap:
      if not minHeap:
        time = max(time, A[i][0])
      while i < n and time >= A[i][0]:
        heapq.heappush(minHeap, (A[i][1], A[i][2]))
        i += 1
      procTime, index = heapq.heappop(minHeap)
      time += procTime
      ans.append(index)

    return ans

```

## 1854. Maximum Population Year_1854.py
```python
class Solution:
  def maximumPopulation(self, logs: List[List[int]]) -> int:
    kMinYear = 1950
    kMaxYear = 2050
    ans = 0
    maxPopulation = 0
    runningPopulation = 0
    # population[i] := the population of year i
    population = [0] * (kMaxYear + 1)

    for birth, death in logs:
      population[birth] += 1
      population[death] -= 1

    for year in range(kMinYear, kMaxYear + 1):
      runningPopulation += population[year]
      if runningPopulation > maxPopulation:
        maxPopulation = runningPopulation
        ans = year

    return ans

```

## 44. Wildcard Matching_44.py
```python
class Solution:
  def isMatch(self, s: str, p: str) -> bool:
    m = len(s)
    n = len(p)
    # dp[i][j] := True if s[0..i) matches p[0..j)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True

    def isMatch(i: int, j: int) -> bool:
      return i >= 0 and p[j] == '?' or s[i] == p[j]

    for j, c in enumerate(p):
      if c == '*':
        dp[0][j + 1] = dp[0][j]

    for i in range(m):
      for j in range(n):
        if p[j] == '*':
          matchEmpty = dp[i + 1][j]
          matchSome = dp[i][j + 1]
          dp[i + 1][j + 1] = matchEmpty or matchSome
        elif isMatch(i, j):
          dp[i + 1][j + 1] = dp[i][j]

    return dp[m][n]

```

## 2402. Meeting Rooms III_2402.py
```python
class Solution:
  def mostBooked(self, n: int, meetings: List[List[int]]) -> int:
    count = [0] * n

    meetings.sort()

    occupied = []  # (endTime, roomId)
    availableRoomIds = [i for i in range(n)]
    heapq.heapify(availableRoomIds)

    for start, end in meetings:
      # Push meetings ending before this `meeting` in occupied to the
      # `availableRoomsIds`.
      while occupied and occupied[0][0] <= start:
        heapq.heappush(availableRoomIds, heapq.heappop(occupied)[1])
      if availableRoomIds:
        roomId = heapq.heappop(availableRoomIds)
        count[roomId] += 1
        heapq.heappush(occupied, (end, roomId))
      else:
        newStart, roomId = heapq.heappop(occupied)
        count[roomId] += 1
        heapq.heappush(occupied, (newStart + (end - start), roomId))

    return count.index(max(count))

```

## 2065. Maximum Path Quality of a Graph_2065-2.py
```python
class Solution:
  def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:
    ans = 0
    graph = [[] for _ in range(len(values))]
    # (node, quality, remainingTime, seen)
    q = collections.deque([(0, values[0], maxTime, {0})])

    for u, v, time in edges:
      graph[u].append((v, time))
      graph[v].append((u, time))

    while q:
      u, quality, remainingTime, seen = q.popleft()
      if u == 0:
        ans = max(ans, quality)
      for v, time in graph[u]:
        if time <= remainingTime:
          q.append(
              (v, quality + values[v] * (v not in seen), remainingTime - time, seen | set([v])))

    return ans

```

## 339. Nested List Weight Sum_339.py
```python
class Solution:
  def depthSum(self, nestedList: List[NestedInteger]) -> int:
    ans = 0
    depth = 0
    q = collections.deque()

    def addIntegers(nestedList: List[NestedInteger]) -> None:
      for ni in nestedList:
        q.append(ni)

    addIntegers(nestedList)

    while q:
      depth += 1
      for _ in range(len(q)):
        ni = q.popleft()
        if ni.isInteger():
          ans += ni.getInteger() * depth
        else:
          addIntegers(ni.getList())

    return ans

```

## 2902. Count of Sub-Multisets With Bounded Sum_2902.py
```python
class Solution:
  def countSubMultisets(self, nums: List[int], l: int, r: int) -> int:
    kMod = 1_000_000_007
    # dp[i] := the number of submultisets of `nums` with sum i
    dp = [1] + [0] * r
    count = collections.Counter(nums)
    zeros = count.pop(0, 0)

    for num, freq in count.items():
      # stride[i] := dp[i] + dp[i - num] + dp[i - 2 * num] + ...
      stride = dp.copy()
      for i in range(num, r + 1):
        stride[i] += stride[i - num]
      for i in range(r, 0, -1):
        if i >= num * (freq + 1):
          # dp[i] + dp[i - num] + dp[i - freq * num]
          dp[i] = stride[i] - stride[i - num * (freq + 1)]
        else:
          dp[i] = stride[i]

    return (zeros + 1) * sum(dp[l:r + 1]) % kMod

```

## 2850. Minimum Moves to Spread Stones Over Grid_2850.py
```python
class Solution:
  def minimumMoves(self, grid: List[List[int]]) -> int:
    if sum(row.count(0) for row in grid) == 0:
      return 0

    ans = math.inf

    for i in range(3):
      for j in range(3):
        if grid[i][j] == 0:
          for x in range(3):
            for y in range(3):
              if grid[x][y] > 1:
                grid[x][y] -= 1
                grid[i][j] += 1
                ans = min(ans, abs(x - i) + abs(y - j) +
                          self.minimumMoves(grid))
                grid[x][y] += 1
                grid[i][j] -= 1

    return ans

```

## 531. Lonely Pixel I_531.py
```python
class Solution:
  def findLonelyPixel(self, picture: List[List[str]]) -> int:
    m = len(picture)
    n = len(picture[0])
    ans = 0
    rows = [0] * m  # rows[i] := the number of B's in rows i
    cols = [0] * n  # cols[i] := the number of B's in cols i

    for i in range(m):
      for j in range(n):
        if picture[i][j] == 'B':
          rows[i] += 1
          cols[j] += 1

    for i in range(m):
      if rows[i] == 1:  # Only have to examine the rows if rows[i] == 1.
        for j in range(n):
          # After meeting a 'B' in this rows, break and search the next row.
          if picture[i][j] == 'B':
            if cols[j] == 1:
              ans += 1
            break

    return ans

```

## 24. Swap Nodes in Pairs_24.py
```python
class Solution:
  def swapPairs(self, head: ListNode) -> ListNode:
    def getLength(head: ListNode) -> int:
      length = 0
      while head:
        length += 1
        head = head.next
      return length

    length = getLength(head)
    dummy = ListNode(0, head)
    prev = dummy
    curr = head

    for _ in range(length // 2):
      next = curr.next
      curr.next = next.next
      next.next = prev.next
      prev.next = next
      prev = curr
      curr = curr.next

    return dummy.next

```

## 92. Reverse Linked List II_92-2.py
```python
class Solution:
  def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:
    if not head and m == n:
      return head

    dummy = ListNode(0, head)
    prev = dummy

    for _ in range(m - 1):
      prev = prev.next  # Point to the node before the sublist [m, n].

    tail = prev.next  # Be the tail of the sublist [m, n].

    # Reverse the sublist [m, n] one by one.
    for _ in range(n - m):
      cache = tail.next
      tail.next = cache.next
      cache.next = prev.next
      prev.next = cache

    return dummy.next

```

## 2280. Minimum Lines to Represent a Line Chart_2280.py
```python
class Solution:
  def minimumLines(self, stockPrices: List[List[int]]) -> int:
    ans = 0

    stockPrices.sort()

    def getSlope(p: List[int], q: List[int]) -> Tuple[int, int]:
      dx = p[0] - q[0]
      dy = p[1] - q[1]
      if dx == 0:
        return (0, p[0])
      if dy == 0:
        return (p[1], 0)
      d = gcd(dx, dy)
      return (dx // d, dy // d)

    for i in range(2, len(stockPrices)):
      a = getSlope(stockPrices[i - 2], stockPrices[i - 1])
      b = getSlope(stockPrices[i - 1], stockPrices[i])
      if a != b:
        ans += 1

    return ans + (len(stockPrices) > 1)

```

## 264. Ugly Number II_264.py
```python
class Solution:
  def nthUglyNumber(self, n: int) -> int:
    nums = [1]
    i2 = 0
    i3 = 0
    i5 = 0

    while len(nums) < n:
      next2 = nums[i2] * 2
      next3 = nums[i3] * 3
      next5 = nums[i5] * 5
      next = min(next2, next3, next5)
      if next == next2:
        i2 += 1
      if next == next3:
        i3 += 1
      if next == next5:
        i5 += 1
      nums.append(next)

    return nums[-1]

```

## 1348. Tweet Counts Per Frequency_1348.py
```python
from sortedcontainers import SortedList


class TweetCounts:
  def __init__(self):
    self.tweetNameToTimes = collections.defaultdict(SortedList)

  def recordTweet(self, tweetName: str, time: int) -> None:
    self.tweetNameToTimes[tweetName].add(time)

  def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:
    counts = []
    times = self.tweetNameToTimes[tweetName]
    chunk = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400

    # I := startTime of each chunk
    for i in range(startTime, endTime + 1, chunk):
      j = min(i + chunk, endTime + 1)  # EndTime of each chunk
      counts.append(bisect_left(times, j) - bisect_left(times, i))

    return counts

```

## 1474. Delete N Nodes After M Nodes of a Linked List_1474.py
```python
class Solution:
  def deleteNodes(self, head: Optional[ListNode], m: int, n: int) -> Optional[ListNode]:
    curr = head
    prev = None  # prev.next == curr

    while curr:
      # Set the m-th node as `prev`.
      for _ in range(m):
        if not curr:
          break
        prev = curr
        curr = curr.next
      # Set the (m + n + 1)-th node as `curr`.
      for _ in range(n):
        if not curr:
          break
        curr = curr.next
      # Delete the nodes [m + 1..n - 1].
      prev.next = curr

    return head

```

## 2476. Closest Nodes Queries in a Binary Search Tree_2476.py
```python
class Solution:
  def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:
    sortedVals = []
    self._inorder(root, sortedVals)

    def getClosestPair(query: int) -> List[int]:
      i = bisect_left(sortedVals, query)
      # query is presented in the tree, so just use [query, query].
      if i != len(sortedVals) and sortedVals[i] == query:
        return [query, query]
      # query isn't presented in the tree, so find the cloest one if possible.
      return [-1 if i == 0 else sortedVals[i - 1],
              -1 if i == len(sortedVals) else sortedVals[i]]

    return [getClosestPair(query) for query in queries]

  def _inorder(self, root: Optional[TreeNode], sortedVals: List[int]) -> None:
    """Walks the BST to collect the sorted numbers."""
    if not root:
      return
    self._inorder(root.left, sortedVals)
    sortedVals.append(root.val)
    self._inorder(root.right, sortedVals)

```

## 4. Median of Two Sorted Arrays_4.py
```python
class Solution:
  def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
    n1 = len(nums1)
    n2 = len(nums2)
    if n1 > n2:
      return self.findMedianSortedArrays(nums2, nums1)

    l = 0
    r = n1

    while l <= r:
      partition1 = (l + r) // 2
      partition2 = (n1 + n2 + 1) // 2 - partition1
      maxLeft1 = -2**31 if partition1 == 0 else nums1[partition1 - 1]
      maxLeft2 = -2**31 if partition2 == 0 else nums2[partition2 - 1]
      minRight1 = 2**31 - 1 if partition1 == n1 else nums1[partition1]
      minRight2 = 2**31 - 1 if partition2 == n2 else nums2[partition2]
      if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:
        return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5 if (n1 + n2) % 2 == 0 else max(maxLeft1, maxLeft2)
      elif maxLeft1 > minRight2:
        r = partition1 - 1
      else:
        l = partition1 + 1

```

## 1187. Make Array Strictly Increasing_1187.py
```python
class Solution:
  def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:
    # dp[i] := the minimum steps to reach i at previous round
    dp = {-1: 0}

    arr2.sort()

    for a in arr1:
      nextDp = collections.defaultdict(lambda: math.inf)
      for val, steps in dp.items():
        # It's possible to use the value in the arr1.
        if a > val:
          nextDp[a] = min(nextDp[a], steps)
        # Also try the value in the arr2.
        i = bisect_right(arr2, val)
        if i < len(arr2):
          nextDp[arr2[i]] = min(nextDp[arr2[i]], steps + 1)
      if not nextDp:
        return -1
      dp = nextDp

    return min(dp.values())

```

## 1248. Count Number of Nice Subarrays_1248.py
```python
class Solution:
  def numberOfSubarrays(self, nums: List[int], k: int) -> int:
    def numberOfSubarraysAtMost(k: int) -> int:
      ans = 0
      l = 0
      r = 0

      while r <= len(nums):
        if k >= 0:
          ans += r - l
          if r == len(nums):
            break
          if nums[r] & 1:
            k -= 1
          r += 1
        else:
          if nums[l] & 1:
            k += 1
          l += 1
      return ans

    return numberOfSubarraysAtMost(k) - numberOfSubarraysAtMost(k - 1)

```

## 2672. Number of Adjacent Elements With the Same Color_2672.py
```python
class Solution:
  def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:
    ans = []
    arr = [0] * n
    sameColors = 0

    for i, color in queries:
      if i + 1 < n:
        if arr[i + 1] > 0 and arr[i + 1] == arr[i]:
          sameColors -= 1
        if arr[i + 1] == color:
          sameColors += 1
      if i > 0:
        if arr[i - 1] > 0 and arr[i - 1] == arr[i]:
          sameColors -= 1
        if arr[i - 1] == color:
          sameColors += 1
      arr[i] = color
      ans.append(sameColors)

    return ans

```

## 972. Equal Rational Numbers_972.py
```python
class Solution:
  def isRationalEqual(self, s: str, t: str) -> bool:
    ratios = [1, 1 / 9, 1 / 99, 1 / 999, 1 / 9999]

    def valueOf(s: str) -> float:
      if s.find('(') == -1:
        return float(s)

      # Get the indices.
      leftParenIndex = s.find('(')
      rightParenIndex = s.find(')')
      dotIndex = s.find('.')

      # integerAndNonRepeating := <IntegerPart><.><NonRepeatingPart>
      integerAndNonRepeating = float(s[:leftParenIndex])
      nonRepeatingLength = leftParenIndex - dotIndex - 1

      # repeating := <RepeatingPart>
      repeating = int(s[leftParenIndex + 1:rightParenIndex])
      repeatingLength = rightParenIndex - leftParenIndex - 1
      return integerAndNonRepeating + repeating * 0.1**nonRepeatingLength * ratios[repeatingLength]

    return abs(valueOf(s) - valueOf(t)) < 1e-9

```

## 1992. Find All Groups of Farmland_1992.py
```python
class Solution:
  def findFarmland(self, land: List[List[int]]) -> List[List[int]]:
    ans = []

    def dfs(i: int, j: int, cell: List[int]) -> None:
      if i < 0 or i == len(land) or j < 0 or j == len(land[0]):
        return
      if land[i][j] != 1:
        return
      land[i][j] = 2  # Mark as visited.
      cell[0] = max(cell[0], i)
      cell[1] = max(cell[1], j)
      dfs(i + 1, j, cell)
      dfs(i, j + 1, cell)

    for i in range(len(land)):
      for j in range(len(land[0])):
        if land[i][j] == 1:
          cell = [i, j]
          dfs(i, j, cell)
          ans.append([i, j, *cell])

    return ans

```

## 3193. Count the Number of Inversions_3193.py
```python
class Solution:
  def numberOfPermutations(self, n: int, requirements: List[List[int]]) -> int:
    kMod = 1_000_000_007
    kMaxInversions = 400
    # dp[i][j] := the number of ways to arrange the first i numbers of the
    # permutation s.t. there are j inversions
    dp = [[0] * (kMaxInversions + 1) for _ in range(n + 1)]
    endToCnt = {end + 1: cnt for end, cnt in requirements}

    # There's only one way to arrange a single number with zero inversions.
    dp[1][0] = 1

    for i in range(2, n + 1):
      for newInversions in range(i):
        for j in range(kMaxInversions - newInversions + 1):
          inversionsAfterInsertion = j + newInversions
          if i in endToCnt and inversionsAfterInsertion != endToCnt[i]:
            continue
          dp[i][inversionsAfterInsertion] += dp[i - 1][j]
          dp[i][inversionsAfterInsertion] %= kMod

    return dp[n][endToCnt[n]]

```

## 2034. Stock Price Fluctuation_2034.py
```python
from sortedcontainers import SortedDict


class StockPrice:
  def __init__(self):
    self.timestampToPrice = SortedDict()
    self.pricesCount = SortedDict()

  def update(self, timestamp: int, price: int) -> None:
    if timestamp in self.timestampToPrice:
      prevPrice = self.timestampToPrice[timestamp]
      self.pricesCount[prevPrice] -= 1
      if self.pricesCount[prevPrice] == 0:
        del self.pricesCount[prevPrice]
    self.timestampToPrice[timestamp] = price
    self.pricesCount[price] = self.pricesCount.get(price, 0) + 1

  def current(self) -> int:
    return self.timestampToPrice.peekitem(-1)[1]

  def maximum(self) -> int:
    return self.pricesCount.peekitem(-1)[0]

  def minimum(self) -> int:
    return self.pricesCount.peekitem(0)[0]

```

## 313. Super Ugly Number_313-2.py
```python
class UglyNum:
  def __init__(self, prime: int, index: int, value: int):
    self.prime = prime
    self.index = index  # Point the next index of uglyNums.
    self.value = value  # prime * uglyNums[index]


class Solution:
  def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:
    minHeap = []  # (value, prime, index)
    uglyNums = [1]

    for prime in primes:
      heapq.heappush(minHeap, (prime * uglyNums[0], prime, 1))

    while len(uglyNums) < n:
      uglyNums.append(minHeap[0][0])
      while minHeap[0][0] == uglyNums[-1]:
        _, prime, index = heapq.heappop(minHeap)
        heapq.heappush(minHeap, (prime * uglyNums[index], prime, index + 1))

    return uglyNums[-1]

```

## 2276. Count Integers in Intervals_2276.py
```python
from sortedcontainers import SortedDict


class CountIntervals:
  def __init__(self):
    self.intervals = SortedDict()
    self.cnt = 0

  def add(self, left: int, right: int) -> None:
    while self._isOverlapped(left, right):
      i = self.intervals.bisect_right(right) - 1
      l, r = self.intervals.popitem(i)
      left = min(left, l)
      right = max(right, r)
      self.cnt -= r - l + 1

    self.intervals[left] = right
    self.cnt += right - left + 1

  def count(self) -> int:
    return self.cnt

  def _isOverlapped(self, left: int, right: int) -> bool:
    i = self.intervals.bisect_right(right)
    return i > 0 and self.intervals.peekitem(i - 1)[1] >= left

```

## 93. Restore IP Addresses_93.py
```python
class Solution:
  def restoreIpAddresses(self, s: str) -> List[str]:
    ans = []

    def dfs(start: int, path: List[int]) -> None:
      if len(path) == 4 and start == len(s):
        ans.append(path[0] + '.' + path[1] + '.' + path[2] + '.' + path[3])
        return
      if len(path) == 4 or start == len(s):
        return

      for length in range(1, 4):
        if start + length > len(s):
          return  # out-of-bounds
        if length > 1 and s[start] == '0':
          return  # leading '0'
        num = s[start: start + length]
        if int(num) > 255:
          return
        dfs(start + length, path + [num])

    dfs(0, [])
    return ans

```

## 2355. Maximum Number of Books You Can Take_2355.py
```python
class Solution:
  def maximumBooks(self, books: List[int]) -> int:
    # dp[i] := the maximum the number of books we can take from books[0..i] with taking all of
    # books[i]
    dp = [0] * len(books)
    stack = []  # the possible indices we can reach

    for i, book in enumerate(books):
      # We may take all of books[j], where books[j] < books[i] - (i - j).
      while stack and books[stack[-1]] >= book - (i - stack[-1]):
        stack.pop()
      # We can now take books[j + 1..i].
      j = stack[-1] if stack else -1
      lastPicked = book - (i - j) + 1
      if lastPicked > 1:
        # book + (book - 1) + ... + (book - (i - j) + 1)
        dp[i] = (book + lastPicked) * (i - j) // 2
      else:
        # 1 + 2 + ... + book
        dp[i] = book * (book + 1) // 2
      if j >= 0:
        dp[i] += dp[j]
      stack.append(i)

    return max(dp)

```

## 382. Linked List Random Node_382.py
```python
# Definition for singly-linked list.
# class ListNode:
#   def __init__(self, val=0, next=None):
#     self.val = val
#     self.next = next

class Solution:
  def __init__(self, head: Optional[ListNode]):
    self.head = head

  def getRandom(self) -> int:
    res = -1
    i = 1
    curr = self.head

    while curr:
      if random.randint(0, i - 1) == 0:
        res = curr.val
      curr = curr.next
      i += 1

    return res

```

## 3130. Find All Possible Stable Binary Arrays II_3130.py
```python
class Solution:
  # Same as 3129. Find All Possible Stable Binary Arrays I
  def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:
    kMod = 1_000_000_007
    # dp[i][j][k] := the number of stable arrays, where the number of
    # occurrences of 0 is i and the number of occurrences of 1 is j and the last
    # number is k (0/1)
    dp = [[[0] * 2
           for _ in range(one + 1)]
          for _ in range(zero + 1)]

    for i in range(min(zero, limit) + 1):
      dp[i][0][0] = 1

    for j in range(min(one, limit) + 1):
      dp[0][j][1] = 1

    for i in range(1, zero + 1):
      for j in range(1, one + 1):
        dp[i][j][0] = (dp[i - 1][j][0] + dp[i - 1][j][1] -
                       (dp[i - limit - 1][j][1] if i - limit >= 1 else 0) + kMod) % kMod
        dp[i][j][1] = (dp[i][j - 1][0] + dp[i][j - 1][1] -
                       (dp[i][j - limit - 1][0] if j - limit >= 1 else 0) + kMod) % kMod

    return (dp[zero][one][0] + dp[zero][one][1]) % kMod

```

## 2556. Disconnect Path in a Binary Matrix by at Most One Flip_2556.py
```python
class Solution:
  def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
    # Returns True is there's a path from (0, 0) to (m - 1, n - 1).
    # Also marks the visited path as 0 except (m - 1, n - 1).
    def hasPath(i: int, j: int) -> bool:
      if i == len(grid) or j == len(grid[0]):
        return False
      if i == len(grid) - 1 and j == len(grid[0]) - 1:
        return True
      if grid[i][j] == 0:
        return False

      grid[i][j] = 0
      # Go down first. Since we use OR logic, we'll only mark one path.
      return hasPath(i + 1, j) or hasPath(i, j + 1)

    if not hasPath(0, 0):
      return True
    # Reassign (0, 0) as 1.
    grid[0][0] = 1
    return not hasPath(0, 0)

```

## 2122. Recover the Original Array_2122.py
```python
class Solution:
  def recoverArray(self, nums: List[int]) -> List[int]:
    nums = sorted(nums)

    def getArray(x: int, count: collections.Counter) -> List[int]:
      A = []
      for num in nums:
        if count[num] == 0:
          continue
        if count[num + x] == 0:
          return []
        count[num] -= 1
        count[num + x] -= 1
        A.append(num + x // 2)
      return A

    count = collections.Counter(nums)

    for i in range(1, len(nums)):
      x = nums[i] - nums[0]  # 2 * k
      if x <= 0 or x % 2 == 1:
        continue
      A = getArray(x, count.copy())
      if A:
        return A

```

## 1713. Minimum Operations to Make a Subsequence_1713.py
```python
class Solution:
  def minOperations(self, target: List[int], arr: List[int]) -> int:
    indices = []
    numToIndex = {num: i for i, num in enumerate(target)}

    for a in arr:
      if a in numToIndex:
        indices.append(numToIndex[a])

    return len(target) - self._lengthOfLIS(indices)

  # Same as 300. Longest Increasing Subsequence
  def _lengthOfLIS(self, nums: List[int]) -> int:
    # tail[i] := the minimum tail of all the increasing subsequences having
    # length i + 1
    tail = []
    for num in nums:
      if not tail or num > tail[-1]:
        tail.append(num)
      else:
        tail[bisect.bisect_left(tail, num)] = num
    return len(tail)

```

## 1955. Count Number of Special Subsequences_1955-3.py
```python
class Solution:
  def countSpecialSubsequences(self, nums: List[int]) -> int:
    kMod = 1_000_000_007
    n = len(nums)
    # dp[j] := the number of increasing subsequences of the numbers so far that
    # end in j
    dp = [0] * 3

    if nums[0] == 0:
      dp[0] = 1

    for i in range(1, n):
      if nums[i] == 0:
        dp[0] = dp[0] * 2 + 1
      elif nums[i] == 1:
        dp[1] = dp[1] * 2 + dp[0]
      else:  # nums[i] == 2
        dp[2] = dp[2] * 2 + dp[1]

      for ending in range(3):
        dp[ending] %= kMod

    return dp[2]

```

## 1388. Pizza With 3n Slices_1388.py
```python
class Solution:
  def maxSizeSlices(self, slices: List[int]) -> int:
    @functools.lru_cache(None)
    def dp(i: int, j: int, k: int) -> int:
      """
      Returns the maximum the sum of slices if you can pick k slices from
      slices[i..j).
      """
      if k == 1:
        return max(slices[i:j])
      # Note that j - i is not the number of all the left slices. Since you
      # Might have chosen not to take a slice in a previous step, there would be
      # Leftovers outside [i:j]. If you take slices[i], one of the slices your
      # Friends take will be outside of [i:j], so the length of [i:j] is reduced
      # By 2 instead of 3. Therefore, the minimum # Is 2 * k - 1 (the last step only
      # Requires one slice).
      if j - i < 2 * k - 1:
        return -math.inf
      return max(slices[i] + dp(i + 2, j, k - 1),
                 dp(i + 1, j, k))

    k = len(slices) // 3
    return max(dp(0, len(slices) - 1, k),
               dp(1, len(slices), k))

```

## 1552. Magnetic Force Between Two Balls_1552.py
```python
class Solution:
  def maxDistance(self, position: List[int], m: int) -> int:
    position.sort()

    l = 1
    r = position[-1] - position[0]

    def numBalls(force: int) -> int:
      balls = 0
      prevPosition = -force
      for pos in position:
        if pos - prevPosition >= force:
          balls += 1
          prevPosition = pos
      return balls

    while l < r:
      mid = r - (r - l) // 2
      if numBalls(mid) >= m:
        l = mid
      else:
        r = mid - 1

    return l

```

## 1905. Count Sub Islands_1905.py
```python
class Solution:
  def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:
    m = len(grid2)
    n = len(grid2[0])

    def dfs(i: int, j: int) -> int:
      if i < 0 or i == m or j < 0 or j == n:
        return 1
      if grid2[i][j] != 1:
        return 1

      grid2[i][j] = 2  # Mark 2 as visited.

      return dfs(i + 1, j) & dfs(i - 1, j) & \
          dfs(i, j + 1) & dfs(i, j - 1) & grid1[i][j]

    ans = 0

    for i in range(m):
      for j in range(n):
        if grid2[i][j] == 1:
          ans += dfs(i, j)

    return ans

```

## 2962. Count Subarrays Where Max Element Appears at Least K Times_2962.py
```python
class Solution:
  def countSubarrays(self, nums: List[int], k: int) -> int:
    maxNum = max(nums)
    ans = 0
    count = 0

    l = 0
    for r, num in enumerate(nums):
      if num == maxNum:
        count += 1
      # Keep the window to include k - 1 times of the maxNummum number.
      while count == k:
        if nums[l] == maxNum:
          count -= 1
        l += 1
      # If l > 0, nums[l:r+1] has k - 1 times of the maxNummum number. For any
      # subarray nums[i:r+1], where i < l, it will have at least k times of the
      # maxNummum number, since nums[l - 1] equals the maxNummum number.
      ans += l

    return ans

```

## 95. Unique Binary Search Trees II_95.py
```python
class Solution:
  def generateTrees(self, n: int) -> List[TreeNode]:
    if n == 0:
      return []

    def generateTrees(mn: int, mx: int) -> List[Optional[int]]:
      if mn > mx:
        return [None]

      ans = []

      for i in range(mn, mx + 1):
        for left in generateTrees(mn, i - 1):
          for right in generateTrees(i + 1, mx):
            ans.append(TreeNode(i))
            ans[-1].left = left
            ans[-1].right = right

      return ans

    return generateTrees(1, n)

```

## 1958. Check if Move is Legal_1958.py
```python
class Solution:
  def checkMove(self, board: List[List[str]], rMove: int, cMove: int, color: str) -> bool:
    dirs = ((-1, -1), (-1, 0), (-1, 1), (0, -1),
            (0, 1), (1, -1), (1, 0), (1, 1))

    for dx, dy in dirs:
      cellsCount = 2
      i = rMove + dx
      j = cMove + dy
      while 0 <= i < 8 and 0 <= j < 8:
        # There are no free cells in between.
        if board[i][j] == '.':
          break
        # Need >= 3 cells.
        if cellsCount == 2 and board[i][j] == color:
          break
        # >= 3 cells.
        if board[i][j] == color:
          return True
        i += dx
        j += dy
        cellsCount += 1

    return False

```

## 1392. Longest Happy Prefix_1392.py
```python
class Solution:
  def longestPrefix(self, s: str) -> str:
    kBase = 26
    kMod = 1_000_000_007
    n = len(s)
    maxLength = 0
    pow = 1
    prefixHash = 0  # the hash of s[0..i]
    suffixHash = 0  # the hash of s[j..n)

    def val(c: str) -> int:
      return ord(c) - ord('a')

    j = n - 1
    for i in range(n - 1):
      prefixHash = (prefixHash * kBase + val(s[i])) % kMod
      suffixHash = (val(s[j]) * pow + suffixHash) % kMod
      pow = pow * kBase % kMod
      if prefixHash == suffixHash:
        maxLength = i + 1
      j -= 1

    return s[:maxLength]

```

## 546. Remove Boxes_546.py
```python
class Solution:
  def removeBoxes(self, boxes: List[int]) -> int:
    @functools.lru_cache(None)
    def dp(i: int, j: int, k: int) -> int:
      """
      Returns the maximum score of boxes[i..j] if k boxes equal to boxes[j].
      """
      if i > j:
        return 0

      r = j
      sameBoxes = k + 1
      while r > 0 and boxes[r - 1] == boxes[r]:
        r -= 1
        sameBoxes += 1
      res = dp(i, r - 1, 0) + sameBoxes * sameBoxes

      for p in range(i, r):
        if boxes[p] == boxes[r]:
          res = max(res, dp(i, p, sameBoxes) + dp(p + 1, r - 1, 0))

      return res

    return dp(0, len(boxes) - 1, 0)

```

## 40. Combination Sum II_40.py
```python
class Solution:
  def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
    ans = []

    def dfs(s: int, target: int, path: List[int]) -> None:
      if target < 0:
        return
      if target == 0:
        ans.append(path.copy())
        return

      for i in range(s, len(candidates)):
        if i > s and candidates[i] == candidates[i - 1]:
          continue
        path.append(candidates[i])
        dfs(i + 1, target - candidates[i], path)
        path.pop()

    candidates.sort()
    dfs(0, target, [])
    return ans

```

## 2477. Minimum Fuel Cost to Report to the Capital_2477.py
```python
class Solution:
  def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
    ans = 0
    tree = [[] for _ in range(len(roads) + 1)]

    for u, v in roads:
      tree[u].append(v)
      tree[v].append(u)

    def dfs(u: int, prev: int) -> int:
      nonlocal ans
      people = 1
      for v in tree[u]:
        if v == prev:
          continue
        people += dfs(v, u)
      if u > 0:
        # the number of cars needed
        ans += int(math.ceil(people / seats))
      return people

    dfs(0, -1)
    return ans

```

## 1761. Minimum Degree of a Connected Trio in a Graph_1761.py
```python
class Solution:
  def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:
    ans = math.inf
    graph = [set() for _ in range(n)]
    degrees = [0] * n

    for u, v in edges:
      u -= 1
      v -= 1
      # Store the mapping from `min(u, v)` to `max(u, v)` to speed up.
      graph[min(u, v)].add(max(u, v))
      degrees[u] += 1
      degrees[v] += 1

    for u in range(n):
      for v in graph[u]:
        for w in graph[u]:
          if w in graph[v]:
            ans = min(ans, degrees[u] + degrees[v] + degrees[w] - 6)

    return -1 if ans == math.inf else ans

```

## 2674. Split a Circular Linked List_2674.py
```python
class Solution:
  def splitCircularLinkedList(self, list: Optional[ListNode]) -> List[Optional[ListNode]]:
    slow = list
    fast = list

    # Point `slow` to the last node in the first half.
    while fast.next != list and fast.next.next != list:
      slow = slow.next
      fast = fast.next.next

    # Circle back the second half.
    secondHead = slow.next
    if fast.next == list:
      fast.next = secondHead
    else:
      fast.next.next = secondHead

    # Circle back the first half.
    slow.next = list

    return [list, secondHead]

```

## 227. Basic Calculator II_227.py
```python
class Solution:
  def calculate(self, s: str) -> int:
    ans = 0
    prevNum = 0
    currNum = 0
    op = '+'

    for i, c in enumerate(s):
      if c.isdigit():
        currNum = currNum * 10 + int(c)
      if not c.isdigit() and c != ' ' or i == len(s) - 1:
        if op == '+' or op == '-':
          ans += prevNum
          prevNum = currNum if op == '+' else -currNum
        elif op == '*':
          prevNum = prevNum * currNum
        elif op == '/':
          if prevNum < 0:
            prevNum = math.ceil(prevNum / currNum)
          else:
            prevNum = prevNum // currNum
        op = c
        currNum = 0

    return ans + prevNum

```

## 1823. Find the Winner of the Circular Game_1823-3.py
```python
class Solution:
  def findTheWinner(self, n: int, k: int) -> int:
    # e.g. n = 4, k = 2.
    # By using 0-indexed notation, we have the following circle:
    #
    # 0 -> 1 -> 2 -> 3 -> 0
    #      x
    #           0 -> 1 -> 2 -> 0
    #
    # After the first round, 1 is removed.
    # So, 2 becomes 0, 3 becomes 1, and 0 becomes 2.
    # Let's denote that oldIndex = f(n, k) and newIndex = f(n - 1, k).
    # By observation, we know f(n, k) = (f(n - 1, k) + k) % n.
    def f(n: int, k: int) -> int:
      ans = 0  # f(1, k)
      # Computes f(i, k) based on f(i - 1, k).
      for i in range(2, n + 1):
        ans = (ans + k) % i
      return ans

    # Converts back to 1-indexed.
    return f(n, k) + 1

```

## 379. Design Phone Directory_379.py
```python
class PhoneDirectory:
  def __init__(self, maxNumbers: int):
    # the next available numbers
    self.next = [i + 1 for i in range(maxNumbers - 1)] + [0]
    # the current possible available number
    self.number = 0

  def get(self) -> int:
    if self.next[self.number] == -1:
      return -1
    ans = self.number
    self.number = self.next[self.number]
    self.next[ans] = -1  # Mark as used.
    return ans

  def check(self, number: int) -> bool:
    return self.next[number] != -1

  def release(self, number: int) -> None:
    if self.next[number] != -1:
      return
    self.next[number] = self.number
    self.number = number

```

## 2941. Maximum GCD-Sum of a Subarray_2941.py
```python
class Solution:
  def maxGcdSum(self, nums: List[int], k: int) -> int:
    ans = 0
    # [(startIndex, gcd of subarray starting at startIndex)]
    startIndexAndGcds = []
    prefix = [0] + list(itertools.accumulate(nums))

    for i, num in enumerate(nums):
      nextStartIndexAndGcds = []
      for startIndex, gcd in startIndexAndGcds:
        nextGcd = math.gcd(gcd, nums[i])
        if not nextStartIndexAndGcds or \
                nextStartIndexAndGcds[-1][1] != nextGcd:  # Skip duplicates.
          nextStartIndexAndGcds.append((startIndex, nextGcd))
      startIndexAndGcds = nextStartIndexAndGcds
      startIndexAndGcds.append((i, nums[i]))
      for startIndex, gcd in startIndexAndGcds:
        if i - startIndex + 1 >= k:
          ans = max(ans, (prefix[i + 1] - prefix[startIndex]) * gcd)

    return ans

```

## 638. Shopping Offers_638.py
```python
class Solution:
  def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:
    def dfs(s: int) -> int:
      ans = 0
      for i, need in enumerate(needs):
        ans += need * price[i]

      for i in range(s, len(special)):
        offer = special[i]
        if all(offer[j] <= need for j, need in enumerate(needs)):
          # Use the special[i].
          for j in range(len(needs)):
            needs[j] -= offer[j]
          ans = min(ans, offer[-1] + dfs(i))
          # Unuse the special[i] (backtracking).
          for j in range(len(needs)):
            needs[j] += offer[j]

      return ans

    return dfs(0)

```

## 2301. Match Substring After Replacement_2301.py
```python
class Solution:
  def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:
    isMapped = [[False] * 128 for _ in range(128)]

    for old, new in mappings:
      isMapped[ord(old)][ord(new)] = True

    for i in range(len(s)):
      if self._canTransform(s, i, sub, isMapped):
        return True

    return False

  def _canTransform(self, s: str, start: int, sub: str, isMapped: List[List[bool]]) -> bool:
    if start + len(sub) > len(s):
      return False

    for i in range(len(sub)):
      a = sub[i]
      b = s[start + i]
      if a != b and not isMapped[ord(a)][ord(b)]:
        return False

    return True

```

## 1870. Minimum Speed to Arrive on Time_1870.py
```python
class Solution:
  def minSpeedOnTime(self, dist: List[int], hour: float) -> int:
    ans = -1
    l = 1
    r = int(1e7)

    def time(speed: int) -> float:
      summ = 0
      for i in range(len(dist) - 1):
        summ += math.ceil(dist[i] / speed)
      return summ + dist[-1] / speed

    while l <= r:
      m = (l + r) // 2
      if time(m) > hour:
        l = m + 1
      else:
        ans = m
        r = m - 1

    return ans

```

## 3115. Maximum Prime Difference_3115.py
```python
class Solution:
  def maximumPrimeDifference(self, nums: List[int]) -> int:
    kMax = 100
    isPrime = self._sieveEratosthenes(kMax + 1)
    minPrimeIndex = -1
    maxPrimeIndex = -1

    for i, num in enumerate(nums):
      if isPrime[num]:
        if minPrimeIndex == -1:
          minPrimeIndex = i
        maxPrimeIndex = i

    return maxPrimeIndex - minPrimeIndex

  def _sieveEratosthenes(self, n: int) -> List[bool]:
    isPrime = [True] * n
    isPrime[0] = False
    isPrime[1] = False
    for i in range(2, int(n**0.5) + 1):
      if isPrime[i]:
        for j in range(i * i, n, i):
          isPrime[j] = False
    return isPrime

```

## 2936. Number of Equal Numbers Blocks_2936.py
```python
# Definition for BigArray.
# class BigArray:
#   def at(self, index: long) -> int:
#     pass
#   def size(self) -> long:
#     pass

class Solution(object):
  def countBlocks(self, nums: Optional['BigArray']) -> int:
    def countBlocks(l: int, r: int, leftValue: int, rightValue: int) -> int:
      """Returns the number of maximal blocks in nums[l..r]."""
      if leftValue == rightValue:
        return 1
      if l + 1 == r:
        return 2
      m = (l + r) // 2
      midValue = nums.at(m)
      return countBlocks(l, m, leftValue, midValue) + countBlocks(m, r, midValue, rightValue) - 1

    # Substract nums[m], which will be counted twice.
    return countBlocks(0, nums.size() - 1,
                       nums.at(0), nums.at(nums.size() - 1))

```

## 2664. The Knight’s Tour_2664.py
```python
class Solution:
  def tourOfKnight(self, m: int, n: int, r: int, c: int) -> List[List[int]]:
    dirs = ((1, 2), (2, 1), (2, -1), (1, -2),
            (-1, -2), (-2, -1), (-2, 1), (-1, 2))
    ans = [[-1] * n for _ in range(m)]

    def dfs(i: int, j: int, step: int) -> bool:
      if step == m * n:
        return True
      if i < 0 or i >= m or j < 0 or j >= n:
        return False
      if ans[i][j] != -1:
        return False
      ans[i][j] = step
      for dx, dy in dirs:
        if dfs(i + dx, j + dy, step + 1):
          return True
      ans[i][j] = -1
      return False

    dfs(r, c, 0)
    return ans

```

## 2412. Minimum Money Required Before Transactions_2412.py
```python
class Solution:
  def minimumMoney(self, transactions: List[List[int]]) -> int:
    ans = 0
    losses = 0

    # Before picking the final transaction, perform any transaction that raises
    # the required money.
    for cost, cashback in transactions:
      losses += max(0, cost - cashback)

    # Now, pick a transaction to be the final one.
    for cost, cashback in transactions:
      if cost > cashback:
        # The losses except this transaction: losses - (cost - cashback), so
        # add the cost of this transaction = losses - (cost - cashback) + cost.
        ans = max(ans, losses + cashback)
      else:
        # The losses except this transaction: losses, so add the cost of this
        # transaction = losses + cost.
        ans = max(ans, losses + cost)

    return ans

```

## 2116. Check if a Parentheses String Can Be Valid_2116.py
```python
class Solution:
  def canBeValid(self, s: str, locked: str) -> bool:
    if len(s) % 2 == 1:
      return False

    def check(s: str, locked: str, isForward: bool) -> bool:
      changeable = 0
      l = 0
      r = 0

      for c, lock in zip(s, locked):
        if lock == '0':
          changeable += 1
        elif c == '(':
          l += 1
        else:  # c == ')'
          r += 1
        if isForward and changeable + l - r < 0:
          return False
        if not isForward and changeable + r - l < 0:
          return False

      return True

    return check(s, locked, True) and check(s[::-1], locked[::-1], False)

```

## 1588. Sum of All Odd Length Subarrays_1588.py
```python
class Solution:
  def sumOddLengthSubarrays(self, arr: List[int]) -> int:
    ans = 0
    # Maintain two sums of subarrays ending in the previous index.
    # Each time we meet a new number, we'll consider 'how many times' it should
    # contribute to the newly built subarrays by calculating the number of
    # previous even/odd-length subarrays.
    prevEvenSum = 0  # the sum of even-length subarrays
    prevOddSum = 0  # the sum of odd-length subarrays

    for i, a in enumerate(arr):
      # (i + 1) // 2 := the number of previous odd-length subarrays.
      currEvenSum = prevOddSum + ((i + 1) // 2) * a
      # i // 2 + 1 := the number of previous even-length subarrays
      # (including 0).
      currOddSum = prevEvenSum + (i // 2 + 1) * a
      ans += currOddSum
      prevEvenSum = currEvenSum
      prevOddSum = currOddSum

    return ans

```

## 2489. Number of Substrings With Fixed Ratio_2489.py
```python
class Solution:
  def fixedRatio(self, s: str, num1: int, num2: int) -> int:
    # Let x := the number of 0s and y := the number of 1s in the subarray.
    # We want x : y = num1 : num2, so our goal is to find number of subarrays
    # with x * num2 - y * num1 = 0. To achieve this, we can use a prefix count
    # map to record the count of the running x * num2 - y * num1. If the
    # running x * num2 - y * num1 = prefix, then add count[prefix] to the
    # `ans`.
    ans = 0
    prefix = 0
    prefixCount = collections.Counter({0: 1})

    for c in s:
      if c == '0':
        prefix += num2
      else:  # c == '1'
        prefix -= num1
      ans += prefixCount[prefix]
      prefixCount[prefix] += 1

    return ans

```

## 1610. Maximum Number of Visible Points_1610.py
```python
class Solution:
  def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:
    posX, posY = location
    maxVisible = 0
    same = 0
    A = []

    for x, y in points:
      if x == posX and y == posY:
        same += 1
      else:
        A.append(math.atan2(y - posY, x - posX))

    A.sort()
    A = A + [a + 2.0 * math.pi for a in A]

    angleInRadians = math.pi * (angle / 180)

    l = 0
    for r in range(len(A)):
      while A[r] - A[l] > angleInRadians:
        l += 1
      maxVisible = max(maxVisible, r - l + 1)

    return maxVisible + same

```

## 59. Spiral Matrix II_59.py
```python
class Solution:
  def generateMatrix(self, n: int) -> List[List[int]]:
    ans = [[0] * n for _ in range(n)]
    count = 1

    for mn in range(n // 2):
      mx = n - mn - 1
      for i in range(mn, mx):
        ans[mn][i] = count
        count += 1
      for i in range(mn, mx):
        ans[i][mx] = count
        count += 1
      for i in range(mx, mn, -1):
        ans[mx][i] = count
        count += 1
      for i in range(mx, mn, -1):
        ans[i][mn] = count
        count += 1

    if n % 2 == 1:
      ans[n // 2][n // 2] = count

    return ans

```

## 2349. Design a Number Container System_2349.py
```python
from sortedcontainers import SortedSet


class NumberContainers:
  def __init__(self):
    self.numberToIndices = collections.defaultdict(SortedSet)
    self.indexToNumber = {}

  def change(self, index: int, number: int) -> None:
    if index in self.indexToNumber:
      originalNumber = self.indexToNumber[index]
      self.numberToIndices[originalNumber].remove(index)
      if len(self.numberToIndices[originalNumber]) == 0:
        del self.numberToIndices[originalNumber]
    self.indexToNumber[index] = number
    self.numberToIndices[number].add(index)

  def find(self, number: int) -> int:
    if number in self.numberToIndices:
      return self.numberToIndices[number][0]
    return -1

```

## 1793. Maximum Score of a Good Subarray_1793-2.py
```python
class Solution:
  def maximumScore(self, nums: List[int], k: int) -> int:
    n = len(nums)
    ans = nums[k]
    mn = nums[k]
    i = k
    j = k

    # Greedily expand the window and decrease the minimum as slow as possible.
    while i > 0 or j < n - 1:
      if i == 0:
        j += 1
      elif j == n - 1:
        i -= 1
      elif nums[i - 1] < nums[j + 1]:
        j += 1
      else:
        i -= 1
      mn = min(mn, nums[i], nums[j])
      ans = max(ans, mn * (j - i + 1))

    return ans

```

## 2492. Minimum Score of a Path Between Two Cities_2492.py
```python
class Solution:
  def minScore(self, n: int, roads: List[List[int]]) -> int:
    ans = math.inf
    graph = [[] for _ in range(n + 1)]  # graph[u] := [(v, distance)]
    q = collections.deque([1])
    seen = {1}

    for u, v, distance in roads:
      graph[u].append((v, distance))
      graph[v].append((u, distance))

    while q:
      u = q.popleft()
      for v, d in graph[u]:
        ans = min(ans, d)
        if v in seen:
          continue
        q.append(v)
        seen.add(v)

    return ans

```

## 1161. Maximum Level Sum of a Binary Tree_1161.py
```python
class Solution:
  def maxLevelSum(self, root: Optional[TreeNode]) -> int:
    ans = 0
    maxLevelSum = -math.inf
    q = collections.deque([root])

    level = 1
    while q:
      levelSum = 0
      for _ in range(len(q)):
        node = q.popleft()
        levelSum += node.val
        if node.left:
          q.append(node.left)
        if node.right:
          q.append(node.right)
      if levelSum > maxLevelSum:
        maxLevelSum = levelSum
        ans = level
      level += 1

    return ans

```

## 1188. Design Bounded Blocking Queue_1188.py
```python
from threading import Semaphore


class BoundedBlockingQueue:
  def __init__(self, capacity: int):
    self.q = collections.deque()
    self.enqueueSemaphore = Semaphore(capacity)
    self.dequeueSemaphore = Semaphore(0)

  def enqueue(self, element: int) -> None:
    self.enqueueSemaphore.acquire()
    self.q.append(element)
    self.dequeueSemaphore.release()

  def dequeue(self) -> int:
    self.dequeueSemaphore.acquire()
    element = self.q.popleft()
    self.enqueueSemaphore.release()
    return element

  def size(self) -> int:
    return len(self.q)

```

## 2728. Count Houses in a Circular Street_2728.py
```python
# Definition for a street.
# class Street:
#   def openDoor(self):
#     pass
#   def closeDoor(self):
#     pass
#   def isDoorOpen(self):
#     pass
#   def moveRight(self):
#     pass
#   def moveLeft(self):
#     pass

class Solution:
  def houseCount(self, street: Optional['Street'], k: int) -> int:
    for _ in range(k):
      if street.isDoorOpen():
        street.closeDoor()
      street.moveRight()

    for ans in range(k + 1):
      if street.isDoorOpen():
        return ans
      street.openDoor()
      street.moveRight()

```

## 2188. Minimum Time to Finish the Race_2188.py
```python
class Solution:
  def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:
    # singleTire[i] := the minimum time to finish i laps without changing tire
    singleTire = [math.inf] * (numLaps + 1)
    # dp[i] := the minimum time to finish i laps
    dp = [math.inf] * (numLaps + 1)

    for i, (f, r) in enumerate(tires):
      sumSecs = 0
      rPower = 1
      for j in range(1, numLaps + 1):
        # the time to use the same tire for the next lap >=
        # the time to change a new tire + f
        if f * rPower >= changeTime + f:
          break
        sumSecs += f * rPower
        rPower *= r
        singleTire[j] = min(singleTire[j], sumSecs)

    dp[0] = 0
    for i in range(1, numLaps + 1):
      for j in range(1, i + 1):
        dp[i] = min(dp[i], dp[i - j] + changeTime + singleTire[j])

    return dp[numLaps] - changeTime

```

## 1130. Minimum Cost Tree From Leaf Values_1130.py
```python
class Solution:
  def mctFromLeafValues(self, arr: List[int]) -> int:
    n = len(arr)
    # dp[i][j] := the minimum cost of arr[i..j]
    dp = [[0] * n for _ in range(n)]
    # maxVal[i][j] := the maximum value of arr[i..j]
    maxVal = [[0] * n for _ in range(n)]

    for i in range(n):
      maxVal[i][i] = arr[i]

    for d in range(1, n):
      for i in range(n - d):
        j = i + d
        maxVal[i][j] = max(maxVal[i][j - 1], maxVal[i + 1][j])

    for d in range(1, n):
      for i in range(n - d):
        j = i + d
        dp[i][j] = math.inf
        for k in range(i, j):
          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] +
                         maxVal[i][k] * maxVal[k + 1][j])

    return dp[0][-1]

```

## 1745. Palindrome Partitioning IV_1745-2.py
```python
class Solution:
  def checkPartitioning(self, s: str) -> bool:
    n = len(s)
    # dp[i][j] := true if s[i..j] is a palindrome
    dp = [[False] * n for _ in range(n)]

    for i in range(n):
      dp[i][i] = True

    for d in range(1, n):
      for i in range(n - d):
        j = i + d
        if s[i] == s[j]:
          dp[i][j] = i + 1 > j - 1 or dp[i + 1][j - 1]

    for i in range(n):
      for j in range(i + 1, n):
        if dp[0][i] and dp[i + 1][j] and dp[j + 1][n - 1]:
          return True

    return False

```

## 753. Cracking the Safe_753.py
```python
class Solution:
  def crackSafe(self, n: int, k: int) -> str:
    passwordSize = k**n
    path = '0' * n
    seen = set()
    seen.add(path)

    def dfs(path: str) -> str:
      if len(seen) == passwordSize:
        return path

      for c in map(str, range(k)):
        node = path[-n + 1:] + c if n > 1 else c
        if node not in seen:
          seen.add(node)
          res = dfs(path + c)
          if res:
            return res
          seen.remove(node)

    return dfs(path)

```

## 97. Interleaving String_97-2.py
```python
class Solution:
  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
    m = len(s1)
    n = len(s2)
    if m + n != len(s3):
      return False

    dp = [False] * (n + 1)

    for i in range(m + 1):
      for j in range(n + 1):
        if i == 0 and j == 0:
          dp[j] = True
        elif i == 0:
          dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]
        elif j == 0:
          dp[j] = dp[j] and s1[i - 1] == s3[i - 1]
        else:
          dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]) or \
              (dp[j - 1] and s2[j - 1] == s3[i + j - 1])

    return dp[n]

```

## 2458. Height of Binary Tree After Subtree Removal Queries_2458.py
```python
class Solution:
  def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:
    @lru_cache(None)
    def height(root: Optional[TreeNode]) -> int:
      if not root:
        return 0
      return 1 + max(height(root.left), height(root.right))

    # valToMaxHeight[val] := the maximum height without the node with `val`
    valToMaxHeight = {}

    # maxHeight := the maximum height without the current node `root`
    def dfs(root: Optional[TreeNode], depth: int, maxHeight: int) -> None:
      if not root:
        return
      valToMaxHeight[root.val] = maxHeight
      dfs(root.left, depth + 1, max(maxHeight, depth + height(root.right)))
      dfs(root.right, depth + 1, max(maxHeight, depth + height(root.left)))

    dfs(root, 0, 0)
    return [valToMaxHeight[query] for query in queries]

```

## 109. Convert Sorted List to Binary Search Tree_109-2.py
```python
class Solution:
  def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:
    A = []

    # Construct the array.
    curr = head
    while curr:
      A.append(curr.val)
      curr = curr.next

    def helper(l: int, r: int) -> Optional[TreeNode]:
      if l > r:
        return None

      m = (l + r) // 2
      root = TreeNode(A[m])
      root.left = helper(l, m - 1)
      root.right = helper(m + 1, r)
      return root

    return helper(0, len(A) - 1)

```

## 2904. Shortest and Lexicographically Smallest Beautiful String_2904.py
```python
class Solution:
  # Same as 76. Minimum Window Substring
  def shortestBeautifulSubstring(self, s: str, k: int) -> str:
    bestLeft = -1
    minLength = len(s) + 1
    ones = 0

    l = 0
    for r, c in enumerate(s):
      if c == '1':
        ones += 1
      while ones == k:
        if r - l + 1 < minLength:
          bestLeft = l
          minLength = r - l + 1
        elif r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength]:
          bestLeft = l
        if s[l] == '1':
          ones -= 1
        l += 1

    return "" if bestLeft == -1 else s[bestLeft:bestLeft + minLength]

```

## 1658. Minimum Operations to Reduce X to Zero_1658.py
```python
class Solution:
  def minOperations(self, nums: List[int], x: int) -> int:
    targetSum = sum(nums) - x
    if targetSum == 0:
      return len(nums)
    maxLen = self._maxSubArrayLen(nums, targetSum)
    return -1 if maxLen == -1 else len(nums) - maxLen

  # Same as 325. Maximum Size Subarray Sum Equals k
  def _maxSubArrayLen(self, nums: List[int], k: int) -> int:
    res = -1
    prefix = 0
    prefixToIndex = {0: -1}

    for i, num in enumerate(nums):
      prefix += num
      target = prefix - k
      if target in prefixToIndex:
        res = max(res, i - prefixToIndex[target])
      # No need to check the existence of the prefix since it's unique.
      prefixToIndex[prefix] = i

    return res

```

## 140. Word Break II_140.py
```python
class Solution:
  def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
    wordSet = set(wordDict)

    @functools.lru_cache(None)
    def wordBreak(s: str) -> List[str]:
      ans = []

      # 1 <= len(prefix) < len(s)
      for i in range(1, len(s)):
        prefix = s[0:i]
        suffix = s[i:]
        if prefix in wordSet:
          for word in wordBreak(suffix):
            ans.append(prefix + ' ' + word)

      # `wordSet` contains the whole string s, so don't add any space.
      if s in wordSet:
        ans.append(s)

      return ans

    return wordBreak(s)

```

## 2502. Design Memory Allocator_2502.py
```python
class Allocator:
  def __init__(self, n: int):
    self.memory = [0] * n
    self.mIDToIndices = [[] for _ in range(1001)]

  def allocate(self, size: int, mID: int) -> int:
    consecutiveFree = 0
    for i, m in enumerate(self.memory):
      consecutiveFree = consecutiveFree + 1 if m == 0 else 0
      if consecutiveFree == size:
        for j in range(i - consecutiveFree + 1, i + 1):
          self.memory[j] = mID
          self.mIDToIndices[mID].append(j)
        return i - consecutiveFree + 1
    return -1

  def free(self, mID: int) -> int:
    indices = self.mIDToIndices[mID]
    freedUnits = len(indices)
    for index in indices:
      self.memory[index] = 0
    indices.clear()
    return freedUnits

```

## 1428. Leftmost Column with at Least a One_1428-2.py
```python
# """
# This is BinaryMatrix's API interface.
# You should not implement it, or speculate about its implementation
# """
# Class BinaryMatrix(object):
#   def get(self, row: int, col: int) -> int:
#   def dimensions(self) -> List[int]:

class Solution:
  def leftMostColumnWithOne(self, binaryMatrix: 'BinaryMatrix') -> int:
    m, n = binaryMatrix.dimensions()
    ans = -1
    i = 0
    j = n - 1

    while i < m and j >= 0:
      if binaryMatrix.get(i, j):
        ans = j
        j -= 1
      else:
        i += 1

    return ans

```

## 30. Substring with Concatenation of All Words_30.py
```python
class Solution:
  def findSubstring(self, s: str, words: List[str]) -> List[int]:
    if len(s) == 0 or words == []:
      return []

    k = len(words)
    n = len(words[0])
    ans = []
    count = collections.Counter(words)

    for i in range(len(s) - k * n + 1):
      seen = collections.defaultdict(int)
      j = 0
      while j < k:
        word = s[i + j * n: i + j * n + n]
        seen[word] += 1
        if seen[word] > count[word]:
          break
        j += 1
      if j == k:
        ans.append(i)

    return ans

```

## 3129. Find All Possible Stable Binary Arrays I_3129.py
```python
class Solution:
  # Same as 3129. Find All Possible Stable Binary Arrays I
  def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:
    kMod = 1_000_000_007
    # dp[i][j][k] := the number of stable arrays, where the number of
    # occurrences of 0 is i and the number of occurrences of 1 is j and the last
    # number is k (0/1)
    dp = [[[0] * 2
           for _ in range(one + 1)]
          for _ in range(zero + 1)]

    for i in range(min(zero, limit) + 1):
      dp[i][0][0] = 1

    for j in range(min(one, limit) + 1):
      dp[0][j][1] = 1

    for i in range(1, zero + 1):
      for j in range(1, one + 1):
        dp[i][j][0] = (dp[i - 1][j][0] + dp[i - 1][j][1] -
                       (dp[i - limit - 1][j][1] if i - limit >= 1 else 0) + kMod) % kMod
        dp[i][j][1] = (dp[i][j - 1][0] + dp[i][j - 1][1] -
                       (dp[i][j - limit - 1][0] if j - limit >= 1 else 0) + kMod) % kMod

    return (dp[zero][one][0] + dp[zero][one][1]) % kMod

```

## 1937. Maximum Number of Points with Cost_1937.py
```python
class Solution:
  def maxPoints(self, points: List[List[int]]) -> int:
    n = len(points[0])
    # dp[j] := the maximum number of points you can have if points[i][j] is the
    # most recent cell you picked
    dp = [0] * n

    for row in points:
      leftToRight = [0] * n
      runningMax = 0
      for j in range(n):
        runningMax = max(runningMax - 1, dp[j])
        leftToRight[j] = runningMax

      rightToLeft = [0] * n
      runningMax = 0
      for j in range(n - 1, - 1, -1):
        runningMax = max(runningMax - 1, dp[j])
        rightToLeft[j] = runningMax

      for j in range(n):
        dp[j] = max(leftToRight[j], rightToLeft[j]) + row[j]

    return max(dp)

```

## 1585. Check If String Is Transformable With Substring Sort Operations_1585.py
```python
class Solution:
  def isTransformable(self, s: str, t: str) -> bool:
    if collections.Counter(s) != collections.Counter(t):
      return False

    positions = [collections.deque() for _ in range(10)]

    for i, c in enumerate(s):
      positions[int(c)].append(i)

    # For each digit in `t`, check if we can put this digit in `s` at the same
    # position as `t`. Ensure that all the left digits are equal to or greater
    # than it. This is because the only operation we can perform is sorting in
    # ascending order. If there is a digit to the left that is smaller than it,
    # we can never move it to the same position as in `t`. However, if all the
    # digits to its left are equal to or greater than it, we can move it one
    # position to the left until it reaches the same position as in `t`.
    for c in t:
      d = int(c)
      front = positions[d].popleft()
      for smaller in range(d):
        if positions[smaller] and positions[smaller][0] < front:
          return False

    return True

```

## 1030. Matrix Cells in Distance Order_1030.py
```python
class Solution:
  def allCellsDistOrder(self, rows: int, cols: int, rCenter: int, cCenter: int) -> List[List[int]]:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    ans = []
    q = collections.deque([(rCenter, cCenter)])
    seen = {(rCenter, cCenter)}

    while q:
      i, j = q.popleft()
      ans.append([i, j])
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == rows or y < 0 or y == cols:
          continue
        if (x, y) in seen:
          continue
        seen.add((x, y))
        q.append((x, y))

    return ans

```

## 2531. Make Number of Distinct Characters Equal_2531.py
```python
class Solution:
  def isItPossible(self, word1: str, word2: str) -> bool:
    count1 = collections.Counter(word1)
    count2 = collections.Counter(word2)
    distinct1 = len(count1)
    distinct2 = len(count2)

    for a in count1:
      for b in count2:
        if a == b:
          # Swapping the same letters won't change the number of distinct
          # letters in each string, so just check if `distinct1 == distinct2`.
          if distinct1 == distinct2:
            return True
          continue
        # The calculation is meaningful only when a != b
        # Swap a in word1 with b in word2.
        distinctAfterSwap1 = distinct1 - (count1[a] == 1) + (count1[b] == 0)
        distinctAfterSwap2 = distinct2 - (count2[b] == 1) + (count2[a] == 0)
        if distinctAfterSwap1 == distinctAfterSwap2:
          return True

    return False

```

## 81. Search in Rotated Sorted Array II_81.py
```python
class Solution:
  def search(self, nums: List[int], target: int) -> bool:
    l = 0
    r = len(nums) - 1

    while l <= r:
      m = (l + r) // 2
      if nums[m] == target:
        return True
      if nums[l] == nums[m] == nums[r]:
        l += 1
        r -= 1
      elif nums[l] <= nums[m]:  # nums[l..m] are sorted
        if nums[l] <= target < nums[m]:
          r = m - 1
        else:
          l = m + 1
      else:  # nums[m..n - 1] are sorted
        if nums[m] < target <= nums[r]:
          l = m + 1
        else:
          r = m - 1

    return False

```

## 1312. Minimum Insertion Steps to Make a String Palindrome_1312.py
```python
class Solution:
  def minInsertions(self, s: str) -> int:
    return len(s) - self._longestPalindromeSubseq(s)

  # Same as 516. Longest Palindromic Subsequence
  def _longestPalindromeSubseq(self, s: str) -> int:
    n = len(s)
    # dp[i][j] := the length of LPS(s[i..j])
    dp = [[0] * n for _ in range(n)]

    for i in range(n):
      dp[i][i] = 1

    for d in range(1, n):
      for i in range(n - d):
        j = i + d
        if s[i] == s[j]:
          dp[i][j] = 2 + dp[i + 1][j - 1]
        else:
          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])

    return dp[0][n - 1]

```

## 1776. Car Fleet II_1776.py
```python
class Solution:
  def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:
    ans = []
    stack = []  # (pos, speed, collisionTime)

    def getCollisionTime(
            car: Tuple[int, int, int],
            pos: int, speed: int) -> float:
      return (car[0] - pos) / (speed - car[1])

    for pos, speed in reversed(cars):
      while stack and (
              speed <= stack[-1][1] or getCollisionTime(stack[-1],
                                                        pos, speed) >=
              stack[-1][2]):
        stack.pop()
      if stack:
        collisionTime = getCollisionTime(stack[-1], pos, speed)
        stack.append((pos, speed, collisionTime))
        ans.append(collisionTime)
      else:
        stack.append((pos, speed, math.inf))
        ans.append(-1)

    return ans[::-1]

```

## 416. Partition Equal Subset Sum_416.py
```python
class Solution:
  def canPartition(self, nums: List[int]) -> bool:
    summ = sum(nums)
    if summ % 2 == 1:
      return False
    return self.knapsack_(nums, summ // 2)

  def knapsack_(self, nums: List[int], subsetSum: int) -> bool:
    n = len(nums)
    # dp[i][j] := True if j can be formed by nums[0..i)
    dp = [[False] * (subsetSum + 1) for _ in range(n + 1)]
    dp[0][0] = True

    for i in range(1, n + 1):
      num = nums[i - 1]
      for j in range(subsetSum + 1):
        if j < num:
          dp[i][j] = dp[i - 1][j]
        else:
          dp[i][j] = dp[i - 1][j] or dp[i - 1][j - num]

    return dp[n][subsetSum]

```

## 844. Backspace String Compare_844-2.py
```python
class Solution:
  def backspaceCompare(self, s: str, t: str) -> bool:
    i = len(s) - 1  # s' index
    j = len(t) - 1  # t's index

    while True:
      # Delete characters of s if needed.
      backspace = 0
      while i >= 0 and (s[i] == '#' or backspace > 0):
        backspace += 1 if s[i] == '#' else -1
        i -= 1
      # Delete characters of t if needed.
      backspace = 0
      while j >= 0 and (t[j] == '#' or backspace > 0):
        backspace += 1 if t[j] == '#' else -1
        j -= 1
      if i >= 0 and j >= 0 and s[i] == t[j]:
        i -= 1
        j -= 1
      else:
        break

    return i == -1 and j == -1

```

## 820. Short Encoding of Words_820.py
```python
class TrieNode:
  def __init__(self):
    self.children: Dict[str, TrieNode] = {}
    self.depth = 0


class Solution:
  def minimumLengthEncoding(self, words: List[str]) -> int:
    root = TrieNode()
    leaves = []

    def insert(word: str) -> TrieNode:
      node = root
      for c in reversed(word):
        node = node.children.setdefault(c, TrieNode())
      node.depth = len(word)
      return node

    for word in set(words):
      leaves.append(insert(word))

    return sum(leaf.depth + 1 for leaf in leaves
               if not len(leaf.children))

```

## 272. Closest Binary Search Tree Value II_272.py
```python
class Solution:
  def closestKValues(self, root: Optional[TreeNode], target: float, k: int) -> List[int]:
    dq = collections.deque()

    def inorder(root: Optional[TreeNode]) -> None:
      if not root:
        return

      inorder(root.left)
      dq.append(root.val)
      inorder(root.right)

    inorder(root)

    while len(dq) > k:
      if abs(dq[0] - target) > abs(dq[-1] - target):
        dq.popleft()
      else:
        dq.pop()

    return list(dq)

```

## 1428. Leftmost Column with at Least a One_1428.py
```python
# """
# This is BinaryMatrix's API interface.
# You should not implement it, or speculate about its implementation
# """
# Class BinaryMatrix(object):
#   def get(self, row: int, col: int) -> int:
#   def dimensions(self) -> List[int]:

class Solution:
  def leftMostColumnWithOne(self, binaryMatrix: 'BinaryMatrix') -> int:
    m, n = binaryMatrix.dimensions()
    ans = -1
    l = 0
    r = n - 1

    while l <= r:
      mid = (l + r) // 2
      if any(binaryMatrix.get(i, mid) for i in range(m)):
        ans = mid
        r = mid - 1
      else:
        l = mid + 1

    return ans

```

## 710. Random Pick with Blacklist_710.py
```python
class Solution:
  def __init__(self, n: int, blacklist: List[int]):
    self.validRange = n - len(blacklist)
    self.dict = {}

    maxAvailable = n - 1

    for b in blacklist:
      self.dict[b] = -1

    for b in blacklist:
      if b < self.validRange:
        # Find the slot that haven't been used.
        while maxAvailable in self.dict:
          maxAvailable -= 1
        self.dict[b] = maxAvailable
        maxAvailable -= 1

  def pick(self) -> int:
    value = random.randint(0, self.validRange - 1)

    if value in self.dict:
      return self.dict[value]

    return value

```

## 1420. Build Array Where You Can Find The Maximum Exactly K Comparisons_1420-2.py
```python
class Solution:
  def numOfArrays(self, n: int, m: int, k: int) -> int:
    kMod = 1_000_000_007
    # dp[i][j][k] := the number of ways to build an array of length i, where j
    # is the maximum number and k is the `search_cost`
    dp = [[[0] * (k + 1) for j in range(m + 1)] for _ in range(n + 1)]
    # prefix[i][j][k] := sum(dp[i][x][k]), where 1 <= x <= j
    prefix = [[[0] * (k + 1) for j in range(m + 1)] for _ in range(n + 1)]

    for j in range(1, m + 1):
      dp[1][j][1] = 1
      prefix[1][j][1] = j

    for i in range(2, n + 1):  # for each length
      for j in range(1, m + 1):  # for each max value
        for cost in range(1, k + 1):  # for each cost
          # 1. Appending any of [1, j] in the i-th position doesn't change the
          #    maximum and cost.
          # 2. Appending j in the i-th position makes j the new max and cost 1.
          dp[i][j][cost] = (j * dp[i - 1][j][cost] +
                            prefix[i - 1][j - 1][cost - 1]) % kMod
          prefix[i][j][cost] = (dp[i][j][cost] + prefix[i][j - 1][cost]) % kMod

    return sum(dp[n][j][k] for j in range(1, m + 1)) % kMod

```

## 964. Least Operators to Express Number_964.py
```python
class Solution:
  def leastOpsExpressTarget(self, x: int, target: int) -> int:
    @functools.lru_cache(None)
    def dfs(target):
      if x > target:
        return min(2 * target - 1, 2 * (x - target))
      if x == target:
        return 0

      prod = x
      n = 0
      while prod < target:
        prod *= x
        n += 1
      if prod == target:
        return n

      ans = dfs(target - prod // x) + n
      if prod < 2 * target:
        ans = min(ans, dfs(prod - target) + n + 1)
      return ans

    return dfs(target)

```

## 3157. Find the Level of Tree with Minimum Sum_3157.py
```python
class Solution:
  # Similar to 1161. Maximum Level Sum of a Binary Tree
  def minimumLevel(self, root: Optional[TreeNode]) -> int:
    ans = 0
    minLevelSum = math.inf
    q = collections.deque([root])

    level = 1
    while q:
      levelSum = 0
      for _ in range(len(q)):
        node = q.popleft()
        levelSum += node.val
        if node.left:
          q.append(node.left)
        if node.right:
          q.append(node.right)
      if levelSum < minLevelSum:
        minLevelSum = levelSum
        ans = level
      level += 1

    return ans

```

## 1973. Count Nodes Equal to Sum of Descendants_1973.py
```python
from dataclasses import dataclass


@dataclass(frozen=True)
class T:
  summ: int
  count: int


class Solution:
  def equalToDescendants(self, root: Optional[TreeNode]) -> int:
    def dfs(root: Optional[TreeNode]) -> T:
      if not root:
        return T(0, 0)
      left = dfs(root.left)
      right = dfs(root.right)
      return T(root.val + left.summ + right.summ,
               left.count + right.count +
               (1 if root.val == left.summ + right.summ else 0))

    return dfs(root).count

```

## 1705. Maximum Number of Eaten Apples_1705.py
```python
class Solution:
  def eatenApples(self, apples: List[int], days: List[int]) -> int:
    n = len(apples)
    ans = 0
    minHeap = []  # (the rotten day, the number of apples)

    i = 0
    while i < n or minHeap:
      # Remove the rotten apples.
      while minHeap and minHeap[0][0] <= i:
        heapq.heappop(minHeap)
      # Add today's apples.
      if i < n and apples[i] > 0:
        heapq.heappush(minHeap, (i + days[i], apples[i]))
      # Eat one apple today.
      if minHeap:
        rottenDay, numApples = heapq.heappop(minHeap)
        if numApples > 1:
          heapq.heappush(minHeap, (rottenDay, numApples - 1))
        ans += 1
      i += 1

    return ans

```

## 227. Basic Calculator II_227-2.py
```python
class Solution:
  def calculate(self, s: str) -> int:
    ans = 0
    prevNum = 0
    currNum = 0
    op = '+'

    for i, c in enumerate(s):
      if c.isdigit():
        currNum = currNum * 10 + int(c)
      if not c.isdigit() and c != ' ' or i == len(s) - 1:
        if op == '+' or op == '-':
          ans += prevNum
          prevNum = (currNum if op == '+' else -currNum)
        elif op == '*':
          prevNum *= currNum
        elif op == '/':
          prevNum = int(prevNum / currNum)
        op = c
        currNum = 0

    return ans + prevNum

```

## 2422. Merge Operations to Turn Array Into a Palindrome_2422.py
```python
class Solution:
  def minimumOperations(self, nums: List[int]) -> int:
    ans = 0
    l = 0
    r = len(nums) - 1
    leftSum = nums[0]
    rightSum = nums[-1]

    while l < r:
      if leftSum < rightSum:
        l += 1
        leftSum += nums[l]
        ans += 1
      elif leftSum > rightSum:
        r -= 1
        rightSum += nums[r]
        ans += 1
      else:  # leftSum == rightSum
        l += 1
        r -= 1
        leftSum = nums[l]
        rightSum = nums[r]

    return ans

```

## 1340. Jump Game V_1340.py
```python
class Solution:
  def maxJumps(self, arr: List[int], d: int) -> int:
    n = len(arr)
    # dp[i] := the maximum jumps starting from arr[i]
    dp = [1] * n
    # a dcreasing stack that stores indices
    stack = []

    for i in range(n + 1):
      while stack and (i == n or arr[stack[-1]] < arr[i]):
        indices = [stack.pop()]
        while stack and arr[stack[-1]] == arr[indices[0]]:
          indices.append(stack.pop())
        for j in indices:
          if i < n and i - j <= d:
            # Can jump from i to j.
            dp[i] = max(dp[i], dp[j] + 1)
          if stack and j - stack[-1] <= d:
            # Can jump from stack[-1] to j
            dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)
      stack.append(i)

    return max(dp)

```

## 1178. Number of Valid Words for Each Puzzle_1178.py
```python
class Solution:
  def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:
    ans = []
    binaryCount = collections.Counter()

    for word in words:
      mask = 0
      for c in word:
        mask |= 1 << (ord(c) - ord('a'))
      binaryCount[mask] += 1

    for puzzle in puzzles:
      valid = 0
      n = len(puzzle) - 1
      for i in range(1 << n):
        mask = 1 << ord(puzzle[0]) - ord('a')
        for j in range(n):
          if i >> j & 1:
            mask |= 1 << ord(puzzle[j + 1]) - ord('a')
        if mask in binaryCount:
          valid += binaryCount[mask]
      ans.append(valid)

    return ans

```

## 2036. Maximum Alternating Subarray Sum_2036.py
```python
class Solution:
  def maximumAlternatingSubarraySum(self, nums: List[int]) -> int:
    ans = -math.inf
    even = 0  # the subarray sum starting from an even index
    odd = 0  # the subarray sum starting from an odd index

    for i in range(len(nums)):
      if i % 2 == 0:  # Must pick.
        even += nums[i]
      else:  # Start a fresh subarray or subtract `nums[i]`.
        even = max(0, even - nums[i])
      ans = max(ans, even)

    for i in range(1, len(nums)):
      if i % 2 == 1:  # Must pick.
        odd += nums[i]
      else:  # Start a fresh subarray or subtract `nums[i]`.
        odd = max(0, odd - nums[i])
      ans = max(ans, odd)

    return ans

```

## 1215. Stepping Numbers_1215-2.py
```python
class Solution:
  def countSteppingNumbers(self, low: int, high: int) -> List[int]:
    ans = [0] if low == 0 else []

    def dfs(curr: int) -> None:
      if curr > high:
        return
      if curr >= low:
        ans.append(curr)

      lastDigit = curr % 10
      if lastDigit > 0:
        dfs(curr * 10 + lastDigit - 1)
      if lastDigit < 9:
        dfs(curr * 10 + lastDigit + 1)

    for i in range(1, 9 + 1):
      dfs(i)

    ans.sort()
    return ans

```

## 2607. Make K-Subarray Sums Equal_2607.py
```python
class Solution:
  def makeSubKSumEqual(self, arr: List[int], k: int) -> int:
    # If the sum of each subarray of length k is equal, then `arr` must have a
    # repeated pattern of size k. e.g. arr = [1, 2, 3, ...] and k = 3, to have
    # sum([1, 2, 3)] == sum([2, 3, x]), x must be 1. Therefore, arr[i] ==
    # arr[(i + k) % n] for every i.
    n = len(arr)
    ans = 0
    seen = [0] * n

    for i in range(n):
      groups = []
      j = i
      while not seen[j]:
        groups.append(arr[j])
        seen[j] = True
        j = (j + k) % n
      groups.sort()
      for num in groups:
        ans += abs(num - groups[len(groups) // 2])

    return ans

```

## 1743. Restore the Array From Adjacent Pairs_1743.py
```python
class Solution:
  def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:
    ans = []
    numToAdjs = collections.defaultdict(list)

    for a, b in adjacentPairs:
      numToAdjs[a].append(b)
      numToAdjs[b].append(a)

    for num, adjs in numToAdjs.items():
      if len(adjs) == 1:
        ans.append(num)
        ans.append(adjs[0])
        break

    while len(ans) < len(adjacentPairs) + 1:
      tail = ans[-1]
      prev = ans[-2]
      adjs = numToAdjs[tail]
      if adjs[0] == prev:  # adjs[0] is already used
        ans.append(adjs[1])
      else:
        ans.append(adjs[0])

    return ans

```

## 2915. Length of the Longest Subsequence That Sums to Target_2915.py
```python
class Solution:
  def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:
    n = len(nums)
    # dp[i][j] := the maximum length of any subsequence of the first i numbers
    # that sum to j
    dp = [[-1] * (target + 1) for _ in range(n + 1)]

    for i in range(n + 1):
      dp[i][0] = 0

    for i in range(1, n + 1):
      num = nums[i - 1]
      for j in range(1, target + 1):
        # 1. Skip `num`.
        if j < num or dp[i - 1][j - num] == -1:
          dp[i][j] = dp[i - 1][j]
        # 2. Skip `num` or pick `num`.
        else:
          dp[i][j] = max(dp[i - 1][j], 1 + dp[i - 1][j - num])

    return dp[n][target]

```

## 1609. Even Odd Tree_1609.py
```python
class Solution:
  def isEvenOddTree(self, root: Optional[TreeNode]) -> bool:
    q = collections.deque([root])
    isEven = True

    while q:
      prevVal = -math.inf if isEven else math.inf
      for _ in range(sz):
        node = q.popleft()
        if isEven and (node.val % 2 == 0 or node.val <= prevVal):
          return False  # invalid case on even level
        if not isEven and (node.val % 2 == 1 or node.val >= prevVal):
          return False  # invalid case on odd level
        prevVal = node.val
        if node.left:
          q.append(node.left)
        if node.right:
          q.append(node.right)
      isEven = not isEven

    return True

```

## 1514. Path with Maximum Probability_1514.py
```python
class Solution:
  def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:
    graph = [[] for _ in range(n)]  # {a: [(b, probability_ab)]}
    maxHeap = [(-1.0, start)]   # (the probability to reach u, u)
    seen = [False] * n

    for i, ((u, v), prob) in enumerate(zip(edges, succProb)):
      graph[u].append((v, prob))
      graph[v].append((u, prob))

    while maxHeap:
      prob, u = heapq.heappop(maxHeap)
      prob *= -1
      if u == end:
        return prob
      if seen[u]:
        continue
      seen[u] = True
      for nextNode, edgeProb in graph[u]:
        if seen[nextNode]:
          continue
        heapq.heappush(maxHeap, (-prob * edgeProb, nextNode))

    return 0

```

## 328. Odd Even Linked List_328.py
```python
class Solution:
  def oddEvenList(self, head: ListNode) -> ListNode:
    oddHead = ListNode(0)
    evenHead = ListNode(0)
    odd = oddHead
    even = evenHead
    isOdd = True

    while head:
      if isOdd:
        odd.next = head
        odd = head
      else:
        even.next = head
        even = head
      head = head.next
      isOdd = not isOdd

    even.next = None
    odd.next = evenHead.next
    return oddHead.next

```

## 912. Sort an Array_912-3.py
```python
class Solution:
  def sortArray(self, nums: List[int]) -> List[int]:
    def quickSort(A: List[int], l: int, r: int) -> None:
      if l >= r:
        return

      def partition(A: List[int], l: int, r: int) -> int:
        randIndex = random.randint(0, r - l) + l
        A[randIndex], A[r] = A[r], A[randIndex]
        pivot = A[r]
        nextSwapped = l
        for i in range(l, r):
          if A[i] <= pivot:
            A[nextSwapped], A[i] = A[i], A[nextSwapped]
            nextSwapped += 1
        A[nextSwapped], A[r] = A[r], A[nextSwapped]
        return nextSwapped

      m = partition(A, l, r)
      quickSort(A, l, m - 1)
      quickSort(A, m + 1, r)

    quickSort(nums, 0, len(nums) - 1)
    return nums

```

## 1483. Kth Ancestor of a Tree Node_1483.py
```python
class TreeAncestor:
  def __init__(self, n: int, parent: List[int]):
    self.maxLevel = n.bit_length()
    # dp[i][j] := node i's 2^j-th ancestor
    self.dp = [[0] * self.maxLevel for _ in range(n)]

    # Node i's 2^0 ancestor is its direct parent
    for i in range(n):
      self.dp[i][0] = parent[i]

    for j in range(1, self.maxLevel):
      for i in range(n):
        if self.dp[i][j - 1] == -1:  # There's no such ancestor
          self.dp[i][j] = -1
        else:  # A(i, 2^j) = A(A(i, 2^{j - 1}), 2^{j - 1})
          self.dp[i][j] = self.dp[self.dp[i][j - 1]][j - 1]

  def getKthAncestor(self, node: int, k: int) -> int:
    for j in range(self.maxLevel):
      if node == -1:
        break
      if k >> j & 1:
        node = self.dp[node][j]
    return node

```

## 2121. Intervals Between Identical Elements_2121.py
```python
class Solution:
  def getDistances(self, arr: List[int]) -> List[int]:
    prefix = [0] * len(arr)
    suffix = [0] * len(arr)
    numToIndices = collections.defaultdict(list)

    for i, a in enumerate(arr):
      numToIndices[a].append(i)

    for indices in numToIndices.values():
      for i in range(1, len(indices)):
        currIndex = indices[i]
        prevIndex = indices[i - 1]
        prefix[currIndex] += prefix[prevIndex] + i * (currIndex - prevIndex)
      for i in range(len(indices) - 2, -1, -1):
        currIndex = indices[i]
        prevIndex = indices[i + 1]
        suffix[currIndex] += suffix[prevIndex] + \
            (len(indices) - i - 1) * (prevIndex - currIndex)

    return [p + s for p, s in zip(prefix, suffix)]

```

## 3224. Minimum Array Changes to Make Differences Equal_3224.py
```python
class Solution:
  def minChanges(self, nums: List[int], k: int) -> int:
    pairSize = len(nums) // 2
    diffCount = collections.Counter()  # {nums[-i - 1] - nums[i]: freq}
    # oneChangeCount[i] := the number of pairs that need only one change to
    # to achieve a difference of `i`
    oneChangeCount = [0] * (k + 1)

    for i in range(pairSize):
      a = nums[i]
      b = nums[-i - 1]
      diffCount[abs(a - b)] += 1
      oneChangeCount[max(a, b, k - a, k - b)] += 1

    # prefixOneChangeCount[i] := the number of pairs that need only one change
    # to achieve a difference >= `i`
    # prefixOneChangeCount[i] = sum(oneChangeCount[i..k])
    prefixOneChangeCount = list(
        itertools.accumulate(reversed(oneChangeCount)))[::-1]

    return min(prefixOneChangeCount[diff] - freq +  # one change
               (pairSize - prefixOneChangeCount[diff]) * 2  # two changes
               for diff, freq in diffCount.items())

```

## 1652. Defuse the Bomb_1652.py
```python
class Solution:
  def decrypt(self, code: List[int], k: int) -> List[int]:
    n = len(code)
    ans = [0] * n
    if k == 0:
      return ans

    summ = 0
    start = 1 if k > 0 else n + k  # the start of the next k numbers
    end = k if k > 0 else n - 1  # the end of the next k numbers

    for i in range(start, end + 1):
      summ += code[i]

    for i in range(n):
      ans[i] = summ
      summ -= code[start % n]
      start += 1
      end += 1
      summ += code[end % n]

    return ans

```

## 733. Flood Fill_733.py
```python
class Solution:
  def floodFill(self, image: List[List[int]],
                sr: int, sc: int, newColor: int) -> List[List[int]]:
    startColor = image[sr][sc]
    seen = set()

    def dfs(i: int, j: int) -> None:
      if i < 0 or i == len(image) or j < 0 or j == len(image[0]):
        return
      if image[i][j] != startColor or (i, j) in seen:
        return

      image[i][j] = newColor
      seen.add((i, j))

      dfs(i + 1, j)
      dfs(i - 1, j)
      dfs(i, j + 1)
      dfs(i, j - 1)

    dfs(sr, sc)
    return image

```

## 2616. Minimize the Maximum Difference of Pairs_2616.py
```python
class Solution:
  def minimizeMax(self, nums: List[int], p: int) -> int:
    nums.sort()

    def numPairs(maxDiff: int) -> int:
      """
      Returns the number of pairs that can be obtained if the difference between
      each pair <= `maxDiff`.
      """
      pairs = 0
      i = 1
      while i < len(nums):
        # Greedily pair nums[i] with nums[i - 1].
        if nums[i] - nums[i - 1] <= maxDiff:
          pairs += 1
          i += 2
        else:
          i += 1
      return pairs

    return bisect.bisect_left(
        range(0, nums[-1] - nums[0]), p,
        key=lambda m: numPairs(m))

```

## 3018. Maximum Number of Removal Queries That Can Be Processed I_3018.py
```python
class Solution:
  def maximumProcessableQueries(self, nums: List[int], queries: List[int]) -> int:
    n = len(nums)
    # dp[i][j] := the maximum number of queries processed if nums[i..j] are not
    # removed after processing dp[i][j] queries
    dp = [[0] * n for _ in range(n)]

    for d in range(n - 1, -1, -1):
      for i in range(n):
        j = i + d
        if j >= n:
          continue
        if i > 0:
          # Remove nums[i - 1] from nums[i - 1..j] if possible.
          dp[i][j] = max(dp[i][j], dp[i - 1][j] +
                         (nums[i - 1] >= queries[dp[i - 1][j]]))
        if j + 1 < n:
          # Remove nums[j + 1] from nums[i..j + 1] if possible.
          dp[i][j] = max(dp[i][j], dp[i][j + 1] +
                         (nums[j + 1] >= queries[dp[i][j + 1]]))
        if dp[i][j] == len(queries):
          return len(queries)

    return max(dp[i][i] + (nums[i] >= queries[dp[i][i]])
               for i in range(n))

```

## 1240. Tiling a Rectangle with the Fewest Squares_1240.py
```python
class Solution:
  def tilingRectangle(self, n: int, m: int) -> int:
    @functools.lru_cache(None)
    def dp(heights: int) -> int:
      minHeight = min(heights)
      if minHeight == n:  # All filled.
        return 0

      ans = m * n
      heightsList = list(heights)
      start = heightsList.index(minHeight)

      # Try to put square of different size that doesn't exceed the width/height.
      for sz in range(1, min(m - start + 1, n - minHeight + 1)):
        # heights[start..start + sz) must has the same height.
        if heights[start + sz - 1] != minHeight:
          break
        # Put a square of size `sz` to cover heights[start..start + sz).
        heightsList[start:start + sz] = [minHeight + sz] * sz
        ans = min(ans, dp(tuple(heightsList)))

      return 1 + ans

    return dp(tuple([0] * m))

```

## 229. Majority Element II_229.py
```python
class Solution:
  def majorityElement(self, nums: List[int]) -> List[int]:
    ans1 = 0
    ans2 = 1
    count1 = 0
    count2 = 0

    for num in nums:
      if num == ans1:
        count1 += 1
      elif num == ans2:
        count2 += 1
      elif count1 == 0:
        ans1 = num
        count1 = 1
      elif count2 == 0:
        ans2 = num
        count2 = 1
      else:
        count1 -= 1
        count2 -= 1

    return [ans for ans in (ans1, ans2) if nums.count(ans) > len(nums) // 3]

```

## 1868. Product of Two Run-Length Encoded Arrays_1868.py
```python
class Solution:
  def findRLEArray(self, encoded1: List[List[int]],
                   encoded2: List[List[int]]) -> List[List[int]]:
    ans = []
    i = 0  # encoded1's index
    j = 0  # encoded2's index

    while i < len(encoded1) and j < len(encoded2):
      mult = encoded1[i][0] * encoded2[j][0]
      minFreq = min(encoded1[i][1], encoded2[j][1])
      if ans and mult == ans[-1][0]:
        ans[-1][1] += minFreq
      else:
        ans.append([mult, minFreq])
      encoded1[i][1] -= minFreq
      encoded2[j][1] -= minFreq
      if encoded1[i][1] == 0:
        i += 1
      if encoded2[j][1] == 0:
        j += 1

    return ans

```

## 1644. Lowest Common Ancestor of a Binary Tree II_1644.py
```python
class Solution:
  def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
    seenP = False
    seenQ = False

    def getLCA(root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
      nonlocal seenP
      nonlocal seenQ
      if not root:
        return None
      # Need to traverse the entire tree to update `seenP` and `seenQ`.
      left = getLCA(root.left, p, q)
      right = getLCA(root.right, p, q)
      if root == p:
        seenP = True
        return root
      if root == q:
        seenQ = True
        return root
      if left and right:
        return root
      return left or right

    lca = getLCA(root, p, q)
    return lca if seenP and seenQ else None

```

## 2872. Maximum Number of K-Divisible Components_2872.py
```python
class Solution:
  def maxKDivisibleComponents(self, n: int, edges: List[List[int]], values: List[int], k: int) -> int:
    ans = 0
    graph = [[] for _ in range(n)]

    def dfs(u: int, prev: int) -> int:
      nonlocal ans
      treeSum = values[u]

      for v in graph[u]:
        if v != prev:
          treeSum += dfs(v, u)

      if treeSum % k == 0:
        ans += 1
      return treeSum

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    dfs(0, -1)
    return ans

```

## 76. Minimum Window Substring_76.py
```python
class Solution:
  def minWindow(self, s: str, t: str) -> str:
    count = collections.Counter(t)
    required = len(t)
    bestLeft = -1
    minLength = len(s) + 1

    l = 0
    for r, c in enumerate(s):
      count[c] -= 1
      if count[c] >= 0:
        required -= 1
      while required == 0:
        if r - l + 1 < minLength:
          bestLeft = l
          minLength = r - l + 1
        count[s[l]] += 1
        if count[s[l]] > 0:
          required += 1
        l += 1

    return '' if bestLeft == -1 else s[bestLeft: bestLeft + minLength]

```

## 1916. Count Ways to Build Rooms in an Ant Colony_1916.py
```python
class Solution:
  def waysToBuildRooms(self, prevRoom: List[int]) -> int:
    kMod = 1_000_000_007
    graph = collections.defaultdict(list)

    for i, prev in enumerate(prevRoom):
      graph[prev].append(i)

    def dfs(node: int) -> Tuple[int, int]:
      if not graph[node]:
        return 1, 1

      ans = 1
      l = 0

      for child in graph[node]:
        temp, r = dfs(child)
        ans = (ans * temp * math.comb(l + r, r)) % kMod
        l += r

      return ans, l + 1

    return dfs(0)[0]

```

## 2050. Parallel Courses III_2050.py
```python
class Solution:
  def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:
    graph = [[] for _ in range(n)]
    inDegrees = [0] * n
    dist = time.copy()

    # Build the graph.
    for a, b in relations:
      u = a - 1
      v = b - 1
      graph[u].append(v)
      inDegrees[v] += 1

    # Perform topological sorting.
    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])

    while q:
      u = q.popleft()
      for v in graph[u]:
        dist[v] = max(dist[v], dist[u] + time[v])
        inDegrees[v] -= 1
        if inDegrees[v] == 0:
          q.append(v)

    return max(dist)

```

## 587. Erect the Fence_587.py
```python
class Solution:
  def outerTrees(self, trees: List[List[int]]) -> List[List[int]]:
    hull = []

    trees.sort(key=lambda x: (x[0], x[1]))

    def cross(p: List[int], q: List[int], r: List[int]) -> int:
      return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])

    # Build the lower hull: left-to-right scan.
    for tree in trees:
      while len(hull) > 1 and cross(hull[-1], hull[-2], tree) > 0:
        hull.pop()
      hull.append(tuple(tree))
    hull.pop()

    # Build the upper hull: right-to-left scan.
    for tree in reversed(trees):
      while len(hull) > 1 and cross(hull[-1], hull[-2], tree) > 0:
        hull.pop()
      hull.append(tuple(tree))

    # Remove the redundant elements from the stack.
    return list(set(hull))

```

## 990. Satisfiability of Equality Equations_990.py
```python
class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))

  def union(self, u: int, v: int) -> None:
    self.id[self.find(u)] = self.find(v)

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def equationsPossible(self, equations: List[str]) -> bool:
    uf = UnionFind(26)

    for x, op, _, y in equations:
      if op == '=':
        uf.union(ord(x) - ord('a'), ord(y) - ord('a'))

    return all(uf.find(ord(x) - ord('a')) != uf.find(ord(y) - ord('a'))
               for x, op, _, y in equations
               if op == '!')

```

## 1830. Minimum Number of Operations to Make String Sorted_1830.py
```python
class Solution:
  def makeStringSorted(self, s: str) -> int:
    kMod = 1_000_000_007
    ans = 0
    count = [0] * 26

    @functools.lru_cache(None)
    def fact(i: int) -> int:
      return 1 if i <= 1 else i * fact(i - 1) % kMod

    @functools.lru_cache(None)
    def inv(i: int) -> int:
      return pow(i, kMod - 2, kMod)

    for i, c in enumerate(reversed(s)):
      order = ord(c) - ord('a')
      count[order] += 1
      # count[:order] := s[i] can be any character smaller than c
      # fact(i) := s[i + 1..n - 1] can be any sequence of characters
      perm = sum(count[:order]) * fact(i)
      for j in range(26):
        perm = perm * inv(fact(count[j])) % kMod
      ans = (ans + perm) % kMod

    return ans

```

## 2232. Minimize Result by Adding Parentheses to Expression_2232.py
```python
class Solution:
  def minimizeResult(self, expression: str) -> str:
    plusIndex = expression.index('+')
    left = expression[:plusIndex]
    right = expression[plusIndex + 1:]
    ans = ''
    mn = math.inf

    # the expression -> a * (b + c) * d
    for i in range(len(left)):
      for j in range(len(right)):
        a = 1 if i == 0 else int(left[:i])
        b = int(left[i:])
        c = int(right[0:j + 1])
        d = 1 if j == len(right) - 1 else int(right[j + 1:])
        val = a * (b + c) * d
        if val < mn:
          mn = val
          ans = ('' if i == 0 else str(a)) + \
              '(' + str(b) + '+' + str(c) + ')' + \
                ('' if j == len(right) - 1 else str(d))

    return ans

```

## 1888. Minimum Number of Flips to Make the Binary String Alternating_1888.py
```python
class Solution:
  def minFlips(self, s: str) -> int:
    n = len(s)
    # count[0][0] :=  the number of '0' in the even indices
    # count[0][1] :=  the number of '0' in the odd indices
    # count[1][0] :=  the number of '1' in the even indices
    # count[1][1] :=  the number of '1' in the odd indices
    count = [[0] * 2 for _ in range(2)]

    for i, c in enumerate(s):
      count[ord(c) - ord('0')][i % 2] += 1

    # min(make all 0s in the even indices + make all 1s in the odd indices,
    #     make all 1s in the even indices + make all 0s in the odd indices)
    ans = min(count[1][0] + count[0][1], count[0][0] + count[1][1])

    for i, c in enumerate(s):
      count[ord(c) - ord('0')][i % 2] -= 1
      count[ord(c) - ord('0')][(n + i) % 2] += 1
      ans = min(ans, count[1][0] + count[0][1], count[0][0] + count[1][1])

    return ans

```

## 1169. Invalid Transactions_1169.py
```python
class Solution:
  def invalidTransactions(self, transactions: List[str]) -> List[str]:
    ans = []
    nameToTranses = collections.defaultdict(list)

    for t in transactions:
      name, time, amount, city = t.split(',')
      time, amount = int(time), int(amount)
      nameToTranses[name].append({'time': time, 'city': city})

    for t in transactions:
      name, time, amount, city = t.split(',')
      time, amount = int(time), int(amount)
      if amount > 1000:
        ans.append(t)
      elif name in nameToTranses:
        for sameName in nameToTranses[name]:
          if abs(sameName['time'] - time) <= 60 and sameName['city'] != city:
            ans.append(t)
            break

    return ans

```

## 1381. Design a Stack With Increment Operation_1381.py
```python
class CustomStack:
  def __init__(self, maxSize: int):
    self.maxSize = maxSize
    self.stack = []
    # pendingIncrements[i] := the pending increment for stack[0..i].
    self.pendingIncrements = []

  def push(self, x: int) -> None:
    if len(self.stack) == self.maxSize:
      return
    self.stack.append(x)
    self.pendingIncrements.append(0)

  def pop(self) -> int:
    if not self.stack:
      return -1
    if len(self.stack) > 1:
      self.pendingIncrements[-2] += self.pendingIncrements[-1]
    return self.stack.pop() + self.pendingIncrements.pop()

  def increment(self, k: int, val: int) -> None:
    if not self.stack:
      return
    i = min(k - 1, len(self.stack) - 1)
    self.pendingIncrements[i] += val

```

## 2106. Maximum Fruits Harvested After at Most K Steps_2106.py
```python
class Solution:
  def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
    ans = 0
    maxRight = max(startPos, fruits[-1][0])
    amounts = [0] * (1 + maxRight)
    for position, amount in fruits:
      amounts[position] = amount
    prefix = [0] + list(itertools.accumulate(amounts))

    def getFruits(leftSteps: int, rightSteps: int) -> int:
      l = max(0, startPos - leftSteps)
      r = min(maxRight, startPos + rightSteps)
      return prefix[r + 1] - prefix[l]

    # Go right first.
    for rightSteps in range(min(maxRight - startPos, k) + 1):
      leftSteps = max(0, k - 2 * rightSteps)  # Turn left
      ans = max(ans, getFruits(leftSteps, rightSteps))

    # Go left first.
    for leftSteps in range(min(startPos, k) + 1):
      rightSteps = max(0, k - 2 * leftSteps)  # Turn right
      ans = max(ans, getFruits(leftSteps, rightSteps))

    return ans

```

## 1630. Arithmetic Subarrays_1630.py
```python
class Solution:
  def checkArithmeticSubarrays(self, nums: List[int], l: List[int], r: List[int]) -> List[bool]:
    return [self._isArithmetic(nums, a, b) for a, b in zip(l, r)]

  def _isArithmetic(self, nums: List[int], l: int, r: int) -> bool:
    if r - l < 2:
      return True

    numsSet = set()
    mn = math.inf
    mx = -math.inf

    for i in range(l, r+1):
      mn = min(mn, nums[i])
      mx = max(mx, nums[i])
      numsSet.add(nums[i])

    if (mx - mn) % (r - l) != 0:
      return False

    interval = (mx - mn) // (r - l)
    return all(mn + k * interval in numsSet
               for k in range(1, r - l + 1))

```

## 186. Reverse Words in a String II_186.py
```python
class Solution:
  def reverseWords(self, s: List[str]) -> None:
    def reverse(l: int, r: int) -> None:
      while l < r:
        s[l], s[r] = s[r], s[l]
        l += 1
        r -= 1

    def reverseWords(n: int) -> None:
      i = 0
      j = 0

      while i < n:
        while i < j or (i < n and s[i] == ' '):  # Skip the spaces.
          i += 1
        while j < i or (j < n and s[j] != ' '):  # Skip the spaces.
          j += 1
        reverse(i, j - 1)  # Reverse the word.

    reverse(0, len(s) - 1)  # Reverse the whole string.
    reverseWords(len(s))  # Reverse each word.

```

## 2934. Minimum Operations to Maximize Last Elements in Arrays_2934.py
```python
class Solution:
  def minOperations(self, nums1: List[int], nums2: List[int]) -> int:
    n = len(nums1)
    mn = min(nums1[-1], nums2[-1])
    mx = max(nums1[-1], nums2[-1])
    # the number of the minimum operations, where nums1[n - 1] is not swapped
    # with nums2[n - 1]
    dp1 = 0
    # the number of the minimum operations, where nums1[n - 1] is swapped with
    # nums2[n - 1]
    dp2 = 0

    for a, b in zip(nums1, nums2):
      if min(a, b) > mn:
        return -1
      if max(a, b) > mx:
        return -1
      if a > nums1[-1] or b > nums2[-1]:
        dp1 += 1
      if a > nums2[-1] or b > nums1[-1]:
        dp2 += 1

    return min(dp1, dp2)

```

## 1472. Design Browser History_1472.py
```python
class BrowserHistory:
  def __init__(self, homepage: str):
    self.urls = []
    self.index = -1
    self.lastIndex = -1
    self.visit(homepage)

  def visit(self, url: str) -> None:
    self.index += 1
    if self.index < len(self.urls):
      self.urls[self.index] = url
    else:
      self.urls.append(url)
    self.lastIndex = self.index

  def back(self, steps: int) -> str:
    self.index = max(0, self.index - steps)
    return self.urls[self.index]

  def forward(self, steps: int) -> str:
    self.index = min(self.lastIndex, self.index + steps)
    return self.urls[self.index]

```

## 874. Walking Robot Simulation_874.py
```python
class Solution:
  def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    ans = 0
    d = 0  # 0 := north, 1 := east, 2 := south, 3 := west
    x = 0  # the start x
    y = 0  # the start y
    obstaclesSet = {(x, y) for x, y in obstacles}

    for c in commands:
      if c == -1:
        d = (d + 1) % 4
      elif c == -2:
        d = (d + 3) % 4
      else:
        for _ in range(c):
          if (x + dirs[d], y + dirs[d + 1]) in obstaclesSet:
            break
          x += dirs[d]
          y += dirs[d + 1]

      ans = max(ans, x * x + y * y)

    return ans

```

## 394. Decode String_394.py
```python
class Solution:
  def decodeString(self, s: str) -> str:
    stack = []  # (prevStr, repeatCount)
    currStr = ''
    currNum = 0

    for c in s:
      if c.isdigit():
        currNum = currNum * 10 + int(c)
      else:
        if c == '[':
          stack.append((currStr, currNum))
          currStr = ''
          currNum = 0
        elif c == ']':
          prevStr, num = stack.pop()
          currStr = prevStr + num * currStr
        else:
          currStr += c

    return currStr

```

## 2155. All Divisions With the Highest Score of a Binary Array_2155.py
```python
class Solution:
  def maxScoreIndices(self, nums: List[int]) -> List[int]:
    zeros = nums.count(0)
    ones = len(nums) - zeros
    ans = [0]  # the division at index 0
    leftZeros = 0
    leftOnes = 0
    maxScore = ones  # `leftZeros` + `rightOnes`

    for i, num in enumerate(nums):
      leftZeros += num == 0
      leftOnes += num == 1
      rightOnes = ones - leftOnes
      score = leftZeros + rightOnes
      if maxScore == score:
        ans.append(i + 1)
      elif maxScore < score:
        maxScore = score
        ans = [i + 1]

    return ans

```

## 2897. Apply Operations on Array to Maximize Sum of Squares_2897.py
```python
class Solution:
  def maxSum(self, nums: List[int], k: int) -> int:
    kMod = 1_000_000_007
    kMaxBit = 30
    ans = 0
    # minIndices[i] := the minimum index in `optimalNums` that the i-th bit
    # should be moved to
    minIndices = [0] * kMaxBit
    optimalNums = [0] * len(nums)

    for num in nums:
      for i in range(kMaxBit):
        if num >> i & 1:
          optimalNums[minIndices[i]] |= 1 << i
          minIndices[i] += 1

    for i in range(k):
      ans += optimalNums[i]**2
      ans %= kMod

    return ans

```

## 52. N-Queens II_52.py
```python
class Solution:
  def totalNQueens(self, n: int) -> int:
    ans = 0
    cols = [False] * n
    diag1 = [False] * (2 * n - 1)
    diag2 = [False] * (2 * n - 1)

    def dfs(i: int) -> None:
      nonlocal ans
      if i == n:
        ans += 1
        return

      for j in range(n):
        if cols[j] or diag1[i + j] or diag2[j - i + n - 1]:
          continue
        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = True
        dfs(i + 1)
        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = False

    dfs(0)
    return ans

```

## 1279. Traffic Light Controlled Intersection_1279.py
```python
class TrafficLight:
  def __init__(self):
    self.canPassRoadId = 1  # 1 := road A, 2 := road B

  def carArrived(
      self,
      # ID of the car
      carId: int,
      # ID of the road the car travels on. Can be 1 (road A) or 2 (road B).
      roadId: int,
      # direction of the car
      direction: int,
      # Use turnGreen() to turn light to green on current road.
      turnGreen: Callable[[], None],
      # Use crossCar() to make car cross the intersection.
      crossCar: Callable[[], None]
  ) -> None:
    if roadId != self.canPassRoadId:
      self.canPassRoadId = roadId
      turnGreen()
    crossCar()

```

## 247. Strobogrammatic Number II_247.py
```python
class Solution:
  def findStrobogrammatic(self, n: int) -> List[str]:
    def helper(n: int, k: int) -> List[str]:
      if n == 0:
        return ['']
      if n == 1:
        return ['0', '1', '8']

      ans = []

      for inner in helper(n - 2, k):
        if n < k:
          ans.append('0' + inner + '0')
        ans.append('1' + inner + '1')
        ans.append('6' + inner + '9')
        ans.append('8' + inner + '8')
        ans.append('9' + inner + '6')

      return ans

    return helper(n, n)

```

## 2945. Find Maximum Non-decreasing Array Length_2945-2.py
```python
class Solution:
  def findMaximumLength(self, nums: List[int]) -> int:
    n = len(nums)
    # prefix[i] := the sum of the first i nums
    prefix = list(itertools.accumulate(nums, initial=0))
    # dp[i] := the maximum number of elements in the increasing
    # sequence after processing the first i nums
    dp = [0] * (n + 1)
    # bestLeft[i] := the index l s.t. merging nums[l..i) is the
    # optimal strategy among processing the first i nums
    bestLeft = [0] * (n + 2)

    for i in range(1, n + 1):
      bestLeft[i] = max(bestLeft[i], bestLeft[i - 1])
      # When merging nums[l, i), consider the next segment as [i, r).
      # Find the minimum `r` where sum(nums[l, i)) <= sum(nums[i, r)).
      # Equivalently, prefix[i] - prefix[l] <= prefix[r] - prefix[i].
      #            => prefix[r] >= prefix[i] * 2 - prefix[l]
      # Therefore, we can binary search `prefix` to find the minimum `r`.
      l = bestLeft[i]
      r = bisect.bisect_left(prefix, 2 * prefix[i] - prefix[l])
      dp[i] = dp[l] + 1
      bestLeft[r] = i

    return dp[n]

```

## 74. Search a 2D Matrix_74.py
```python
class Solution:
  def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
    if not matrix:
      return False

    m = len(matrix)
    n = len(matrix[0])
    l = 0
    r = m * n

    while l < r:
      mid = (l + r) // 2
      i = mid // n
      j = mid % n
      if matrix[i][j] == target:
        return True
      if matrix[i][j] < target:
        l = mid + 1
      else:
        r = mid

    return False

```

## 222. Count Complete Tree Nodes_222-2.py
```python
class Solution:
  def countNodes(self, root: Optional[TreeNode]) -> int:
    if not root:
      return 0

    left = root
    right = root
    heightL = 0
    heightR = 0

    while left:
      heightL += 1
      left = left.left

    while right:
      heightR += 1
      right = right.right

    if heightL == heightR:  # `root` is a complete tree.
      return pow(2, heightL) - 1
    return 1 + self.countNodes(root.left) + self.countNodes(root.right)

```

## 2948. Make Lexicographically Smallest Array by Swapping Elements_2948.py
```python
class Solution:
  def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:
    ans = [0] * len(nums)
    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums)])
    # [[(num, index)]], where the difference between in each pair in each
    # `[(num, index)]` group <= `limit`
    numAndIndexesGroups: List[List[Tuple[int, int]]] = []

    for numAndIndex in numAndIndexes:
      if not numAndIndexesGroups or numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit:
        # Start a new group.
        numAndIndexesGroups.append([numAndIndex])
      else:
        # Append to the existing group.
        numAndIndexesGroups[-1].append(numAndIndex)

    for numAndIndexesGroup in numAndIndexesGroups:
      sortedNums = [num for num, _ in numAndIndexesGroup]
      sortedIndices = sorted([index for _, index in numAndIndexesGroup])
      for num, index in zip(sortedNums, sortedIndices):
        ans[index] = num

    return ans

```

## 355. Design Twitter_355.py
```python
class Twitter:
  def __init__(self):
    self.timer = itertools.count(step=-1)
    self.tweets = collections.defaultdict(deque)
    self.followees = collections.defaultdict(set)

  def postTweet(self, userId: int, tweetId: int) -> None:
    self.tweets[userId].appendleft((next(self.timer), tweetId))
    if len(self.tweets[userId]) > 10:
      self.tweets[userId].pop()

  def getNewsFeed(self, userId: int) -> List[int]:
    tweets = list(heapq.merge(
        *(self.tweets[followee] for followee in self.followees[userId] | {userId})))
    return [tweetId for _, tweetId in tweets[:10]]

  def follow(self, followerId: int, followeeId: int) -> None:
    self.followees[followerId].add(followeeId)

  def unfollow(self, followerId: int, followeeId: int) -> None:
    self.followees[followerId].discard(followeeId)

```

## 2143. Choose Numbers From Two Arrays in Range_2143.py
```python
class Solution:
  def countSubranges(self, nums1: List[int], nums2: List[int]) -> int:
    kMod = 1_000_000_007
    ans = 0
    # {sum, count}, add if choose from nums1, minus if choose from nums2
    dp = collections.Counter()

    for a, b in zip(nums1, nums2):
      newDp = collections.Counter()
      newDp[a] += 1
      newDp[-b] += 1

      for prevSum, count in dp.items():
        # Choose nums1[i]
        newDp[prevSum + a] += count
        newDp[prevSum + a] %= kMod
        # Choose nums2[i]
        newDp[prevSum - b] += count
        newDp[prevSum - b] %= kMod

      dp = newDp
      ans += dp[0]
      ans %= kMod

    return ans

```

## 57. Insert Interval_57.py
```python
class Solution:
  def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
    n = len(intervals)
    ans = []
    i = 0

    while i < n and intervals[i][1] < newInterval[0]:
      ans.append(intervals[i])
      i += 1

    # Merge overlapping intervals.
    while i < n and intervals[i][0] <= newInterval[1]:
      newInterval[0] = min(newInterval[0], intervals[i][0])
      newInterval[1] = max(newInterval[1], intervals[i][1])
      i += 1

    ans.append(newInterval)

    while i < n:
      ans.append(intervals[i])
      i += 1

    return ans

```

## 46. Permutations_46.py
```python
class Solution:
  def permute(self, nums: List[int]) -> List[List[int]]:
    ans = []
    used = [False] * len(nums)

    def dfs(path: List[int]) -> None:
      if len(path) == len(nums):
        ans.append(path.copy())
        return

      for i, num in enumerate(nums):
        if used[i]:
          continue
        used[i] = True
        path.append(num)
        dfs(path)
        path.pop()
        used[i] = False

    dfs([])
    return ans

```

## 1395. Count Number of Teams_1395.py
```python
class Solution:
  def numTeams(self, rating: List[int]) -> int:
    ans = 0

    for i in range(1, len(rating) - 1):
      # Calculate soldiers on the left with less//greater ratings.
      leftLess = 0
      leftGreater = 0
      for j in range(i):
        if rating[j] < rating[i]:
          leftLess += 1
        elif rating[j] > rating[i]:
          leftGreater += 1
      # Calculate soldiers on the right with less//greater ratings.
      rightLess = 0
      rightGreater = 0
      for j in range(i + 1, len(rating)):
        if rating[j] < rating[i]:
          rightLess += 1
        elif rating[j] > rating[i]:
          rightGreater += 1
      ans += leftLess * rightGreater + leftGreater * rightLess

    return ans

```

## 1163. Last Substring in Lexicographical Order_1163.py
```python
class Solution:
  def lastSubstring(self, s: str) -> str:
    i = 0
    j = 1
    k = 0  # the number of the same letters of s[i..n) and s[j..n)

    while j + k < len(s):
      if s[i + k] == s[j + k]:
        k += 1
      elif s[i + k] > s[j + k]:
        # s[i..i + k] == s[j..j + k] and s[i + k] > s[j + k] means that we
        # should start from s[j + k] to find a possible larger substring.
        j += k + 1
        k = 0
      else:
        # s[i..i + k] == s[j..j + k] and s[i + k] < s[j + k] means that either
        # starting from s[i + k + 1] or s[j] has a larger substring
        i = max(i + k + 1, j)
        j = i + 1
        k = 0

    return s[i:]

```

## 1799. Maximize Score After N Operations_1799.py
```python
class Solution:
  def maxScore(self, nums: List[int]) -> int:
    n = len(nums) // 2

    @functools.lru_cache(None)
    def dp(k: int, mask: int) -> int:
      """
      Returns the maximum score you can receive after performing the k to n
      operations, where `mask` is the bitmask of the chosen numbers.
      """
      if k == n + 1:
        return 0

      res = 0

      for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
          chosenMask = 1 << i | 1 << j
          if (mask & chosenMask) == 0:
            res = max(res,
                      k * math.gcd(nums[i], nums[j]) + dp(k + 1, mask | chosenMask))

      return res

    return dp(1, 0)

```

## 1057. Campus Bikes_1057.py
```python
class Solution:
  def assignBikes(self, workers: List[List[int]], bikes: List[List[int]]) -> List[int]:
    ans = [-1] * len(workers)
    usedBikes = [False] * len(bikes)
    # buckets[k] := (i, j), where k = dist(workers[i], bikes[j])
    buckets = [[] for _ in range(2001)]

    def dist(p1: List[int], p2: List[int]) -> int:
      return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

    for i, worker in enumerate(workers):
      for j, bike in enumerate(bikes):
        buckets[dist(worker, bike)].append((i, j))

    for k in range(2001):
      for i, j in buckets[k]:
        if ans[i] == -1 and not usedBikes[j]:
          ans[i] = j
          usedBikes[j] = True

    return ans

```

## 889. Construct Binary Tree from Preorder and Postorder Traversal_889.py
```python
class Solution:
  def constructFromPrePost(self, pre: List[int], post: List[int]) -> Optional[TreeNode]:
    postToIndex = {num: i for i, num in enumerate(post)}

    def build(preStart: int, preEnd: int, postStart: int, postEnd: int) -> Optional[TreeNode]:
      if preStart > preEnd:
        return None
      if preStart == preEnd:
        return TreeNode(pre[preStart])

      rootVal = pre[preStart]
      leftRootVal = pre[preStart + 1]
      leftRootPostIndex = postToIndex[leftRootVal]
      leftSize = leftRootPostIndex - postStart + 1

      root = TreeNode(rootVal)
      root.left = build(preStart + 1, preStart + leftSize,
                        postStart, leftRootPostIndex)
      root.right = build(preStart + leftSize + 1, preEnd,
                         leftRootPostIndex + 1, postEnd - 1)
      return root

    return build(0, len(pre) - 1, 0, len(post) - 1)

```

## 1999. Smallest Greater Multiple Made of Two Digits_1999.py
```python
class Solution:
  def findInteger(self, k: int, digit1: int, digit2: int) -> int:
    minDigit = min(digit1, digit2)
    maxDigit = max(digit1, digit2)
    digits = [minDigit] if minDigit == maxDigit else [minDigit, maxDigit]
    q = collections.deque()

    for digit in digits:
      q.append(digit)

    while q:
      u = q.popleft()
      if u > k and u % k == 0:
        return u
      if u == 0:
        continue
      for digit in digits:
        nextNum = u * 10 + digit
        if nextNum > 2**31 - 1:
          continue
        q.append(nextNum)

    return -1

```

## 847. Shortest Path Visiting All Nodes_847.py
```python
class Solution:
  def shortestPathLength(self, graph: List[List[int]]) -> int:
    n = len(graph)
    goal = (1 << n) - 1

    ans = 0
    q = collections.deque()  # (u, state)
    seen = set()

    for i in range(n):
      q.append((i, 1 << i))

    while q:
      for _ in range(len(q)):
        u, state = q.popleft()
        if state == goal:
          return ans
        if (u, state) in seen:
          continue
        seen.add((u, state))
        for v in graph[u]:
          q.append((v, state | (1 << v)))
      ans += 1

    return -1

```

## 2875. Minimum Size Subarray in Infinite Array_2875.py
```python
class Solution:
  def minSizeSubarray(self, nums: List[int], target: int) -> int:
    summ = sum(nums)
    n = len(nums)
    remainingTarget = target % summ
    repeatLength = (target // summ) * n
    if remainingTarget == 0:
      return repeatLength

    suffixPlusPrefixLength = n
    prefix = 0
    prefixToIndex = {0: -1}

    for i in range(2 * n):
      prefix += nums[i % n]
      if prefix - remainingTarget in prefixToIndex:
        suffixPlusPrefixLength = min(
            suffixPlusPrefixLength,
            i - prefixToIndex[prefix - remainingTarget])
      prefixToIndex[prefix] = i

    return -1 if suffixPlusPrefixLength == n else suffixPlusPrefixLength + repeatLength

```

## 1372. Longest ZigZag Path in a Binary Tree_1372.py
```python
class T:
  def __init__(self, leftMax: int, rightMax: int, subtreeMax: int):
    self.leftMax = leftMax
    self.rightMax = rightMax
    self.subtreeMax = subtreeMax


class Solution:
  def longestZigZag(self, root: Optional[TreeNode]) -> int:
    def dfs(root: Optional[TreeNode]) -> T:
      if not root:
        return T(-1, -1, -1)
      left = dfs(root.left)
      right = dfs(root.right)
      leftZigZag = left.rightMax + 1
      rightZigZag = right.leftMax + 1
      subtreeMax = max(leftZigZag, rightZigZag,
                       left.subtreeMax, right.subtreeMax)
      return T(leftZigZag, rightZigZag, subtreeMax)

    return dfs(root).subtreeMax

```

## 2767. Partition String Into Minimum Beautiful Substrings_2767.py
```python
class Solution:
  def minimumBeautifulSubstrings(self, s: str) -> int:
    n = len(s)
    # dp[i] := the minimum number of beautiful substrings for the first i chars
    dp = [0] + [n + 1] * n

    for i in range(1, n + 1):
      if s[i - 1] == '0':
        continue
      num = 0  # the number of s[i - 1..j - 1]
      for j in range(i, n + 1):
        num = (num << 1) + int(s[j - 1])
        if self._isPowerOfFive(num):
          dp[j] = min(dp[j], dp[i - 1] + 1)

    return -1 if dp[n] == n + 1 else dp[n]

  def _isPowerOfFive(self, num: int) -> bool:
    while num % 5 == 0:
      num //= 5
    return num == 1

```

## 1487. Making File Names Unique_1487.py
```python
class Solution:
  def getFolderNames(self, names: List[str]) -> List[str]:
    ans = []
    nameToSuffix = {}

    for name in names:
      if name in nameToSuffix:
        suffix = nameToSuffix[name] + 1
        newName = self._getName(name, suffix)
        while newName in nameToSuffix:
          suffix += 1
          newName = self._getName(name, suffix)
        nameToSuffix[name] = suffix
        nameToSuffix[newName] = 0
        ans.append(newName)
      else:
        nameToSuffix[name] = 0
        ans.append(name)

    return ans

  def _getName(self, name: str, suffix: int) -> str:
    return name + '(' + str(suffix) + ')'

```

## 75. Sort Colors_75.py
```python
class Solution:
  def sortColors(self, nums: List[int]) -> None:
    zero = -1
    one = -1
    two = -1

    for num in nums:
      if num == 0:
        two += 1
        one += 1
        zero += 1
        nums[two] = 2
        nums[one] = 1
        nums[zero] = 0
      elif num == 1:
        two += 1
        one += 1
        nums[two] = 2
        nums[one] = 1
      else:
        two += 1
        nums[two] = 2

```

## 158. Read N Characters Given Read4 II - Call multiple times_158.py
```python
# The read4 API is already defined for you.
# Def read4(buf4: List[str]) -> int:

class Solution:
  def read(self, buf: List[str], n: int) -> int:
    i = 0  # buf's index

    while i < n:
      if self.i4 == self.n4:  # All the characters in the buf4 are consumed.
        self.i4 = 0  # Reset the buf4's index.
        # Read <= 4 characters from the file to the buf4.
        self.n4 = read4(self.buf4)
        if self.n4 == 0:  # Reach the EOF.
          return i
      buf[i] = self.buf4[self.i4]
      i += 1
      self.i4 += 1

    return i

  buf4 = [' '] * 4
  i4 = 0  # buf4's index
  n4 = 0  # buf4's size

```

## 1175. Prime Arrangements_1175.py
```python
class Solution:
  def numPrimeArrangements(self, n: int) -> int:
    kMod = 1_000_000_007

    def countPrimes(n: int) -> int:
      isPrime = [False] * 2 + [True] * (n - 1)

      for i in range(2, int(n**0.5) + 1):
        if isPrime[i]:
          for j in range(i * i, n + 1, i):
            isPrime[j] = False

      return sum(isPrime)

    def factorial(n: int) -> int:
      fact = 1

      for i in range(1, n + 1):
        fact = fact * i % kMod

      return fact

    count = countPrimes(n)
    return factorial(count) * factorial(n - count) % kMod

```

## 1042. Flower Planting With No Adjacent_1042.py
```python
class Solution:
  def gardenNoAdj(self, n: int, paths: List[List[int]]) -> List[int]:
    ans = [0] * n  # ans[i] := 1, 2, 3, or 4
    graph = [[] for _ in range(n)]

    for a, b in paths:
      u = a - 1
      v = b - 1
      graph[u].append(v)
      graph[v].append(u)

    for i in range(n):
      used = [False] * 5
      for v in graph[i]:
        used[ans[v]] = True
      for type in range(1, 5):
        if not used[type]:
          ans[i] = type
          break

    return ans

```

## 215. Kth Largest Element in an Array_215-3.py
```python
class Solution:
  def findKthLargest(self, nums: List[int], k: int) -> int:
    def quickSelect(l: int, r: int, k: int) -> int:
      randIndex = random.randint(0, r - l) + l
      nums[randIndex], nums[r] = nums[r], nums[randIndex]
      pivot = nums[r]

      nextSwapped = l
      for i in range(l, r):
        if nums[i] >= pivot:
          nums[nextSwapped], nums[i] = nums[i], nums[nextSwapped]
          nextSwapped += 1
      nums[nextSwapped], nums[r] = nums[r], nums[nextSwapped]

      count = nextSwapped - l + 1  # Number of nums >= pivot
      if count == k:
        return nums[nextSwapped]
      if count > k:
        return quickSelect(l, nextSwapped - 1, k)
      return quickSelect(nextSwapped + 1, r, k - count)

    return quickSelect(0, len(nums) - 1, k)

```

## 1820. Maximum Number of Accepted Invitations_1820.py
```python
class Solution:
  def maximumInvitations(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    ans = 0
    mates = [-1] * n  # mates[i] := the i-th girl's mate

    def canInvite(i: int, seen: List[bool]) -> bool:
      """Returns True if the i-th boy can make an invitation."""
      # The i-th boy asks each girl.
      for j in range(n):
        if not grid[i][j] or seen[j]:
          continue
        seen[j] = True
        if mates[j] == -1 or canInvite(mates[j], seen):
          mates[j] = i  # Match the j-th girl with i-th boy.
          return True
      return False

    for i in range(m):
      seen = [False] * n
      if canInvite(i, seen):
        ans += 1

    return ans

```

## 3042. Count Prefix and Suffix Pairs I_3042.py
```python
class TrieNode:
  def __init__(self):
    self.children: Dict[Tuple[str, str], TrieNode] = {}
    self.count = 0


class Trie:
  def __init__(self):
    self.root = TrieNode()

  def insert(self, word: str) -> int:
    node = self.root
    count = 0
    for i, prefix in enumerate(word):
      suffix = word[-i - 1]
      node = node.children.setdefault((prefix, suffix), TrieNode())
      count += node.count
    node.count += 1
    return count


class Solution:
  def countPrefixSuffixPairs(self, words: List[str]) -> int:
    trie = Trie()
    return sum(trie.insert(word) for word in words)

```

## 393. UTF-8 Validation_393.py
```python
class Solution:
  def validUtf8(self, data: List[int]) -> bool:
    followedBytes = 0

    for d in data:
      if followedBytes == 0:
        if (d >> 3) == 0b11110:
          followedBytes = 3
        elif (d >> 4) == 0b1110:
          followedBytes = 2
        elif (d >> 5) == 0b110:
          followedBytes = 1
        elif (d >> 7) == 0b0:
          followedBytes = 0
        else:
          return False
      else:
        if (d >> 6) != 0b10:
          return False
        followedBytes -= 1

    return followedBytes == 0

```

## 2328. Number of Increasing Paths in a Grid_2328.py
```python
class Solution:
  def countPaths(self, grid: List[List[int]]) -> int:
    kMod = 1_000_000_007
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])

    @functools.lru_cache(None)
    def dp(i: int, j: int) -> int:
      """Returns the number of increasing paths starting from (i, j)."""
      ans = 1  # The current cell contributes 1 length.
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        if grid[x][y] <= grid[i][j]:
          continue
        ans += dp(x, y)
        ans %= kMod
      return ans

    return sum(dp(i, j)
               for i in range(m)
               for j in range(n)) % kMod

```

## 792. Number of Matching Subsequences_792-2.py
```python
class Solution:
  def numMatchingSubseq(self, s: str, words: List[str]) -> int:
    ans = 0
    # [(i, j)] := words[i] and the letter words[i][j] is waiting for
    bucket = [[] for _ in range(26)]

    # For each word, it's waiting for word[0].
    for i, word in enumerate(words):
      bucket[ord(word[0]) - ord('a')].append((i, 0))

    for c in s:
      # Let prevBucket = bucket[c] and clear bucket[c].
      index = ord(c) - ord('a')
      prevBucket = bucket[index]
      bucket[index] = []
      for i, j in prevBucket:
        j += 1
        if j == len(words[i]):  # All the letters in words[i] are matched.
          ans += 1
        else:
          bucket[ord(words[i][j]) - ord('a')].append((i, j))

    return ans

```

## 999. Available Captures for Rook_999.py
```python
class Solution:
  def numRookCaptures(self, board: List[List[str]]) -> int:
    ans = 0

    for i in range(8):
      for j in range(8):
        if board[i][j] == 'R':
          i0 = i
          j0 = j

    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:
      i = i0 + d[0]
      j = j0 + d[1]
      while 0 <= i < 8 and 0 <= j < 8:
        if board[i][j] == 'p':
          ans += 1
        if board[i][j] != '.':
          break
        i += d[0]
        j += d[1]

    return ans

```

## 1028. Recover a Tree From Preorder Traversal_1028.py
```python
class Solution:
  def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:
    i = 0

    def recoverFromPreorder(depth: int) -> Optional[TreeNode]:
      nonlocal i
      nDashes = 0
      while i + nDashes < len(traversal) and traversal[i + nDashes] == '-':
        nDashes += 1
      if nDashes != depth:
        return None

      i += depth
      start = i
      while i < len(traversal) and traversal[i].isdigit():
        i += 1

      return TreeNode(int(traversal[start:i]),
                      recoverFromPreorder(depth + 1),
                      recoverFromPreorder(depth + 1))

    return recoverFromPreorder(0)

```

## 3077. Maximum Strength of K Disjoint Subarrays_3077.py
```python
class Solution:
  def maximumStrength(self, nums: List[int], k: int) -> int:

    @functools.lru_cache(None)
    def dp(i: int, k: int, fresh: bool) -> int:
      """
      Returns the maximum strength of nums[i..n) with k operations left, where
      `fresh` means we're starting a new subarray.
      """
      if len(nums) - i < k:
        return -math.inf
      if k == 0:
        return 0
      if i == len(nums):
        return 0 if k == 0 else -math.inf
      # If it's not fresh, we can't skip the current number and consider it as a
      # fresh start, since the case where it's fresh is already covered by
      # `includeAndFreshStart`.
      skip = dp(i + 1, k, True) if fresh else -math.inf
      gain = (-1 if k % 2 == 0 else 1) * nums[i] * k
      includeAndContinue = dp(i + 1, k, False) + gain
      includeAndFreshStart = dp(i + 1, k - 1, True) + gain
      return max(skip, includeAndContinue, includeAndFreshStart)

    return dp(0, k, True)

```

## 402. Remove K Digits_402.py
```python
class Solution:
  def removeKdigits(self, num: str, k: int) -> str:
    if len(num) == k:
      return '0'

    ans = []
    stack = []

    for i, digit in enumerate(num):
      while k > 0 and stack and stack[-1] > digit:
        stack.pop()
        k -= 1
      stack.append(digit)

    for _ in range(k):
      stack.pop()

    for c in stack:
      if c == '0' and not ans:
        continue
      ans.append(c)

    return ''.join(ans) if ans else '0'

```

## 2454. Next Greater Element IV_2454.py
```python
class Solution:
  def secondGreaterElement(self, nums: List[int]) -> List[int]:
    ans = [-1] * len(nums)
    # a decreasing stack that stores indices that met the first greater number.
    prevStack = []
    # a decreasing stack that stores indices.
    currStack = []

    for i, num in enumerate(nums):
      # Indices in prevStack meet the second greater num.
      while prevStack and nums[prevStack[-1]] < num:
        ans[prevStack.pop()] = num
      # Push indices that meet the first greater number from `currStack` to
      # `prevStack`. We need a temporary array to make the indices in the
      # `prevStack` increasing.
      decreasingIndices = []
      while currStack and nums[currStack[-1]] < num:
        decreasingIndices.append(currStack.pop())
      while decreasingIndices:
        prevStack.append(decreasingIndices.pop())
      currStack.append(i)

    return ans

```

## 2615. Sum of Distances_2615.py
```python
class Solution:
  def distance(self, nums: List[int]) -> List[int]:
    ans = [0] * len(nums)
    numToIndices = collections.defaultdict(list)

    for i, num in enumerate(nums):
      numToIndices[num].append(i)

    for indices in numToIndices.values():
      n = len(indices)
      if n == 1:
        continue
      sumSoFar = sum(indices)
      prevIndex = 0
      for i in range(n):
        sumSoFar += (i - 1) * (indices[i] - prevIndex)
        sumSoFar -= (n - 1 - i) * (indices[i] - prevIndex)
        ans[indices[i]] = sumSoFar
        prevIndex = indices[i]

    return ans

```

## 16. 3Sum Closest_16.py
```python
class Solution:
  def threeSumClosest(self, nums: List[int], target: int) -> int:
    ans = nums[0] + nums[1] + nums[2]

    nums.sort()

    for i in range(len(nums) - 2):
      if i > 0 and nums[i] == nums[i - 1]:
        continue
      # Choose nums[i] as the first number in the triplet, then search the
      # remaining numbers in [i + 1, n - 1].
      l = i + 1
      r = len(nums) - 1
      while l < r:
        summ = nums[i] + nums[l] + nums[r]
        if summ == target:
          return summ
        if abs(summ - target) < abs(ans - target):
          ans = summ
        if summ < target:
          l += 1
        else:
          r -= 1

    return ans

```

## 163. Missing Ranges_163.py
```python
class Solution:
  def findMissingRanges(self, nums: List[int], lower: int, upper: int) -> List[str]:
    def getRange(lo: int, hi: int) -> str:
      if lo == hi:
        return str(lo)
      return str(lo) + '->' + str(hi)

    if not nums:
      return [getRange(lower, upper)]

    ans = []

    if nums[0] > lower:
      ans.append(getRange(lower, nums[0] - 1))

    for prev, curr in zip(nums, nums[1:]):
      if curr > prev + 1:
        ans.append(getRange(prev + 1, curr - 1))

    if nums[-1] < upper:
      ans.append(getRange(nums[-1] + 1, upper))

    return ans

```

## 1114. Print in Order_1114.py
```python
from threading import Lock


class Foo:
  def __init__(self):
    self.firstDone = Lock()
    self.secondDone = Lock()
    self.firstDone.acquire()
    self.secondDone.acquire()

  def first(self, printFirst: 'Callable[[], None]') -> None:
    printFirst()
    self.firstDone.release()

  def second(self, printSecond: 'Callable[[], None]') -> None:
    self.firstDone.acquire()
    printSecond()
    self.secondDone.release()

  def third(self, printThird: 'Callable[[], None]') -> None:
    self.secondDone.acquire()
    printThird()

```

## 1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold_1292.py
```python
class Solution:
  def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:
    m = len(mat)
    n = len(mat[0])
    ans = 0
    prefix = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m):
      for j in range(n):
        prefix[i + 1][j + 1] = mat[i][j] + prefix[i][j + 1] + \
            prefix[i + 1][j] - prefix[i][j]

    def squareSum(r1: int, c1: int, r2: int, c2: int) -> int:
      return prefix[r2 + 1][c2 + 1] - prefix[r1][c2 + 1] - prefix[r2 + 1][c1] + prefix[r1][c1]

    for i in range(m):
      for j in range(n):
        for length in range(ans, min(m - i, n - j)):
          if squareSum(i, j, i + length, j + length) > threshold:
            break
          ans = max(ans, length + 1)

    return ans

```

## 97. Interleaving String_97.py
```python
class Solution:
  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
    m = len(s1)
    n = len(s2)
    if m + n != len(s3):
      return False

    # dp[i][j] := true if s3[0..i + j) is formed by the interleaving of
    # s1[0..i) and s2[0..j)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True

    for i in range(1, m + 1):
      dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]

    for j in range(1, n + 1):
      dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]

    for i in range(1, m + 1):
      for j in range(1, n + 1):
        dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or \
            (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])

    return dp[m][n]

```

## 3067. Count Pairs of Connectable Servers in a Weighted Tree Network_3067.py
```python
class Solution:
  def countPairsOfConnectableServers(self, edges: List[List[int]], signalSpeed: int) -> List[int]:
    n = len(edges) + 1
    tree = [[] for _ in range(n)]

    for u, v, w in edges:
      tree[u].append((v, w))
      tree[v].append((u, w))

    def connectablePairsRootedAt(u: int) -> int:
      pairs = 0
      count = 0
      for v, w in tree[u]:
        childCount = dfs(v, u, w)
        pairs += count * childCount
        count += childCount
      return pairs

    def dfs(u: int, prev: int, dist: int) -> int:
      return int(dist % signalSpeed == 0) + \
          sum(dfs(v, u, dist + w)
              for v, w in tree[u]
              if v != prev)

    return [connectablePairsRootedAt(i) for i in range(n)]

```

## 1074. Number of Submatrices That Sum to Target_1074.py
```python
class Solution:
  def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -> int:
    m = len(matrix)
    n = len(matrix[0])
    ans = 0

    # Transfer each row in the matrix to the prefix sum.
    for row in matrix:
      for i in range(1, n):
        row[i] += row[i - 1]

    for baseCol in range(n):
      for j in range(baseCol, n):
        prefixCount = collections.Counter({0: 1})
        summ = 0
        for i in range(m):
          if baseCol > 0:
            summ -= matrix[i][baseCol - 1]
          summ += matrix[i][j]
          ans += prefixCount[summ - target]
          prefixCount[summ] += 1

    return ans

```

## 3200. Maximum Height of a Triangle_3200.py
```python
class Solution:
  def maxHeightOfTriangle(self, red: int, blue: int) -> int:
    return max(self._maxHeight(red, blue),
               self._maxHeight(blue, red))

  def _maxHeight(self, n1: int, n2: int) -> int:
    """
    Returns the maximum height of a triangle with the odd levels having `n1`
    balls and the even levels having `n2` balls.
    """
    #             1 + 3 + ... + h <= n1
    # ((1 + h) * (n + 1) / 2) / 2 <= n1
    #                           h <= sqrt(4 * n1) - 1
    oddHeight = math.isqrt(4 * n1) - 1
    #       2 + 4 + ... + h <= n2
    # ((2 + h) * h / 2) / 2 <= n2
    #                     h <= sqrt(4 * n2 + 1) - 1
    evenHeight = math.isqrt(4 * n2 + 1) - 1
    # If the difference between the odd and even heights is >= 1, we can add an
    # extra level to the minimum height.
    return min(oddHeight, evenHeight) + (1 if abs(oddHeight - evenHeight) >= 1 else 0)

```

## 919. Complete Binary Tree Inserter_919.py
```python
class CBTInserter:
  def __init__(self, root: Optional[TreeNode]):
    self.tree = [root]
    for node in self.tree:
      if node.left:
        self.tree.append(node.left)
      if node.right:
        self.tree.append(node.right)

  def insert(self, v: int) -> int:
    n = len(self.tree)
    self.tree.append(TreeNode(v))
    parent = self.tree[(n - 1) // 2]
    if n % 2 == 1:
      parent.left = self.tree[-1]
    else:
      parent.right = self.tree[-1]
    return parent.val

  def get_root(self) -> Optional[TreeNode]:
    return self.tree[0]

```

## 1575. Count All Possible Routes_1575.py
```python
class Solution:
  def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:
    kMod = 1_000_000_007

    @functools.lru_cache(None)
    def dp(i: int, fuel: int) -> int:
      """
      Returns the number of ways to reach the `finish` city from the i-th city
      with `fuel` fuel.
      """
      if fuel < 0:
        return 0

      res = 1 if i == finish else 0
      for j in range(len(locations)):
        if j == i:
          continue
        res += dp(j, fuel - abs(locations[i] - locations[j]))
        res %= kMod

      return res

    return dp(start, fuel)

```

## 562. Longest Line of Consecutive One in Matrix_562.py
```python
class Solution:
  def longestLine(self, mat: List[List[int]]) -> int:
    m = len(mat)
    n = len(mat[0])
    ans = 0
    # dp[i][j][0] := horizontal
    # dp[i][j][1] := vertical
    # dp[i][j][2] := diagonal
    # dp[i][j][3] := anti-diagonal
    dp = [[[0] * 4 for j in range(n)] for _ in range(m)]

    for i in range(m):
      for j in range(n):
        if mat[i][j] == 1:
          dp[i][j][0] = dp[i][j - 1][0] + 1 if j > 0 else 1
          dp[i][j][1] = dp[i - 1][j][1] + 1 if i > 0 else 1
          dp[i][j][2] = dp[i - 1][j - 1][2] + 1 if i > 0 and j > 0 else 1
          dp[i][j][3] = dp[i - 1][j + 1][3] + 1 if i > 0 and j < n - 1 else 1
          ans = max(ans, max(dp[i][j]))

    return ans

```

## 3116. Kth Smallest Amount With Single Denomination Combination_3116.py
```python
class Solution:
  def findKthSmallest(self, coins: List[int], k: int) -> int:
    sizeToLcms = self._getSizeToLcms(coins)

    def count(m: int) -> int:
      """Returns the number of denominations <= m."""
      res = 0
      for sz, lcms in enumerate(sizeToLcms):
        for lcm in lcms:
          # Principle of Inclusion-Exclusion (PIE)
          res += m // lcm * pow(-1, sz + 1)
      return res

    return bisect.bisect_left(range(0, k * min(coins)), k,
                              key=lambda m: count(m))

  def _getSizeToLcms(self, coins: List[int]) -> List[List[int]]:
    # Returns the LCMs for each number of combination of coins.
    sizeToLcms = [[] for _ in range(len(coins) + 1)]
    for sz in range(1, len(coins) + 1):
      for combination in itertools.combinations(coins, sz):
        sizeToLcms[sz].append(math.lcm(*combination))
    return sizeToLcms

```

## 374. Guess Number Higher or Lower_374.py
```python
# The guess API is already defined for you.
# @param num, your guess
# @return -1 if num is higher than the picked number
#          1 if num is lower than the picked number
#          otherwise return 0
# def guess(num: int) -> int:

class Solution:
  def guessNumber(self, n: int) -> int:
    l = 1
    r = n

    # Find the first guess number that >= the target number
    while l < r:
      m = (l + r) // 2
      if guess(m) <= 0:  # -1, 0
        r = m
      else:
        l = m + 1

    return l

```

## 2104. Sum of Subarray Ranges_2104.py
```python
class Solution:
  def subArrayRanges(self, nums: List[int]) -> int:
    n = len(nums)

    def sumSubarray(A: List[int], op):
      res = 0
      prev = [-1] * n
      next = [n] * n
      stack = []

      for i, a in enumerate(A):
        while stack and op(A[stack[-1]], a):
          index = stack.pop()
          next[index] = i
        if stack:
          prev[i] = stack[-1]
        stack.append(i)

      for i, a in enumerate(A):
        res += a * (i - prev[i]) * (next[i] - i)

      return res

    return sumSubarray(nums, operator.lt) - sumSubarray(nums, operator.gt)

```

## 3040. Maximum Number of Operations With the Same Score II_3040.py
```python
class Solution:
  def maxOperations(self, nums: List[int]) -> int:
    @functools.lru_cache(None)
    def dp(i: int, j: int, score: int) -> int:
      """
      Returns the maximum number of operations that can be performed for
      nums[i..j], s.t. all operations have the same `score`.
      """
      if i >= j:
        return 0
      deleteFirstTwo = 1 + dp(i + 2, j, score) \
          if nums[i] + nums[i + 1] == score else 0
      deleteLastTwo = 1 + dp(i, j - 2, score) \
          if nums[j] + nums[j - 1] == score else 0
      deleteFirstAndLast = 1 + dp(i + 1, j - 1, score) \
          if nums[i] + nums[j] == score else 0
      return max(deleteFirstTwo, deleteLastTwo, deleteFirstAndLast)

    n = len(nums)
    return max(dp(0, n - 1, nums[0] + nums[1]),
               dp(0, n - 1, nums[-1] + nums[-2]),
               dp(0, n - 1, nums[0] + nums[-1]))

```

## 295. Find Median from Data Stream_295.py
```python
class MedianFinder:
  def __init__(self):
    self.maxHeap = []
    self.minHeap = []

  def addNum(self, num: int) -> None:
    if not self.maxHeap or num <= -self.maxHeap[0]:
      heapq.heappush(self.maxHeap, -num)
    else:
      heapq.heappush(self.minHeap, num)

    # Balance the two heaps s.t.
    # |maxHeap| >= |minHeap| and |maxHeap| - |minHeap| <= 1.
    if len(self.maxHeap) < len(self.minHeap):
      heapq.heappush(self.maxHeap, -heapq.heappop(self.minHeap))
    elif len(self.maxHeap) - len(self.minHeap) > 1:
      heapq.heappush(self.minHeap, -heapq.heappop(self.maxHeap))

  def findMedian(self) -> float:
    if len(self.maxHeap) == len(self.minHeap):
      return (-self.maxHeap[0] + self.minHeap[0]) / 2.0
    return -self.maxHeap[0]

```

## 691. Stickers to Spell Word_691.py
```python
class Solution:
  def minStickers(self, stickers: List[str], target: str) -> int:
    maxMask = 1 << len(target)
    # dp[i] := the minimum number of stickers to spell out i, where i is the
    # bit mask of target
    dp = [math.inf] * maxMask
    dp[0] = 0

    for mask in range(maxMask):
      if dp[mask] == math.inf:
        continue
      # Try to expand from `mask` by using each sticker.
      for sticker in stickers:
        superMask = mask
        for c in sticker:
          for i, t in enumerate(target):
            # Try to apply it on a missing letter.
            if c == t and not (superMask >> i & 1):
              superMask |= 1 << i
              break
        dp[superMask] = min(dp[superMask], dp[mask] + 1)

    return -1 if dp[-1] == math.inf else dp[-1]

```

## 2896. Apply Operations to Make Two Strings Equal_2896.py
```python
class Solution:
  def minOperations(self, s1: str, s2: str, x: int) -> int:
    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))
                   if a != b]
    if not diffIndices:
      return 0
    # It's impossible to make two strings equal if there are odd number of
    # differences.
    if len(diffIndices) & 1:
      return -1

    @functools.lru_cache(None)
    def dp(i: int) -> int:
      """Returns the minimum cost to correct diffIndices[i..n)."""
      if i == len(diffIndices):
        return 0
      if i == len(diffIndices) - 1:
        return x / 2
      return min(dp(i + 1) + x / 2,
                 dp(i + 2) + diffIndices[i + 1] - diffIndices[i])

    return int(dp(0))

```

## 1354. Construct Target Array With Multiple Sums_1354.py
```python
class Solution:
  def isPossible(self, target: List[int]) -> bool:
    if len(target) == 1:
      return target[0] == 1

    summ = sum(target)
    maxHeap = [-num for num in target]
    heapq.heapify(maxHeap)

    while -maxHeap[0] > 1:
      mx = -heapq.heappop(maxHeap)
      restSum = summ - mx
      # Only occurs if n == 2.
      if restSum == 1:
        return True
      updated = mx % restSum
      # updated == 0 (invalid) or didn't change.
      if updated == 0 or updated == mx:
        return False
      heapq.heappush(maxHeap, -updated)
      summ = summ - mx + updated

    return True

```

## 366. Find Leaves of Binary Tree_366.py
```python
class Solution:
  def findLeaves(self, root: Optional[TreeNode]) -> List[List[int]]:
    ans = []

    def depth(root: Optional[TreeNode]) -> int:
      """Returns the depth of the root (0-indexed)."""
      if not root:
        return -1

      l = depth(root.left)
      r = depth(root.right)
      h = 1 + max(l, r)

      if len(ans) == h:  # Meet a leaf
        ans.append([])

      ans[h].append(root.val)
      return h

    depth(root)
    return ans

```

## 2261. K Divisible Elements Subarrays_2261.py
```python
class TrieNode:
  def __init__(self):
    self.children: Dict[int, TrieNode] = {}
    self.count = 0


class Solution:
  def countDistinct(self, nums: List[int], k: int, p: int) -> int:
    ans = 0
    root = TrieNode()

    def insert(node: TrieNode, i: int, k: int):
      nonlocal ans
      if i == len(nums) or k - (nums[i] % p == 0) < 0:
        return
      if nums[i] not in node.children:
        node.children[nums[i]] = TrieNode()
        ans += 1
      insert(node.children[nums[i]], i + 1, k - (nums[i] % p == 0))

    for i in range(len(nums)):
      insert(root, i, k)

    return ans

```

## 837. New 21 Game_837.py
```python
class Solution:
  def new21Game(self, n: int, k: int, maxPts: int) -> float:
    # When the game ends, the point is in [k..k - 1 maxPts].
    #   P = 1, if n >= k - 1 + maxPts
    #   P = 0, if n < k (note that the constraints already have k <= n)
    if k == 0 or n >= k - 1 + maxPts:
      return 1.0

    ans = 0.0
    dp = [1.0] + [0] * n  # dp[i] := the probability to have i points
    windowSum = dp[0]  # P(i - 1) + P(i - 2) + ... + P(i - maxPts)

    for i in range(1, n + 1):
      # The probability to get i points is
      # P(i) = [P(i - 1) + P(i - 2) + ... + P(i - maxPts)] / maxPts
      dp[i] = windowSum / maxPts
      if i < k:
        windowSum += dp[i]
      else:  # The game ends.
        ans += dp[i]
      if i - maxPts >= 0:
        windowSum -= dp[i - maxPts]

    return ans

```

## 2488. Count Subarrays With Median K_2488.py
```python
class Solution:
  def countSubarrays(self, nums: List[int], k: int) -> int:
    kIndex = nums.index(k)
    ans = 0
    count = collections.Counter()

    balance = 0
    for i in range(kIndex, -1, -1):
      if nums[i] < k:
        balance -= 1
      elif nums[i] > k:
        balance += 1
      count[balance] += 1

    balance = 0
    for i in range(kIndex, len(nums)):
      if nums[i] < k:
        balance -= 1
      elif nums[i] > k:
        balance += 1
      # The subarray that has balance == 0 or 1 having median equal to k.
      # So, add count[0 - balance] and count[1 - balance] to `ans`.
      ans += count[-balance] + count[1 - balance]

    return ans

```

## 2513. Minimize the Maximum of Two Arrays_2513.py
```python
class Solution:
  def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:
    divisorLcm = math.lcm(divisor1, divisor2)
    l = 0
    r = 2**31 - 1

    # True if we can take uniqueCnt1 integers from [1..m] to arr1 and take
    # uniqueCnt2 integers from [1..m] to arr2.
    def isPossible(m: int) -> bool:
      cnt1 = m - m // divisor1
      cnt2 = m - m // divisor2
      totalCnt = m - m // divisorLcm
      return cnt1 >= uniqueCnt1 and cnt2 >= uniqueCnt2 and \
          totalCnt >= uniqueCnt1 + uniqueCnt2

    while l < r:
      m = (l + r) // 2
      if isPossible(m):
        r = m
      else:
        l = m + 1

    return l

```

## 2137. Pour Water Between Buckets to Make Water Levels Equal_2137.py
```python
class Solution:
  def equalizeWater(self, buckets: List[int], loss: int) -> float:
    kErr = 1e-5
    kPercentage = (100 - loss) / 100
    l = 0.0
    r = max(buckets)

    def canFill(target: float) -> bool:
      extra = 0
      need = 0
      for bucket in buckets:
        if bucket > target:
          extra += bucket - target
        else:
          need += target - bucket
      return extra * kPercentage >= need

    while r - l > kErr:
      m = (l + r) / 2
      if canFill(m):
        l = m
      else:
        r = m

    return l

```

## 33. Search in Rotated Sorted Array_33.py
```python
class Solution:
  def search(self, nums: List[int], target: int) -> int:
    l = 0
    r = len(nums) - 1

    while l <= r:
      m = (l + r) // 2
      if nums[m] == target:
        return m
      if nums[l] <= nums[m]:  # nums[l..m] are sorted.
        if nums[l] <= target < nums[m]:
          r = m - 1
        else:
          l = m + 1
      else:  # nums[m..n - 1] are sorted.
        if nums[m] < target <= nums[r]:
          l = m + 1
        else:
          r = m - 1

    return -1

```

## 2371. Minimize Maximum Value in a Grid_2371.py
```python
class Solution:
  def minScore(self, grid: List[List[int]]) -> List[List[int]]:
    m = len(grid)
    n = len(grid[0])
    ans = [[0] * n for _ in range(m)]
    valAndIndices = []
    rows = [0] * m  # rows[i] := the maximum used number so far
    cols = [0] * n  # cols[j] := the maximum used number so far

    for i in range(m):
      for j in range(n):
        valAndIndices.append((grid[i][j], i, j))

    valAndIndices.sort()

    for _, i, j in valAndIndices:
      nextAvailable = max(rows[i], cols[j]) + 1
      ans[i][j] = nextAvailable
      rows[i] = nextAvailable
      cols[j] = nextAvailable

    return ans

```

## 2096. Step-By-Step Directions From a Binary Tree Node to Another_2096-2.py
```python
class Solution:
  def getDirections(self, root: Optional[TreeNode], startValue: int, destValue: int) -> str:
    # Buidl the string in reverse order to avoid creating new copy
    def dfs(root: Optional[TreeNode], val: int, path: List[chr]) -> bool:
      if root.val == val:
        return True
      if root.left and dfs(root.left, val, path):
        path.append('L')
      elif root.right and dfs(root.right, val, path):
        path.append('R')
      return len(path) > 0

    pathToStart = []
    pathToDest = []

    dfs(root, startValue, pathToStart)
    dfs(root, destValue, pathToDest)

    while pathToStart and pathToDest and pathToStart[-1] == pathToDest[-1]:
      pathToStart.pop()
      pathToDest.pop()

    return 'U' * len(pathToStart) + ''.join(reversed(pathToDest))

```

## 394. Decode String_394-2.py
```python
class Solution:
  def decodeString(self, s: str) -> str:
    ans = ''

    while self.i < len(s) and s[self.i] != ']':
      if s[self.i].isdigit():
        k = 0
        while self.i < len(s) and s[self.i].isdigit():
          k = k * 10 + int(s[self.i])
          self.i += 1
        self.i += 1  # '['
        decodedString = self.decodeString(s)
        self.i += 1  # ']'
        ans += k * decodedString
      else:
        ans += s[self.i]
        self.i += 1

    return ans

  i = 0

```

## 2241. Design an ATM Machine_2241.py
```python
class ATM:
  def __init__(self):
    self.banknotes = [20, 50, 100, 200, 500]
    self.bank = [0] * 5

  def deposit(self, banknotesCount: List[int]) -> None:
    for i in range(5):
      self.bank[i] += banknotesCount[i]

  def withdraw(self, amount: int) -> List[int]:
    withdrew = [0] * 5

    for i in reversed(range(5)):
      withdrew[i] = min(self.bank[i], amount // self.banknotes[i])
      amount -= withdrew[i] * self.banknotes[i]

    if amount:
      return [-1]

    for i in range(5):
      self.bank[i] -= withdrew[i]
    return withdrew

```

## 678. Valid Parenthesis String_678.py
```python
class Solution:
  def checkValidString(self, s: str) -> bool:
    low = 0
    high = 0

    for c in s:
      if c == '(':
        low += 1
        high += 1
      elif c == ')':
        if low > 0:
          low -= 1
        high -= 1
      else:
        if low > 0:
          low -= 1
        high += 1
      if high < 0:
        return False

    return low == 0

```

## 1823. Find the Winner of the Circular Game_1823.py
```python
class Solution:
  def findTheWinner(self, n: int, k: int) -> int:
    # True if i-th friend is left
    friends = [False] * n

    friendCount = n
    fp = 0  # friends' index

    while friendCount > 1:
      for _ in range(k):
        while friends[fp % n]:  # The friend is not there.
          fp += 1  # Point to the next one.
        fp += 1
      friends[(fp - 1) % n] = True
      friendCount -= 1

    fp = 0
    while friends[fp]:
      fp += 1

    return fp + 1

```

## 666. Path Sum IV_666.py
```python
class Solution:
  def pathSum(self, nums: List[int]) -> int:
    ans = 0
    tree = [[-1] * 8 for _ in range(4)]

    for num in nums:
      d = num // 100 - 1
      p = (num % 100) // 10 - 1
      v = num % 10
      tree[d][p] = v

    def dfs(i: int, j: int, path: int) -> None:
      nonlocal ans
      if tree[i][j] == -1:
        return
      if i == 3 or max(tree[i + 1][j * 2], tree[i + 1][j * 2 + 1]) == -1:
        ans += path + tree[i][j]
        return

      dfs(i + 1, j * 2, path + tree[i][j])
      dfs(i + 1, j * 2 + 1, path + tree[i][j])

    dfs(0, 0, 0)
    return ans

```

## 3080. Mark Elements on Array by Performing Queries_3080.py
```python
class Solution:
  def unmarkedSumArray(self, nums: List[int], queries: List[List[int]]) -> List[int]:
    ans = []
    marked = set()
    summ = sum(nums)
    minHeap = [(num, i) for i, num in enumerate(nums)]
    heapq.heapify(minHeap)

    for index, k in queries:
      if index not in marked:
        marked.add(index)
        summ -= nums[index]
      popped = 0
      while popped < k and minHeap:
        num, i = heapq.heappop(minHeap)
        if i not in marked:
          marked.add(i)
          summ -= num
          popped += 1
      ans.append(summ)

    return ans

```

## 320. Generalized Abbreviation_320.py
```python
class Solution:
  def generateAbbreviations(self, word: str) -> List[str]:
    ans = []

    def getCountString(count: int) -> str:
      return str(count) if count > 0 else ''

    def dfs(i: int, count: int, path: List[str]) -> None:
      if i == len(word):
        ans.append(''.join(path) + getCountString(count))
        return

      # Abbreviate the word[i].
      dfs(i + 1, count + 1, path)
      # Keep the word[i], so consume the count as a string.
      path.append(getCountString(count) + word[i])
      # Reset the count to 0.
      dfs(i + 1, 0, path)
      path.pop()

    dfs(0, 0, [])
    return ans

```

## 3092. Most Frequent IDs_3092.py
```python
from sortedcontainers import SortedDict


class Solution:
  def mostFrequentIDs(self, nums: List[int], freq: List[int]) -> List[int]:
    ans = []
    numCount = collections.Counter()  # {num: freq}
    freqCount = SortedDict()  # {num's freq: freq}

    for num, f in zip(nums, freq):
      if numCount[num] > 0:
        numFreq = numCount[num]
        freqCount[numFreq] -= 1
        if freqCount[numFreq] == 0:
          del freqCount[numFreq]
      newFreq = numCount[num] + f
      if newFreq == 0:
        del numCount[num]
      else:
        numCount[num] = newFreq
        freqCount[newFreq] = freqCount.get(newFreq, 0) + 1
      ans.append(freqCount.peekitem(-1)[0] if freqCount else 0)

    return ans

```

## 2552. Count Increasing Quadruplets_2552.py
```python
class Solution:
  def countQuadruplets(self, nums: List[int]) -> int:
    ans = 0
    # dp[j] := the number of triplets (i, j, k) where i < j < k and nums[i] < nums[k] <
    # nums[j]. Keep this information for l to use later.
    dp = [0] * len(nums)

    # k can be treated as l.
    for k in range(2, len(nums)):
      numLessThanK = 0
      # j can be treated as i.
      for j in range(k):
        if nums[j] < nums[k]:
          numLessThanK += 1  # nums[i] < nums[k]
          # nums[j] < nums[l], so we should add dp[j] since we find a new
          # quadruplets for (i, j, k, l).
          ans += dp[j]
        elif nums[j] > nums[k]:
          dp[j] += numLessThanK

    return ans

```

## 2732. Find a Good Subset of the Matrix_2732.py
```python
class Solution:
  def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:
    kMaxBit = 30
    maskToIndex = {}

    def getMask(row: List[int]) -> int:
      mask = 0
      for i, num in enumerate(row):
        if num == 1:
          mask |= 1 << i
      return mask

    for i, row in enumerate(grid):
      mask = getMask(row)
      if mask == 0:
        return [i]
      for prevMask in range(1, kMaxBit):
        if (mask & prevMask) == 0 and prevMask in maskToIndex:
          return [maskToIndex[prevMask], i]
      maskToIndex[mask] = i

    return []

```

## 1883. Minimum Skips to Arrive at Meeting On Time_1883.py
```python
class Solution:
  def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -> int:
    kInf = 10**7
    kEps = 1e-9
    n = len(dist)
    # dp[i][j] := the minimum time, where i is the number of roads we traversed
    # so far and j is the number of skips we did
    dp = [[kInf] * (n + 1) for _ in range(n + 1)]
    dp[0][0] = 0

    for i, d in enumerate(dist, 1):
      dp[i][0] = math.ceil(dp[i - 1][0] + d / speed - kEps)
      for j in range(1, i + 1):
        dp[i][j] = min(dp[i - 1][j - 1] + d / speed,
                       math.ceil(dp[i - 1][j] + d / speed - kEps))

    for j, time in enumerate(dp[-1]):
      if time <= hoursBefore:
        return j

    return -1

```

## 3186. Maximum Total Damage With Spell Casting_3186.py
```python
class Solution:
  def maximumTotalDamage(self, power: List[int]) -> int:
    count = collections.Counter(power)
    uniqueDamages = sorted(count.keys())
    # dp[i][k] := the maximum damage using uniqueDamages[0..i], where k
    # indicates if the i-th damage is used
    dp = [[0] * 2 for _ in range(len(uniqueDamages))]

    for i, damage in enumerate(uniqueDamages):
      if i == 0:
        dp[0] = [0, damage * count[damage]]
        continue
      dp[i][0] = max(dp[i - 1])
      dp[i][1] = damage * count[damage]
      if i >= 1 and uniqueDamages[i - 1] not in (damage - 1, damage - 2):
        dp[i][1] += max(dp[i - 1])
      elif i >= 2 and uniqueDamages[i - 2] != damage - 2:
        dp[i][1] += max(dp[i - 2])
      elif i >= 3:
        dp[i][1] += max(dp[i - 3])

    return max(dp[-1])

```

## 576. Out of Boundary Paths_576-2.py
```python
class Solution:
  def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    kMod = 1_000_000_007
    ans = 0
    # dp[i][j] := the number of paths to move the ball (i, j) out-of-bounds
    dp = [[0] * n for _ in range(m)]
    dp[startRow][startColumn] = 1

    for _ in range(maxMove):
      newDp = [[0] * n for _ in range(m)]
      for i in range(m):
        for j in range(n):
          if dp[i][j] > 0:
            for dx, dy in dirs:
              x = i + dx
              y = j + dy
              if x < 0 or x == m or y < 0 or y == n:
                ans = (ans + dp[i][j]) % kMod
              else:
                newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod
      dp = newDp

    return ans

```

## 1648. Sell Diminishing-Valued Colored Balls_1648.py
```python
class Solution:
  def maxProfit(self, inventory: List[int], orders: int) -> int:
    kMod = 1_000_000_007
    ans = 0
    largestCount = 1

    def trapezoid(a: int, b: int) -> int:
      return (a + b) * (a - b + 1) // 2

    for a, b in itertools.pairwise(sorted(inventory, reverse=True) + [0]):
      if a > b:
        # If we are at the last inventory, or inventory[i] > inventory[i + 1].
        # In either case, we will pick inventory[i - largestCount + 1..i].
        pick = a - b
        # We have run out of orders, so we need to recalculate the number of
        # balls that we actually pick for inventory[i - largestCount + 1..i].
        if largestCount * pick >= orders:
          actualPick, remaining = divmod(orders, largestCount)
          return (ans +
                  largestCount * trapezoid(a, a - actualPick + 1) +
                  remaining * (a - actualPick)) % kMod
        ans += largestCount * trapezoid(a, a - pick + 1)
        ans %= kMod
        orders -= largestCount * pick
      largestCount += 1

```

## 2334. Subarray With Elements Greater Than Varying Threshold_2334.py
```python
class Solution:
  # Similar to 907. Sum of Subarray Minimums
  def validSubarraySize(self, nums: List[int], threshold: int) -> int:
    n = len(nums)
    ans = 0
    # prev[i] := the index k s.t. nums[k] is the previous minimum in nums[0..n)
    prev = [-1] * n
    # next[i] := the index k s.t. nums[k] is the next minimum in nums[i + 1..n)
    next = [n] * n
    stack = []

    for i, a in enumerate(nums):
      while stack and nums[stack[-1]] > a:
        index = stack.pop()
        next[index] = i
      if stack:
        prev[i] = stack[-1]
      stack.append(i)

    for i, (num, prevIndex, nextIndex) in enumerate(zip(nums, prev, next)):
      k = (i - prevIndex) + (nextIndex - i) - 1
      if num > threshold / k:
        return k

    return -1

```

## 1246. Palindrome Removal_1246.py
```python
class Solution:
  def minimumMoves(self, arr: List[int]) -> int:
    n = len(arr)
    # dp[i][j] := the minimum number of moves to remove all numbers from arr[i..j]
    dp = [[n] * n for _ in range(n)]

    for i in range(n):
      dp[i][i] = 1

    for i in range(n - 1):
      dp[i][i + 1] = 1 if arr[i] == arr[i + 1] else 2

    for d in range(2, n):
      for i in range(n - d):
        j = i + d
        # Remove arr[i] and arr[j] within the move of removing
        # arr[i + 1..j - 1]
        if arr[i] == arr[j]:
          dp[i][j] = dp[i + 1][j - 1]
        # Try all the possible partitions.
        for k in range(i, j):
          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])

    return dp[0][n - 1]

```

## 484. Find Permutation_484-2.py
```python
class Solution:
  def findPermutation(self, s: str) -> List[int]:
    ans = [i for i in range(1, len(s) + 2)]

    # For each D* group (s[i..j]), reverse ans[i..j + 1].
    i = -1
    j = -1

    def getNextIndex(c: str, start: int) -> int:
      for i in range(start, len(s)):
        if s[i] == c:
          return i
      return len(s)

    while True:
      i = getNextIndex('D', j + 1)
      if i == len(s):
        break
      j = getNextIndex('I', i + 1)
      ans[i:j + 1] = ans[i:j + 1][::-1]

    return ans

```

## 17. Letter Combinations of a Phone Number_17.py
```python
class Solution:
  def letterCombinations(self, digits: str) -> List[str]:
    if not digits:
      return []

    digitToLetters = ['', '', 'abc', 'def', 'ghi',
                      'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']
    ans = []

    def dfs(i: int, path: List[chr]) -> None:
      if i == len(digits):
        ans.append(''.join(path))
        return

      for letter in digitToLetters[ord(digits[i]) - ord('0')]:
        path.append(letter)
        dfs(i + 1, path)
        path.pop()

    dfs(0, [])
    return ans

```

## 2591. Distribute Money to Maximum Children_2591.py
```python
class Solution:
  def distMoney(self, money: int, children: int) -> int:
    # Everyone must receive at least 1 dollar.
    money -= children
    if money < 0:
      return -1

    count7 = money // 7
    remaining = money % 7

    # Distribute 8 dollars to every child.
    if count7 == children and remaining == 0:
      return count7

    # Need to move 1 dollar from the last child with 4 dollars to one of other
    # children. That's why we need to substract 1.
    if count7 == children - 1 and remaining == 3:
      return count7 - 1

    # Though there might be child with 4 dollars, since count7 < children - 1,
    # we have 'extra' spot to move money to if needed.
    return min(children - 1, count7)

```

## 1320. Minimum Distance to Type a Word Using Two Fingers_1320.py
```python
class Solution:
  def minimumDistance(self, word: str) -> int:
    def dist(a: int, b: int) -> int:
      if a == 26:  # the first hovering state
        return 0
      x1, y1 = a // 6, a % 6
      x2, y2 = b // 6, b % 6
      return abs(x1 - x2) + abs(y1 - y2)

    @functools.lru_cache(None)
    def dp(i: int, j: int, k: int) -> int:
      """
      Returns the minimum distance to type the `word`, where the left finger is
      on the i-th letter, the right finger is on the j-th letter, and the
      words[0..k) have been written.
      """
      if k == len(word):
        return 0
      nxt = ord(word[k]) - ord('A')
      moveLeft = dist(i, nxt) + dp(nxt, j, k + 1)
      moveRight = dist(j, nxt) + dp(i, nxt, k + 1)
      return min(moveLeft, moveRight)

    return dp(26, 26, 0)

```

## 720. Longest Word in Dictionary_720.py
```python
class Solution:
  def longestWord(self, words: List[str]) -> str:
    root = {}

    for word in words:
      node = root
      for c in word:
        if c not in node:
          node[c] = {}
        node = node[c]
      node['word'] = word

    def dfs(node: dict) -> str:
      ans = node['word'] if 'word' in node else ''

      for child in node:
        if 'word' in node[child] and len(node[child]['word']) > 0:
          childWord = dfs(node[child])
          if len(childWord) > len(ans) or (len(childWord) == len(ans) and childWord < ans):
            ans = childWord

      return ans

    return dfs(root)

```

## 1420. Build Array Where You Can Find The Maximum Exactly K Comparisons_1420.py
```python
class Solution:
  def numOfArrays(self, n: int, m: int, k: int) -> int:
    kMod = 1_000_000_007
    # dp[i][j][k] := the number of ways to build an array of length i, where j
    # is the maximum number and k is `search_cost`
    dp = [[[0] * (k + 1) for j in range(m + 1)] for _ in range(n + 1)]

    for j in range(1, m + 1):
      dp[1][j][1] = 1

    for i in range(2, n + 1):  # for each length
      for j in range(1, m + 1):  # for each max value
        for cost in range(1, k + 1):  # for each cost
          # 1. Appending any of [1, j] in the i-th position doesn't change the
          #    maximum and cost.
          dp[i][j][cost] = j * dp[i - 1][j][cost] % kMod
          # 2. Appending j in the i-th position makes j the new max and cost 1.
          for prevMax in range(1, j):
            dp[i][j][cost] += dp[i - 1][prevMax][cost - 1]
            dp[i][j][cost] %= kMod

    return sum(dp[n][j][k] for j in range(1, m + 1)) % kMod

```

## 1462. Course Schedule IV_1462.py
```python
class Solution:
  def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
    graph = [[] for _ in range(numCourses)]
    # isPrerequisite[i][j] := True if course i is a prerequisite of course j.
    isPrerequisite = [[False] * numCourses for _ in range(numCourses)]

    for u, v in prerequisites:
      graph[u].append(v)

    # DFS from every course.
    for i in range(numCourses):
      self._dfs(graph, i, isPrerequisite[i])

    return [isPrerequisite[u][v] for u, v in queries]

  def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:
    for v in graph[u]:
      if used[v]:
        continue
      used[v] = True
      self._dfs(graph, v, used)

```

## 210. Course Schedule II_210-2.py
```python
class Solution:
  def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
    ans = []
    graph = [[] for _ in range(numCourses)]
    inDegrees = [0] * numCourses
    q = collections.deque()

    # Build the graph.
    for v, u in prerequisites:
      graph[u].append(v)
      inDegrees[v] += 1

    # Perform topological sorting.
    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])

    while q:
      u = q.popleft()
      ans.append(u)
      for v in graph[u]:
        inDegrees[v] -= 1
        if inDegrees[v] == 0:
          q.append(v)

    return ans if len(ans) == numCourses else []

```

## 426. Convert Binary Search Tree to Sorted Doubly Linked List_426-2.py
```python
class Solution:
  def treeToDoublyList(self, root: 'Optional[Node]') -> 'Optional[Node]':
    if not root:
      return None

    stack = []
    first = None
    pred = None

    while root or stack:
      while root:
        stack.append(root)
        root = root.left
      root = stack.pop()
      if not first:
        first = root
      if pred:
        pred.right = root
        root.left = pred
      pred = root
      root = root.right

    pred.right = first
    first.left = pred
    return first

```

## 655. Print Binary Tree_655.py
```python
class Solution:
  def printTree(self, root: Optional[TreeNode]) -> List[List[str]]:
    def maxHeight(root: Optional[TreeNode]) -> int:
      if not root:
        return 0
      return 1 + max(maxHeight(root.left), maxHeight(root.right))

    def dfs(root: Optional[TreeNode], row: int, left: int, right: int) -> None:
      if not root:
        return

      mid = (left + right) // 2
      ans[row][mid] = str(root.val)
      dfs(root.left, row + 1, left, mid - 1)
      dfs(root.right, row + 1, mid + 1, right)

    m = maxHeight(root)
    n = pow(2, m) - 1
    ans = [[''] * n for _ in range(m)]
    dfs(root, 0, 0, len(ans[0]) - 1)
    return ans

```

## 1216. Valid Palindrome III_1216.py
```python
class Solution:
  def isValidPalindrome(self, s: str, k: int) -> bool:
    return len(s) - self._longestPalindromeSubseq(s) <= k

  # Same as 516. Longest Palindromic Subsequence
  def _longestPalindromeSubseq(self, s: str) -> int:
    n = len(s)
    # dp[i][j] := the length of LPS(s[i..j])
    dp = [[0] * n for _ in range(n)]

    for i in range(n):
      dp[i][i] = 1

    for d in range(1, n):
      for i in range(n - d):
        j = i + d
        if s[i] == s[j]:
          dp[i][j] = 2 + dp[i + 1][j - 1]
        else:
          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])

    return dp[0][n - 1]

```

## 72. Edit Distance_72.py
```python
class Solution:
  def minDistance(self, word1: str, word2: str) -> int:
    m = len(word1)
    n = len(word2)
    # dp[i][j] := the minimum number of operations to convert word1[0..i) to
    # word2[0..j)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
      dp[i][0] = i

    for j in range(1, n + 1):
      dp[0][j] = j

    for i in range(1, m + 1):
      for j in range(1, n + 1):
        if word1[i - 1] == word2[j - 1]:
          dp[i][j] = dp[i - 1][j - 1]
        else:
          dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1

    return dp[m][n]

```

## 2043. Simple Bank System_2043.py
```python
class Bank:
  def __init__(self, balance: List[int]):
    self.balance = balance

  def transfer(self, account1: int, account2: int, money: int) -> bool:
    if not self._isValid(account2):
      return False
    return self.withdraw(account1, money) and self.deposit(account2, money)

  def deposit(self, account: int, money: int) -> bool:
    if not self._isValid(account):
      return False
    self.balance[account - 1] += money
    return True

  def withdraw(self, account: int, money: int) -> bool:
    if not self._isValid(account):
      return False
    if self.balance[account - 1] < money:
      return False
    self.balance[account - 1] -= money
    return True

  def _isValid(self, account: int) -> bool:
    return 1 <= account <= len(self.balance)

```

## 277. Find the Celebrity_277.py
```python
# The knows API is already defined for you.
# Returns a bool, whether a knows b
# Def knows(a: int, b: int) -> bool:


class Solution:
  def findCelebrity(self, n: int) -> int:
    candidate = 0

    # Everyone knows the celebrity.
    for i in range(1, n):
      if knows(candidate, i):
        candidate = i

    # The candidate knows nobody and everyone knows the celebrity.
    for i in range(n):
      if i < candidate and knows(candidate, i) or not knows(i, candidate):
        return -1
      if i > candidate and not knows(i, candidate):
        return -1

    return candidate

```

## 1525. Number of Good Ways to Split a String_1525.py
```python
class Solution:
  def numSplits(self, s: str) -> int:
    n = len(s)
    ans = 0
    seen = set()
    prefix = [0] * n
    suffix = [0] * n

    for i in range(n):
      seen.add(s[i])
      prefix[i] = len(seen)

    seen.clear()

    for i in reversed(range(n)):
      seen.add(s[i])
      suffix[i] = len(seen)

    for i in range(n - 1):
      if prefix[i] == suffix[i + 1]:
        ans += 1

    return ans

```

## 1616. Split Two Strings to Make Palindrome_1616.py
```python
class Solution:
  def checkPalindromeFormation(self, a: str, b: str) -> bool:
    return self._check(a, b) or self._check(b, a)

  def _check(self, a: str, b: str) -> bool:
    i, j = 0, len(a) - 1
    while i < j:
      if a[i] != b[j]:
        # a[0:i] + a[i..j] + b[j + 1:] or
        # a[0:i] + b[i..j] + b[j + 1:]
        return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)
      i += 1
      j -= 1
    return True

  def _isPalindrome(self, s: str, i: int, j: int) -> bool:
    while i < j:
      if s[i] != s[j]:
        return False
      i += 1
      j -= 1
    return True

```

## 47. Permutations II_47.py
```python
class Solution:
  def permuteUnique(self, nums: List[int]) -> List[List[int]]:
    ans = []
    used = [False] * len(nums)

    def dfs(path: List[int]) -> None:
      if len(path) == len(nums):
        ans.append(path.copy())
        return

      for i, num in enumerate(nums):
        if used[i]:
          continue
        if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:
          continue
        used[i] = True
        path.append(num)
        dfs(path)
        path.pop()
        used[i] = False

    nums.sort()
    dfs([])
    return ans

```

## 3020. Find the Maximum Number of Elements in Subset_3020.py
```python
class Solution:
  def maximumLength(self, nums: List[int]) -> int:
    maxNum = max(nums)
    count = collections.Counter(nums)
    ans = count[1] - (count[1] % 2 == 0) if 1 in count else 1

    for num in nums:
      if num == 1:
        continue
      length = 0
      x = num
      while x <= maxNum and x in count and count[x] >= 2:
        length += 2
        x *= x
      # x is now x^k, and the pattern is [x, ..., x^(k/2), x^(k/2), ..., x].
      # The goal is to determine if we can insert x^k in the middle of the
      # pattern to increase the length by 1. If not, we make x^(k/2) the middle
      # and decrease the length by 1.
      ans = max(ans, length + (1 if x in count else -1))

    return ans

```

## 1562. Find Latest Group of Size M_1562.py
```python
class Solution:
  def findLatestStep(self, arr: List[int], m: int) -> int:
    if len(arr) == m:
      return len(arr)

    ans = -1
    step = 0
    # sizes[i] := the size of the group starting from i or ending in i
    # (1-indexed)
    sizes = [0] * (len(arr) + 2)

    for i in arr:
      step += 1
      # In the previous step, there exists a group with a size of m.
      if sizes[i - 1] == m or sizes[i + 1] == m:
        ans = step - 1
      head = i - sizes[i - 1]
      tail = i + sizes[i + 1]
      sizes[head] = tail - head + 1
      sizes[tail] = tail - head + 1

    return ans

```

## 1583. Count Unhappy Friends_1583.py
```python
class Solution:
  def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:
    ans = 0
    matches = [0] * n
    prefer = [{} for _ in range(n)]

    for x, y in pairs:
      matches[x] = y
      matches[y] = x

    for i in range(n):
      for j in range(n - 1):
        prefer[i][preferences[i][j]] = j

    for x in range(n):
      for u in prefer[x].keys():
        y = matches[x]
        v = matches[u]
        if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:
          ans += 1
          break

    return ans

```

## 1120. Maximum Average Subtree_1120.py
```python
class T:
  def __init__(self, summ: int, count: int, maxAverage: float):
    self.summ = summ
    self.count = count
    self.maxAverage = maxAverage


class Solution:
  def maximumAverageSubtree(self, root: Optional[TreeNode]) -> float:
    def maximumAverage(root: Optional[TreeNode]) -> T:
      if not root:
        return T(0, 0, 0)

      left = maximumAverage(root.left)
      right = maximumAverage(root.right)

      summ = root.val + left.summ + right.summ
      count = 1 + left.count + right.count
      maxAverage = max(summ / count, left.maxAverage, right.maxAverage)
      return T(summ, count, maxAverage)

    return maximumAverage(root).maxAverage

```

## 681. Next Closest Time_681.py
```python
class Solution:
  def nextClosestTime(self, time: str) -> str:
    ans = list(time)
    digits = sorted(ans)

    def nextClosest(digit: str, limit: str) -> chr:
      next = bisect_right(digits, digit)
      return digits[0] if next == 4 or digits[next] > limit else digits[next]

    ans[4] = nextClosest(ans[4], '9')
    if time[4] < ans[4]:
      return ''.join(ans)

    ans[3] = nextClosest(ans[3], '5')
    if time[3] < ans[3]:
      return ''.join(ans)

    ans[1] = nextClosest(ans[1], '3' if ans[0] == '2' else '9')
    if time[1] < ans[1]:
      return ''.join(ans)

    ans[0] = nextClosest(ans[0], '2')
    return ''.join(ans)

```

## 289. Game of Life_289.py
```python
class Solution:
  def gameOfLife(self, board: List[List[int]]) -> None:
    m = len(board)
    n = len(board[0])

    for i in range(m):
      for j in range(n):
        ones = 0
        for x in range(max(0, i - 1), min(m, i + 2)):
          for y in range(max(0, j - 1), min(n, j + 2)):
            ones += board[x][y] & 1
        # Any live cell with two or three live neighbors lives on to the next
        # generation.
        if board[i][j] == 1 and (ones == 3 or ones == 4):
          board[i][j] |= 0b10
        # Any dead cell with exactly three live neighbors becomes a live cell,
        # as if by reproduction.
        if board[i][j] == 0 and ones == 3:
          board[i][j] |= 0b10

    for i in range(m):
      for j in range(n):
        board[i][j] >>= 1

```

## 1314. Matrix Block Sum_1314.py
```python
class Solution:
  def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:
    m = len(mat)
    n = len(mat[0])
    ans = [[0] * n for _ in range(m)]
    prefix = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m):
      for j in range(n):
        prefix[i + 1][j + 1] = mat[i][j] + \
            prefix[i][j + 1] + prefix[i + 1][j] - prefix[i][j]

    for i in range(m):
      for j in range(n):
        r1 = max(0, i - k) + 1
        c1 = max(0, j - k) + 1
        r2 = min(m - 1, i + k) + 1
        c2 = min(n - 1, j + k) + 1
        ans[i][j] = prefix[r2][c2] - prefix[r2][c1 - 1] - \
            prefix[r1 - 1][c2] + prefix[r1 - 1][c1 - 1]

    return ans

```

## 2353. Design a Food Rating System_2353.py
```python
from sortedcontainers import SortedSet


class FoodRatings:
  def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):
    self.cuisineToRatingAndFoods = collections.defaultdict(
        lambda: SortedSet(key=lambda x: (-x[0], x[1])))
    self.foodToCuisine = {}
    self.foodToRating = {}

    for food, cuisine, rating in zip(foods, cuisines, ratings):
      self.cuisineToRatingAndFoods[cuisine].add((rating, food))
      self.foodToCuisine[food] = cuisine
      self.foodToRating[food] = rating

  def changeRating(self, food: str, newRating: int) -> None:
    cuisine = self.foodToCuisine[food]
    oldRating = self.foodToRating[food]
    ratingAndFoods = self.cuisineToRatingAndFoods[cuisine]
    ratingAndFoods.remove((oldRating, food))
    ratingAndFoods.add((newRating, food))
    self.foodToRating[food] = newRating

  def highestRated(self, cuisine: str) -> str:
    return self.cuisineToRatingAndFoods[cuisine][0][1]

```

## 1575. Count All Possible Routes_1575-2.py
```python
class Solution:
  def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:
    kMod = 1_000_000_007
    n = len(locations)
    # dp[i][j] := the number of ways to reach the `finish` city from the i-th
    # city with `j` fuel
    dp = [[0] * (fuel + 1) for _ in range(n)]

    for f in range(fuel + 1):
      dp[finish][f] = 1

    for f in range(fuel + 1):
      for i in range(n):
        for j in range(n):
          if i == j:
            continue
          requiredFuel = abs(locations[i] - locations[j])
          if requiredFuel <= f:
            dp[i][f] += dp[j][f - requiredFuel]
            dp[i][f] %= kMod

    return dp[start][fuel]

```

## 843. Guess the Word_843.py
```python
# """
# This is Master's API interface.
# You should not implement it, or speculate about its implementation
# """
# Class Master:
#   def guess(self, word: str) -> int:

class Solution:
  def findSecretWord(self, wordlist: List[str], master: 'Master') -> None:
    def getMatches(s1: str, s2: str) -> int:
      matches = 0
      for c1, c2 in zip(s1, s2):
        if c1 == c2:
          matches += 1
      return matches

    for _ in range(10):
      guessedWord = wordlist[random.randint(0, len(wordlist) - 1)]
      matches = master.guess(guessedWord)
      if matches == 6:
        break
      wordlist = [
          word for word in wordlist
          if getMatches(guessedWord, word) == matches]

```

## 323. Number of Connected Components in an Undirected Graph_323-2.py
```python
class Solution:
  def countComponents(self, n: int, edges: List[List[int]]) -> int:
    ans = 0
    graph = [[] for _ in range(n)]
    seen = set()

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    def dfs(u: int, seen: Set[int]) -> None:
      for v in graph[u]:
        if v not in seen:
          seen.add(v)
          dfs(v, seen)

    for i in range(n):
      if i not in seen:
        seen.add(i)
        dfs(graph, i, seen)
        ans += 1

    return ans

```

## 1826. Faulty Sensor_1826.py
```python
class Solution:
  def badSensor(self, sensor1: List[int], sensor2: List[int]) -> int:
    # A -> B, so B is defect
    def canReplace(A, B):
      i = 0  # A's index
      j = 0  # B's index
      droppedValue = -1

      while i < len(A):
        if A[i] == B[j]:
          i += 1
          j += 1
        else:
          droppedValue = A[i]
          i += 1

      return j == len(B) - 1 and B[-1] != droppedValue

    oneDefect = canReplace(sensor2, sensor1)
    twoDefect = canReplace(sensor1, sensor2)
    if oneDefect and twoDefect:
      return -1
    if not oneDefect and not twoDefect:
      return -1
    return 1 if oneDefect else 2

```

## 1882. Process Tasks Using Servers_1882.py
```python
class Solution:
  def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:
    ans = []
    free = []  # (weight, index, freeTime)
    used = []  # (freeTime, weight, index)

    for i, weight in enumerate(servers):
      heapq.heappush(free, (weight, i, 0))

    for i, executionTime in enumerate(tasks):  # i := the current time
      # Poll all servers that'll be free at time i.
      while used and used[0][0] <= i:
        curr = heapq.heappop(used)
        heapq.heappush(free, (curr[1], curr[2], curr[0]))
      if free:
        curr = heapq.heappop(free)
        ans.append(curr[1])
        heapq.heappush(used, (i + executionTime, curr[0], curr[1]))
      else:
        curr = heapq.heappop(used)
        ans.append(curr[2])
        heapq.heappush(used, (curr[0] + executionTime, curr[1], curr[2]))

    return ans

```

## 1382. Balance a Binary Search Tree_1382.py
```python
class Solution:
  def balanceBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
    nums = []

    def inorder(root: Optional[TreeNode]) -> None:
      if not root:
        return
      inorder(root.left)
      nums.append(root.val)
      inorder(root.right)

    inorder(root)

    # Same as 108. Convert Sorted Array to Binary Search Tree
    def build(l: int, r: int) -> Optional[TreeNode]:
      if l > r:
        return None
      m = (l + r) // 2
      return TreeNode(nums[m],
                      build(l, m - 1),
                      build(m + 1, r))

    return build(0, len(nums) - 1)

```

## 1136. Parallel Courses_1136-2.py
```python
class Solution:
  def minimumSemesters(self, n: int, relations: List[List[int]]) -> int:
    ans = 0
    graph = [[] for _ in range(n)]
    inDegrees = [0] * n

    # Build the graph.
    for u, v in relations:
      graph[u - 1].append(v - 1)
      inDegrees[v - 1] += 1

    # Perform topological sorting.
    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])

    while q:
      for _ in range(len(q)):
        u = q.popleft()
        n -= 1
        for v in graph[u]:
          inDegrees[v] -= 1
          if inDegrees[v] == 0:
            q.append(v)
      ans += 1

    return ans if n == 0 else -1

```

## 2955. Number of Same-End Substrings_2955.py
```python
class Solution:
  def sameEndSubstringCount(self, s: str, queries: List[List[int]]) -> List[int]:
    count = collections.Counter()
    # counts[i] := the count of s[0..i)
    counts = [count.copy()]

    for c in s:
      count[c] += 1
      counts.append(count.copy())

    ans = []

    for l, r in queries:
      sameEndCount = 0
      for c in string.ascii_lowercase:
        #   the count of s[0..r] - the count of s[0..l - 1]
        # = the count of s[l..r]
        freq = counts[r + 1][c] - counts[l][c]
        #   C(freq, 2) + freq
        # = freq * (freq - 1) / 2 + freq
        # = freq * (freq + 1) / 2
        sameEndCount += freq * (freq + 1) // 2
      ans.append(sameEndCount)

    return ans

```

## 604. Design Compressed String Iterator_604-2.py
```python
class StringIterator:
  def __init__(self, compressedString: str):
    self.q = collections.deque()  # (currentChar, num)

    i = 0  # compressedString's index
    while i < len(compressedString):
      c = compressedString[i]
      i += 1
      num = 0
      while i < len(compressedString) and compressedString[i].isdigit():
        num = num * 10 + (ord(compressedString[i]) - ord('0'))
        i += 1
      self.q.append((c, num))

  def next(self) -> str:
    if not self.hasNext():
      return ' '

    c, num = self.q.popleft()
    if num > 1:
      self.q.appendleft((c, num - 1))
    return c

  def hasNext(self) -> bool:
    return self.q

```

## 2670. Find the Distinct Difference Array_2670.py
```python
class Solution:
  def distinctDifferenceArray(self, nums: List[int]) -> List[int]:
    kMax = 50
    ans = []
    prefixCount = [0] * (kMax + 1)
    suffixCount = [0] * (kMax + 1)
    distinctPrefix = 0
    distinctSuffix = 0

    for num in nums:
      if suffixCount[num] == 0:
        distinctSuffix += 1
      suffixCount[num] += 1

    for num in nums:
      if prefixCount[num] == 0:
        distinctPrefix += 1
      prefixCount[num] += 1
      if suffixCount[num] == 1:
        distinctSuffix -= 1
      suffixCount[num] -= 1
      ans.append(distinctPrefix - distinctSuffix)

    return ans

```

## 368. Largest Divisible Subset_368.py
```python
class Solution:
  def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
    n = len(nums)
    ans = []
    count = [1] * n
    prevIndex = [-1] * n
    maxCount = 0
    index = -1

    nums.sort()

    for i, num in enumerate(nums):
      for j in reversed(range(i)):
        if num % nums[j] == 0 and count[i] < count[j] + 1:
          count[i] = count[j] + 1
          prevIndex[i] = j
      if count[i] > maxCount:
        maxCount = count[i]
        index = i

    while index != -1:
      ans.append(nums[index])
      index = prevIndex[index]

    return ans

```

## 2461. Maximum Sum of Distinct Subarrays With Length K_2461.py
```python
class Solution:
  def maximumSubarraySum(self, nums: List[int], k: int) -> int:
    ans = 0
    summ = 0
    distinct = 0
    count = collections.Counter()

    for i, num in enumerate(nums):
      summ += num
      count[num] += 1
      if count[num] == 1:
        distinct += 1
      if i >= k:
        count[nums[i - k]] -= 1
        if count[nums[i - k]] == 0:
          distinct -= 1
        summ -= nums[i - k]
      if i >= k - 1 and distinct == k:
        ans = max(ans, summ)

    return ans

```

## 450. Delete Node in a BST_450.py
```python
class Solution:
  def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
    if not root:
      return None
    if root.val == key:
      if not root.left:
        return root.right
      if not root.right:
        return root.left
      minNode = self._getMin(root.right)
      root.right = self.deleteNode(root.right, minNode.val)
      minNode.left = root.left
      minNode.right = root.right
      root = minNode
    elif root.val < key:
      root.right = self.deleteNode(root.right, key)
    else:  # root.val > key
      root.left = self.deleteNode(root.left, key)
    return root

  def _getMin(self, node: Optional[TreeNode]) -> Optional[TreeNode]:
    while node.left:
      node = node.left
    return node

```

## 296. Best Meeting Point_296.py
```python
class Solution:
  def minTotalDistance(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    # i indices s.t. grid[i][j] == 1
    I = [i for i in range(m) for j in range(n) if grid[i][j]]
    # j indices s.t. grid[i][j] == 1
    J = [j for j in range(n) for i in range(m) if grid[i][j]]

    def minTotalDistance(grid: List[int]) -> int:
      summ = 0
      i = 0
      j = len(grid) - 1
      while i < j:
        summ += grid[j] - grid[i]
        i += 1
        j -= 1
      return summ

    # sum(i - median(I)) + sum(j - median(J))
    return minTotalDistance(I) + minTotalDistance(J)

```

## 973. K Closest Points to Origin_973-2.py
```python
class Solution:
  def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
    def squareDist(p: List[int]) -> int:
      return p[0] * p[0] + p[1] * p[1]

    def quickSelect(l: int, r: int, k: int) -> None:
      pivot = points[r]

      nextSwapped = l
      for i in range(l, r):
        if squareDist(points[i]) <= squareDist(pivot):
          points[nextSwapped], points[i] = points[i], points[nextSwapped]
          nextSwapped += 1
      points[nextSwapped], points[r] = points[r], points[nextSwapped]

      count = nextSwapped - l + 1  the number of points <= pivot
      if count == k:
        return
      if count > k:
        quickSelect(l, nextSwapped - 1, k)
      else:
        quickSelect(nextSwapped + 1, r, k - count)

    quickSelect(0, len(points) - 1, k)
    return points[0:k]

```

## 127. Word Ladder_127.py
```python
class Solution:
  def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
    wordSet = set(wordList)
    if endWord not in wordSet:
      return 0

    ans = 0
    q = collections.deque([beginWord])

    while q:
      ans += 1
      for _ in range(len(q)):
        wordList = list(q.popleft())
        for i, cache in enumerate(wordList):
          for c in string.ascii_lowercase:
            wordList[i] = c
            word = ''.join(wordList)
            if word == endWord:
              return ans + 1
            if word in wordSet:
              q.append(word)
              wordSet.remove(word)
          wordList[i] = cache

    return 0

```

## 2947. Count Beautiful Substrings I_2947.py
```python
class Solution:
  def beautifulSubstrings(self, s: str, k: int) -> int:
    kVowels = 'aeiou'
    root = self._getRoot(k)
    ans = 0
    vowels = 0
    vowelsMinusConsonants = 0
    # {(vowels, vowelsMinusConsonants): count}
    prefixCount = collections.Counter({(0, 0): 1})

    for c in s:
      if c in kVowels:
        vowelsMinusConsonants += 1
        vowels = (vowels + 1) % root
      else:
        vowelsMinusConsonants -= 1
      ans += prefixCount[(vowels, vowelsMinusConsonants)]
      prefixCount[(vowels, vowelsMinusConsonants)] += 1

    return ans

  def _getRoot(self, k: int) -> int:
    for i in range(1, k + 1):
      if i * i % k == 0:
        return i

```

## 1058. Minimize Rounding Error to Meet Target_1058.py
```python
class Solution:
  def minimizeError(self, prices: List[str], target: int) -> str:
    # A[i] := (costCeil - costFloor, costCeil, costFloor)
    # The lower the costCeil - costFloor is, the cheaper to ceil it.
    A = []
    sumFloored = 0
    sumCeiled = 0

    for price in map(float, prices):
      floored = math.floor(price)
      ceiled = math.ceil(price)
      sumFloored += floored
      sumCeiled += ceiled
      costFloor = price - floored
      costCeil = ceiled - price
      A.append((costCeil - costFloor, costCeil, costFloor))

    if not sumFloored <= target <= sumCeiled:
      return '-1'

    A.sort()
    nCeiled = target - sumFloored
    return '{:.3f}'.format(sum(a[1] for a in A[:nCeiled]) +
                           sum(a[2] for a in A[nCeiled:]))

```

## 2508. Add Edges to Make Degrees of All Nodes Even_2508.py
```python
class Solution:
  def isPossible(self, n: int, edges: List[List[int]]) -> bool:
    graph = [set() for _ in range(n)]

    for u, v in edges:
      graph[u - 1].add(v - 1)
      graph[v - 1].add(u - 1)

    oddNodes = [i for i, neighbor in enumerate(
        graph) if len(neighbor) % 2 == 1]
    if not oddNodes:
      return True
    if len(oddNodes) == 2:
      a, b = oddNodes
      return any(a not in graph[i] and b not in graph[i] for i in range(n))
    if len(oddNodes) == 4:
      a, b, c, d = oddNodes
      return (b not in graph[a] and d not in graph[c]) or \
          (c not in graph[a] and d not in graph[b]) or \
          (d not in graph[a] and c not in graph[b])
    return False

```

## 244. Shortest Word Distance II_244.py
```python
class WordDistance:
  def __init__(self, wordsDict: List[str]):
    self.wordToIndices = collections.defaultdict(list)
    for i, word in enumerate(wordsDict):
      self.wordToIndices[word].append(i)

  def shortest(self, word1: str, word2: str) -> int:
    indices1 = self.wordToIndices[word1]
    indices2 = self.wordToIndices[word2]
    ans = math.inf

    i = 0
    j = 0
    while i < len(indices1) and j < len(indices2):
      ans = min(ans, abs(indices1[i] - indices2[j]))
      if indices1[i] < indices2[j]:
        i += 1
      else:
        j += 1

    return ans

```

## 1943. Describe the Painting_1943.py
```python
from sortedcontainers import SortedDict


class Solution:
  def splitPainting(self, segments: List[List[int]]) -> List[List[int]]:
    ans = []
    prevIndex = 0
    runningMix = 0
    timeline = SortedDict()

    for start, end, color in segments:
      timeline[start] = timeline.get(start, 0) + color
      timeline[end] = timeline.get(end, 0) - color

    for i, mix in timeline.items():
      if runningMix > 0:
        ans.append([prevIndex, i, runningMix])
      runningMix += mix
      prevIndex = i

    return ans

```

## 3082. Find the Sum of the Power of All Subsequences_3082-2.py
```python
class Solution:
  def sumOfPower(self, nums: List[int], k: int) -> int:
    kMod = 1_000_000_007
    n = len(nums)
    # dp[i][j] := the number of subsequences in nums[0..i) that sums to k
    dp = [[0] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 1

    for i in range(1, n + 1):
      num = nums[i - 1]
      for j in range(k + 1):
        if j < num:
          # 1. Exclude nums[i] in the subsequence.
          # 2. Include nums[i] in the subsequence and skip it.
          dp[i][j] = (dp[i - 1][j] * 2) % kMod
        else:
          # 1. Exclude nums[i] in the subsequence.
          # 2. Include nums[i] in the subsequence and skip it.
          # 3. Include nums[i] in the subsequence and pick it.
          dp[i][j] = (dp[i - 1][j] * 2 + dp[i - 1][j - num]) % kMod

    return dp[n][k]

```

## 2195. Append K Integers With Minimal Sum_2195.py
```python
class Solution:
  def minimalKSum(self, nums: List[int], k: int) -> int:
    ans = 0
    nums.append(0)
    nums.sort()

    for a, b in zip(nums, nums[1:]):
      if a == b:
        continue
      l = a + 1
      r = min(a + k, b - 1)
      ans += (l + r) * (r - l + 1) // 2
      k -= r - l + 1
      if k == 0:
        return ans

    if k > 0:
      l = nums[-1] + 1
      r = nums[-1] + k
      ans += (l + r) * (r - l + 1) // 2

    return ans

```

## 3011. Find if Array Can Be Sorted_3011.py
```python
class Solution:
  def canSortArray(self, nums: List[int]) -> int:
    # Divide the array into distinct segments where each segment is comprised
    # of consecutive elements sharing an equal number of set bits. Ensure that
    # for each segment, when moving from left to right, the maximum of a
    # preceding segment is less than the minimum of the following segment.
    prevSetBits = 0
    prevMax = -math.inf  # the maximum of the previous segment
    currMax = -math.inf  # the maximum of the current segment
    currMin = math.inf   # the minimum of the current segment

    for num in nums:
      setBits = num.bit_count()
      if setBits != prevSetBits:  # Start a new segment.
        if prevMax > currMin:
          return False
        prevSetBits = setBits
        prevMax = currMax
        currMax = num
        currMin = num
      else:  # Continue with the current segment.
        currMax = max(currMax, num)
        currMin = min(currMin, num)

    return prevMax <= currMin

```

## 1942. The Number of the Smallest Unoccupied Chair_1942.py
```python
class Solution:
  def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:
    nextUnsatChair = 0
    emptyChairs = []
    occupied = []  # (leaving, chair)

    for i in range(len(times)):
      times[i].append(i)

    times.sort(key=lambda time: time[0])

    for arrival, leaving, i in times:
      while len(occupied) > 0 and occupied[0][0] <= arrival:
        unsatChair = heapq.heappop(occupied)[1]
        heapq.heappush(emptyChairs, unsatChair)
      if i == targetFriend:
        return emptyChairs[0] if len(emptyChairs) > 0 else nextUnsatChair
      if len(emptyChairs) == 0:
        heapq.heappush(occupied, (leaving, nextUnsatChair))
        nextUnsatChair += 1
      else:
        emptyChair = heapq.heappop(emptyChairs)
        heapq.heappush(occupied, (leaving, emptyChair))

```

## 767. Reorganize String_767.py
```python
class Solution:
  def reorganizeString(self, s: str) -> str:
    count = collections.Counter(s)
    if max(count.values()) > (len(s) + 1) // 2:
      return ''

    ans = []
    maxHeap = [(-freq, c) for c, freq in count.items()]
    heapq.heapify(maxHeap)
    prevFreq = 0
    prevChar = '@'

    while maxHeap:
      # Get the letter with the maximum frequency.
      freq, c = heapq.heappop(maxHeap)
      ans.append(c)
      # Add the previous letter back s.t. any two adjacent characters are not
      # the same.
      if prevFreq < 0:
        heapq.heappush(maxHeap, (prevFreq, prevChar))
      prevFreq = freq + 1
      prevChar = c

    return ''.join(ans)

```

## 79. Word Search_79.py
```python
class Solution:
  def exist(self, board: List[List[str]], word: str) -> bool:
    m = len(board)
    n = len(board[0])

    def dfs(i: int, j: int, s: int) -> bool:
      if i < 0 or i == m or j < 0 or j == n:
        return False
      if board[i][j] != word[s] or board[i][j] == '*':
        return False
      if s == len(word) - 1:
        return True

      cache = board[i][j]
      board[i][j] = '*'
      isExist = \
          dfs(i + 1, j, s + 1) or \
          dfs(i - 1, j, s + 1) or \
          dfs(i, j + 1, s + 1) or \
          dfs(i, j - 1, s + 1)
      board[i][j] = cache

      return isExist

    return any(dfs(i, j, 0) for i in range(m) for j in range(n))

```

## 99. Recover Binary Search Tree_99-2.py
```python
class Solution:
  def recoverTree(self, root: Optional[TreeNode]) -> None:
    pred = None
    x = None  # the first wrong node
    y = None  # the second wrong node
    stack = []

    while root or stack:
      while root:
        stack.append(root)
        root = root.left
      root = stack.pop()
      if pred and root.val < pred.val:
        y = root
        if not x:
          x = pred
      pred = root
      root = root.right

    def swap(x: Optional[TreeNode], y: Optional[TreeNode]) -> None:
      temp = x.val
      x.val = y.val
      y.val = temp

    swap(x, y)

```

## 907. Sum of Subarray Minimums_907.py
```python
class Solution:
  def sumSubarrayMins(self, arr: List[int]) -> int:
    kMod = 1_000_000_007
    n = len(arr)
    ans = 0
    # prevMin[i] := index k s.t. arr[k] is the previous minimum in arr[:i]
    prevMin = [-1] * n
    # nextMin[i] := index k s.t. arr[k] is the next minimum in arr[i + 1:]
    nextMin = [n] * n
    stack = []

    for i, a in enumerate(arr):
      while stack and arr[stack[-1]] > a:
        index = stack.pop()
        nextMin[index] = i
      if stack:
        prevMin[i] = stack[-1]
      stack.append(i)

    for i, a in enumerate(arr):
      ans += a * (i - prevMin[i]) * (nextMin[i] - i)
      ans %= kMod

    return ans

```

## 1087. Brace Expansion_1087.py
```python
class Solution:
  def expand(self, s: str) -> List[str]:
    ans = []

    def dfs(i: int, path: List[str]) -> None:
      if i == len(s):
        ans.append(''.join(path))
        return
      if s[i] == '{':
        nextRightBraceIndex = s.find('}', i)
        for c in s[i + 1:nextRightBraceIndex].split(','):
          path.append(c)
          dfs(nextRightBraceIndex + 1, path)
          path.pop()
      else:  # s[i] != '{'
        path.append(s[i])
        dfs(i + 1, path)
        path.pop()

    dfs(0, [])
    return sorted(ans)

```

## 845. Longest Mountain in Array_845.py
```python
class Solution:
  def longestMountain(self, arr: List[int]) -> int:
    ans = 0
    i = 0

    while i + 1 < len(arr):
      while i + 1 < len(arr) and arr[i] == arr[i + 1]:
        i += 1

      increasing = 0
      decreasing = 0

      while i + 1 < len(arr) and arr[i] < arr[i + 1]:
        increasing += 1
        i += 1

      while i + 1 < len(arr) and arr[i] > arr[i + 1]:
        decreasing += 1
        i += 1

      if increasing > 0 and decreasing > 0:
        ans = max(ans, increasing + decreasing + 1)

    return ans

```

## 2653. Sliding Subarray Beauty_2653.py
```python
class Solution:
  def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:
    ans = []
    count = [0] * 50  # count[i] := the frequency of (i + 50)

    for i, num in enumerate(nums):
      if num < 0:
        count[num + 50] += 1
      if i - k >= 0 and nums[i - k] < 0:
        count[nums[i - k] + 50] -= 1
      if i + 1 >= k:
        ans.append(self._getXthSmallestNum(count, x))

    return ans

  def _getXthSmallestNum(self, count: List[int], x: int) -> int:
    prefix = 0
    for i in range(50):
      prefix += count[i]
      if prefix >= x:
        return i - 50
    return 0

```

## 2359. Find Closest Node to Given Two Nodes_2359.py
```python
class Solution:
  def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:
    kMax = 10000
    dist1 = self._getDist(edges, node1)
    dist2 = self._getDist(edges, node2)
    minDist = kMax
    ans = -1

    for i, (d1, d2) in enumerate(zip(dist1, dist2)):
      if min(d1, d2) >= 0:
        maxDist = max(d1, d2)
        if maxDist < minDist:
          minDist = maxDist
          ans = i

    return ans

  def _getDist(self, edges: List[int], u: int) -> List[int]:
    dist = [-1] * len(edges)
    d = 0
    while u != -1 and dist[u] == -1:
      dist[u] = d
      d += 1
      u = edges[u]
    return dist

```

## 1311. Get Watched Videos by Your Friends_1311.py
```python
class Solution:
  def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]],
                             id: int, level: int) -> List[str]:
    visited = [False] * 100
    visited[id] = True
    q = collections.deque([id])
    count = collections.Counter()

    for _ in range(level):
      for _ in range(len(q)):
        curr = q.popleft()
        for friend in friends[curr]:
          if not visited[friend]:
            visited[friend] = True
            q.append(friend)

    for friend in q:
      for video in watchedVideos[friend]:
        count[video] += 1

    return sorted(count.keys(), key=lambda video: (count[video], video))

```

## 802. Find Eventual Safe States_802.py
```python
from enum import Enum


class State(Enum):
  kInit = 0
  kVisiting = 1
  kVisited = 2


class Solution:
  def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
    states = [State.kInit] * len(graph)

    def hasCycle(u: int) -> bool:
      if states[u] == State.kVisiting:
        return True
      if states[u] == State.kVisited:
        return False

      states[u] = State.kVisiting
      if any(hasCycle(v) for v in graph[u]):
        return True
      states[u] = State.kVisited

    return [i for i in range(len(graph)) if not hasCycle(i)]

```

## 261. Graph Valid Tree_261.py
```python
class Solution:
  def validTree(self, n: int, edges: List[List[int]]) -> bool:
    if n == 0 or len(edges) != n - 1:
      return False

    graph = [[] for _ in range(n)]
    q = collections.deque([0])
    seen = {0}

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    while q:
      u = q.popleft()
      for v in graph[u]:
        if v not in seen:
          q.append(v)
          seen.add(v)

    return len(seen) == n

```

## 2510. Check if There is a Path With Equal Number of 0's And 1's_2510.py
```python
class Solution:
  def isThereAPath(self, grid: List[List[int]]) -> bool:
    m = len(grid)
    n = len(grid[0])
    if m + n - 1 & 1:
      return False

    @functools.lru_cache(None)
    def dp(i: int, j: int, summ: int) -> bool:
      """
      Returns 1 if there's a path to grid[i][j] s.t.
      `summ` = (the number of 0s - the number of 1s).
      """
      if i == m or j == n:
        return False
      summ += 1 if grid[i][j] == 0 else -1
      if i == m - 1 and j == n - 1:
        return summ == 0
      return dp(i + 1, j, summ) or dp(i, j + 1, summ)

    return dp(0, 0, 0)

```

## 1674. Minimum Moves to Make Array Complementary_1674.py
```python
class Solution:
  def minMoves(self, nums: List[int], limit: int) -> int:
    n = len(nums)
    ans = n
    # delta[i] := the number of moves needed when target goes from i - 1 to i
    delta = [0] * (limit * 2 + 2)

    for i in range(n // 2):
      a = nums[i]
      b = nums[n - 1 - i]
      delta[min(a, b) + 1] -= 1
      delta[a + b] -= 1
      delta[a + b + 1] += 1
      delta[max(a, b) + limit + 1] += 1

    # Initially, we need `moves` when the target is 2.
    moves = n
    for i in range(2, limit * 2 + 1):
      moves += delta[i]
      ans = min(ans, moves)

    return ans

```

## 734. Sentence Similarity_734.py
```python
class Solution:
  def areSentencesSimilar(self, sentence1: List[str], sentence2: List[str], similarPairs: List[List[str]]) -> bool:
    if len(sentence1) != len(sentence2):
      return False

    # map[key] := all the similar words of key
    map = collections.defaultdict(set)

    for a, b in similarPairs:
      map[a].add(b)
      map[b].add(a)

    for word1, word2 in zip(sentence1, sentence2):
      if word1 == word2:
        continue
      if word1 not in map:
        return False
      if word2 not in map[word1]:
        return False

    return True

```

## 2998. Minimum Number of Operations to Make X and Y Equal_2998.py
```python
class Solution:
  def minimumOperationsToMakeEqual(self, x, y):
    if x <= y:
      return y - x

    queue = collections.deque([x])
    seen = set()

    ans = 0
    while queue:
      for _ in range(len(queue)):
        num = queue.popleft()
        if num == y:
          return ans
        if num in seen:
          continue
        seen.add(num)
        if num % 11 == 0:
          queue.append(num // 11)
        if num % 5 == 0:
          queue.append(num // 5)
        queue.append(num - 1)
        queue.append(num + 1)
      ans += 1

```

## 604. Design Compressed String Iterator_604.py
```python
class StringIterator:
  def __init__(self, compressedString: str):
    self.s = compressedString
    self.i = 0    # s' index
    self.num = 0  # currentChar's count
    self.currentChar = ' '

  def next(self) -> str:
    if not self.hasNext():
      return ' '

    if self.num == 0:
      self.currentChar = self.s[self.i]
      self.i += 1
      while self.i < len(self.s) and self.s[self.i].isdigit():
        self.num = self.num * 10 + (ord(self.s[self.i]) - ord('0'))
        self.i += 1

    self.num -= 1
    return self.currentChar

  def hasNext(self) -> bool:
    return self.i < len(self.s) or self.num > 0

```

## 3098. Find the Sum of Subsequence Powers_3098.py
```python
class Solution:
  def sumOfPowers(self, nums: List[int], k: int) -> int:
    kMod = 1_000_000_007
    nums.sort()

    @functools.lru_cache(None)
    def dp(i: int, k: int, lastPickedIndex: int, firstIndex: int, secondIndex: int) -> int:
      if k == 0:
        return nums[secondIndex] - nums[firstIndex]
      if i == len(nums):
        return 0
      newFirstIndex = firstIndex
      newSecondIndex = secondIndex
      if firstIndex == -1:
        newFirstIndex = i
      elif secondIndex == -1:
        newSecondIndex = i
      elif nums[i] - nums[lastPickedIndex] < nums[secondIndex] - nums[firstIndex]:
        newFirstIndex = lastPickedIndex
        newSecondIndex = i
      pick = dp(i + 1, k - 1, i, newFirstIndex, newSecondIndex)
      skip = dp(i + 1, k, lastPickedIndex, firstIndex, secondIndex)
      return (pick + skip) % kMod

    return dp(0, k, -1, -1, -1)

```

## 992. Subarrays with K Different Integers_992.py
```python
class Solution:
  def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:
    def subarraysWithAtMostKDistinct(k: int) -> int:
      res = 0
      count = collections.Counter()

      l = 0
      for r, num in enumerate(nums):
        count[num] += 1
        if count[num] == 1:
          k -= 1
        while k < 0:
          count[nums[l]] -= 1
          if count[nums[l]] == 0:
            k += 1
          l += 1
        res += r - l + 1  # nums[l..r], nums[l + 1..r], ..., nums[r]

      return res

    return subarraysWithAtMostKDistinct(k) - subarraysWithAtMostKDistinct(k - 1)

```

## 725. Split Linked List in Parts_725.py
```python
class Solution:
  def splitListToParts(self, root: ListNode, k: int) -> List[ListNode]:
    ans = [[] for _ in range(k)]
    length = 0
    curr = root
    while curr:
      length += 1
      curr = curr.next
    subLength = length // k
    remainder = length % k

    prev = None
    head = root

    for i in range(k):
      ans[i] = head
      for j in range(subLength + (1 if remainder > 0 else 0)):
        prev = head
        head = head.next
      if prev:
        prev.next = None
      remainder -= 1

    return ans

```

## 2164. Sort Even and Odd Indices Independently_2164.py
```python
class Solution:
  def sortEvenOdd(self, nums: List[int]) -> List[int]:
    ans = [0] * len(nums)
    evenCount = collections.Counter(nums[::2])
    oddCount = collections.Counter(nums[1::2])

    ansIndex = 0
    for i in range(1, 101):
      while evenCount[i] > 0:
        ans[ansIndex] = i
        ansIndex += 2
        evenCount[i] -= 1

    ansIndex = 1
    for i in range(100, 0, -1):
      while oddCount[i] > 0:
        ans[ansIndex] = i
        ansIndex += 2
        oddCount[i] -= 1

    return ans

```

## 2967. Minimum Cost to Make Array Equalindromic_2967.py
```python
class Solution:
  def minimumCost(self, nums: List[int]) -> int:
    nums.sort()
    median = nums[len(nums) // 2]
    nextPalindrome = self._getPalindrome(median, delta=1)
    prevPalindrome = self._getPalindrome(median, delta=-1)
    return min(self._cost(nums, nextPalindrome),
               self._cost(nums, prevPalindrome))

  def _cost(self, nums: List[int], palindrome: int) -> int:
    """Returns the cost to change all the numbers to `palindrome`."""
    return sum(abs(palindrome - num) for num in nums)

  def _getPalindrome(self, num: int, delta: int) -> int:
    """Returns the palindrome `p`, where p = num + a * delta and a > 0."""
    while not self._isPalindrome(num):
      num += delta
    return num

  def _isPalindrome(self, num: int) -> int:
    original = str(num)
    return original == original[::-1]

```

## 1764. Form Array by Concatenating Subarrays of Another Array_1764.py
```python
class Solution:
  def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:
    i = 0  # groups' index
    j = 0  # nums' index

    while i < len(groups) and j < len(nums):
      if self._isMatch(groups[i], nums, j):
        j += len(groups[i])
        i += 1
      else:
        j += 1

    return i == len(groups)

  # Returns True if group == nums[j..j + |group|].
  def _isMatch(self, group: List[int], nums: List[int], j: int) -> bool:
    if j + |group| > len(nums):
      return False
    for i, g in enumerate(group):
      if g != nums[j + i]:
        return False
    return True

```

## 359. Logger Rate Limiter_359.py
```python
class Logger:
  def __init__(self):
    # [(timestamp, message)]
    self.messageQueue = collections.deque()
    self.messageSet = set()

  def shouldPrintMessage(self, timestamp: int, message: str) -> bool:
    # Remove the messages that are 10 seconds from the current timestamp.
    while self.messageQueue:
      headTimestamp, headMessage = self.messageQueue[0]
      if timestamp < headTimestamp + 10:
        break
      self.messageQueue.popleft()
      self.messageSet.remove(headMessage)

    if message in self.messageSet:
      return False

    self.messageQueue.append((timestamp, message))
    self.messageSet.add(message)
    return True

```

## 51. N-Queens_51.py
```python
class Solution:
  def solveNQueens(self, n: int) -> List[List[str]]:
    ans = []
    cols = [False] * n
    diag1 = [False] * (2 * n - 1)
    diag2 = [False] * (2 * n - 1)

    def dfs(i: int, board: List[int]) -> None:
      if i == n:
        ans.append(board)
        return

      for j in range(n):
        if cols[j] or diag1[i + j] or diag2[j - i + n - 1]:
          continue
        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = True
        dfs(i + 1, board + ['.' * j + 'Q' + '.' * (n - j - 1)])
        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = False

    dfs(0, [])
    return ans

```

## 2192. All Ancestors of a Node in a Directed Acyclic Graph_2192-2.py
```python
class Solution:
  def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:
    ans = [set() for _ in range(n)]
    graph = [[] for _ in range(n)]
    inDegrees = [0] * n

    # Build the graph.
    for u, v in edges:
      graph[u].append(v)
      inDegrees[v] += 1

    # Perform topological sorting.
    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])

    while q:
      for _ in range(len(q)):
        u = q.popleft()
        for v in graph[u]:
          ans[v].add(u)
          ans[v].update(ans[u])
          inDegrees[v] -= 1
          if inDegrees[v] == 0:
            q.append(v)

    return [sorted(nodes) for nodes in ans]

```

## 91. Decode Ways_91.py
```python
class Solution:
  def numDecodings(self, s: str) -> int:
    n = len(s)
    # dp[i] := the number of ways to decode s[i..n)
    dp = [0] * n + [1]

    def isValid(a: str, b=None) -> bool:
      if b:
        return a == '1' or a == '2' and b < '7'
      return a != '0'

    if isValid(s[-1]):
      dp[n - 1] = 1

    for i in reversed(range(n - 1)):
      if isValid(s[i]):
        dp[i] += dp[i + 1]
      if isValid(s[i], s[i + 1]):
        dp[i] += dp[i + 2]

    return dp[0]

```

## 2318. Number of Distinct Roll Sequences_2318.py
```python
class Solution:
  def distinctSequences(self, n: int) -> int:
    kMod = 1_000_000_007

    @functools.lru_cache(None)
    def dp(n: int, prev: int, prevPrev: int) -> int:
      """
      Returns the number of distinct sequences for n dices with `prev` and
      `prevPrev`.
      """
      if n == 0:
        return 1
      res = 0
      for dice in range(1, 7):
        if dice != prev and dice != prevPrev and \
                (prev == 0 or math.gcd(dice, prev) == 1):
          res += dp(n - 1, dice, prev)
          res %= kMod
      return res

    return dp(n, 0, 0)

```

## 259. 3Sum Smaller_259.py
```python
class Solution:
  def threeSumSmaller(self, nums: List[int], target: int) -> int:
    if len(nums) < 3:
      return 0

    ans = 0

    nums.sort()

    for i in range(len(nums) - 2):
      l = i + 1
      r = len(nums) - 1
      while l < r:
        if nums[i] + nums[l] + nums[r] < target:
          # (nums[i], nums[l], nums[r])
          # (nums[i], nums[l], nums[r - 1])
          # ...,
          # (nums[i], nums[l], nums[l + 1])
          ans += r - l
          l += 1
        else:
          r -= 1

    return ans

```

## 514. Freedom Trail_514.py
```python
class Solution:
  def findRotateSteps(self, ring: str, key: str) -> int:
    @functools.lru_cache(None)
    def dfs(ring: str, index: int) -> int:
      """Returns the number of rotates of ring to match key[index..n)."""
      if index == len(key):
        return 0

      ans = math.inf

      # For each ring[i] == key[index], we rotate the ring to match the ring[i]
      # with the key[index], then recursively match the newRing with the
      # key[index + 1..n).
      for i, r in enumerate(ring):
        if r == key[index]:
          minRotates = min(i, len(ring) - i)
          newRing = ring[i:] + ring[:i]
          remainingRotates = dfs(newRing, index + 1)
          ans = min(ans, minRotates + remainingRotates)

      return ans

    return dfs(ring, 0) + len(key)

```

## 1712. Ways to Split Array Into Three Subarrays_1712-2.py
```python
class Solution:
  def waysToSplit(self, nums: List[int]) -> int:
    kMod = 1_000_000_007
    n = len(nums)
    ans = 0
    prefix = list(itertools.accumulate(nums))

    j = 0
    k = 0
    for i in range(n - 2):
      # Find the first index j s.t.
      # left = prefix[i] <= mid = prefix[j] - prefix[i]
      j = max(j, i + 1)
      while j < n - 1 and prefix[i] > prefix[j] - prefix[i]:
        j += 1
      # Find the first index k s.t.
      # mid = prefix[k] - prefix[i] > right = prefix[-1] - prefix[k]
      k = max(k, j)
      while k < n - 1 and prefix[k] - prefix[i] <= prefix[-1] - prefix[k]:
        k += 1
      ans += k - j
      ans %= kMod

    return ans

```

## 354. Russian Doll Envelopes_354.py
```python
class Solution:
  def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
    envelopes.sort(key=lambda x: (x[0], -x[1]))
    # Same as 300. Longest Increasing Subsequence
    ans = 0
    dp = [0] * len(envelopes)

    for _, h in envelopes:
      l = 0
      r = ans
      while l < r:
        m = (l + r) // 2
        if dp[m] >= h:
          r = m
        else:
          l = m + 1
      dp[l] = h
      if l == ans:
        ans += 1

    return ans

```

## 381. Insert Delete GetRandom O(1) - Duplicates allowed_381.py
```python
class RandomizedCollection:
  def __init__(self):
    self.vals = []
    self.valToIndices = collections.defaultdict(list)

  def insert(self, val: int) -> bool:
    self.valToIndices[val].append(len(self.vals))
    self.vals.append([val, len(self.valToIndices[val]) - 1])
    return len(self.valToIndices[val]) == 1

  def remove(self, val: int) -> bool:
    if val not in self.valToIndices or self.valToIndices[val] == []:
      return False

    index = self.valToIndices[val][-1]
    self.valToIndices[self.vals[-1][0]][self.vals[-1][1]] = index
    self.valToIndices[val].pop()
    self.vals[index] = self.vals[-1]
    self.vals.pop()
    return True

  def getRandom(self) -> int:
    index = random.randint(0, len(self.vals) - 1)
    return self.vals[index][0]

```

## 3139. Minimum Cost to Equalize Array_3139.py
```python
class Solution:
  def minCostToEqualizeArray(self, nums: List[int], cost1: int, cost2: int) -> int:
    kMod = 1_000_000_007
    n = len(nums)
    minNum = min(nums)
    maxNum = max(nums)
    summ = sum(nums)

    if cost1 * 2 <= cost2 or n < 3:
      totalGap = maxNum * n - summ
      return (cost1 * totalGap) % kMod

    def getMinCost(target: int) -> int:
      """Returns the minimum cost to make all numbers equal to `target`."""
      maxGap = target - minNum
      totalGap = target * n - summ
      # Pair one shallowest number with one non-shallowest number, so the worst
      # case is that we have `totalGap - maxGap` non-shallowest numbers to pair.
      pairs = min(totalGap // 2, totalGap - maxGap)
      return cost1 * (totalGap - 2 * pairs) + cost2 * pairs

    return min(getMinCost(target)
               for target in range(maxNum, 2 * maxNum)) % kMod

```

## 1522. Diameter of N-Ary Tree_1522.py
```python
class Solution:
  def diameter(self, root: 'Node') -> int:
    ans = 0

    def maxDepth(root: 'Node') -> int:
      """Returns the maximum depth of the subtree rooted at `root`."""
      nonlocal ans
      maxSubDepth1 = 0
      maxSubDepth2 = 0
      for child in root.children:
        maxSubDepth = maxDepth(child)
        if maxSubDepth > maxSubDepth1:
          maxSubDepth2 = maxSubDepth1
          maxSubDepth1 = maxSubDepth
        elif maxSubDepth > maxSubDepth2:
          maxSubDepth2 = maxSubDepth
      ans = max(ans, maxSubDepth1 + maxSubDepth2)
      return 1 + maxSubDepth1

    maxDepth(root)
    return ans

```

## 286. Walls and Gates_286.py
```python
class Solution:
  def wallsAndGates(self, rooms: List[List[int]]) -> None:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    kInf = 2**31 - 1
    m = len(rooms)
    n = len(rooms[0])
    q = collections.deque()

    for i in range(m):
      for j in range(n):
        if rooms[i][j] == 0:
          q.append((i, j))

    while q:
      i, j = q.popleft()
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        if rooms[x][y] != kInf:
          continue
        rooms[x][y] = rooms[i][j] + 1
        q.append((x, y))

```

## 1620. Coordinate With Maximum Network Quality_1620.py
```python
class Solution:
  def bestCoordinate(self, towers: List[List[int]], radius: int) -> List[int]:
    kMax = 50
    n = len(towers)
    ans = [0] * 2
    maxQuality = 0

    def dist(tower: List[int], i: int, j: int) -> float:
      """Returns the distance between the tower and the coordinate."""
      return math.sqrt((tower[0] - i)**2 + (tower[1] - j)**2)

    for i in range(kMax + 1):
      for j in range(kMax + 1):
        qualitySum = 0
        for tower in towers:
          q = tower[2]
          d = dist(tower, i, j)
          if d <= radius:
            qualitySum += int(q / (1 + d))
        if qualitySum > maxQuality:
          maxQuality = qualitySum
          ans = [i, j]

    return ans

```

## 1602. Find Nearest Right Node in Binary Tree_1602.py
```python
class Solution:
  def findNearestRightNode(self, root: TreeNode, u: TreeNode) -> Optional[TreeNode]:
    ans = None
    targetDepth = -1

    def dfs(root: TreeNode, depth: int) -> None:
      nonlocal ans
      nonlocal targetDepth
      if not root:
        return
      if root == u:
        targetDepth = depth
        return
      if depth == targetDepth and not ans:
        ans = root
        return
      dfs(root.left, depth + 1)
      dfs(root.right, depth + 1)

    dfs(root, 0)
    return ans

```

## 8. String to Integer (atoi)_8.py
```python
class Solution:
  def myAtoi(self, s: str) -> int:
    s = s.strip()
    if not s:
      return 0

    sign = -1 if s[0] == '-' else 1
    if s[0] in {'-', '+'}:
      s = s[1:]

    num = 0

    for c in s:
      if not c.isdigit():
        break
      num = num * 10 + ord(c) - ord('0')
      if sign * num <= -2**31:
        return -2**31
      if sign * num >= 2**31 - 1:
        return 2**31 - 1

    return sign * num

```

## 2162. Minimum Cost to Set Cooking Time_2162.py
```python
class Solution:
  def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:
    ans = math.inf
    mins = 99 if targetSeconds > 5999 else targetSeconds // 60
    secs = targetSeconds - mins * 60

    def getCost(mins: int, secs: int) -> int:
      cost = 0
      curr = str(startAt)
      for c in str(mins * 100 + secs):
        if c == curr:
          cost += pushCost
        else:
          cost += moveCost + pushCost
          curr = c
      return cost

    while secs < 100:
      ans = min(ans, getCost(mins, secs))
      mins -= 1
      secs += 60

    return ans

```

## 2290. Minimum Obstacle Removal to Reach Corner_2290.py
```python
class Solution:
  def minimumObstacles(self, grid: List[List[int]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])
    minHeap = [(grid[0][0], 0, 0)]  # (d, i, j)
    dist = [[math.inf] * n for _ in range(m)]
    dist[0][0] = grid[0][0]

    while minHeap:
      d, i, j = heapq.heappop(minHeap)
      if i == m - 1 and j == n - 1:
        return d
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        newDist = d + grid[i][j]
        if newDist < dist[x][y]:
          dist[x][y] = newDist
          heapq.heappush(minHeap, (newDist, x, y))

    return dist[m - 1][n - 1]

```

## 23. Merge k Sorted Lists_23.py
```python
from queue import PriorityQueue


class Solution:
  def mergeKLists(self, lists: List[ListNode]) -> ListNode:
    dummy = ListNode(0)
    curr = dummy
    pq = PriorityQueue()

    for i, lst in enumerate(lists):
      if lst:
        pq.put((lst.val, i, lst))

    while not pq.empty():
      _, i, minNode = pq.get()
      if minNode.next:
        pq.put((minNode.next.val, i, minNode.next))
      curr.next = minNode
      curr = curr.next

    return dummy.next

```

## 1639. Number of Ways to Form a Target String Given a Dictionary_1639.py
```python
class Solution:
  def numWays(self, words: List[str], target: str) -> int:
    kMod = 1_000_000_007
    wordLength = len(words[0])
    # counts[j] := the count map of words[i][j], where 0 <= i < |words|
    counts = [collections.Counter() for _ in range(wordLength)]

    for i in range(wordLength):
      for word in words:
        counts[i][word[i]] += 1

    @functools.lru_cache(None)
    def dp(i: int, j: int):
      """Returns the number of ways to form target[i..n) using word[j..n)."""
      if i == len(target):
        return 1
      if j == wordLength:
        return 0
      return (dp(i + 1, j + 1) * counts[j][target[i]] + dp(i, j + 1)) % kMod

    return dp(0, 0)

```

## 2058. Find the Minimum and Maximum Number of Nodes Between Critical Points_2058.py
```python
class Solution:
  def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:
    minDistance = math.inf
    firstMaIndex = -1
    prevMaIndex = -1
    index = 1
    prev = head  # Point to the index 0.
    curr = head.next  # Point to the index 1.

    while curr.next:
      if curr.val > prev.val and curr.val > curr.next.val or \
         curr.val < prev.val and curr.val < curr.next.val:
        if firstMaIndex == -1:  # Only assign once.
          firstMaIndex = index
        if prevMaIndex != -1:
          minDistance = min(minDistance, index - prevMaIndex)
        prevMaIndex = index
      prev = curr
      curr = curr.next
      index += 1

    if minDistance == math.inf:
      return [-1, -1]
    return [minDistance, prevMaIndex - firstMaIndex]

```

## 1406. Stone Game III_1406.py
```python
class Solution:
  def stoneGameIII(self, stoneValue: List[int]) -> str:
    @functools.lru_cache(None)
    def dp(i: int) -> int:
      """
      Returns the maximum relative score Alice can make with stoneValue[i..n).
      """
      if i == len(stoneValue):
        return 0

      res = -math.inf
      summ = 0

      for j in range(i, i + 3):
        if j == len(stoneValue):
          break
        summ += stoneValue[j]
        res = max(res, summ - dp(j + 1))

      return res

    score = dp(0)
    if score == 0:
      return 'Tie'
    return 'Alice' if score > 0 else 'Bob'

```

## 188. Best Time to Buy and Sell Stock IV_188.py
```python
class Solution:
  def maxProfit(self, k: int, prices: List[int]) -> int:
    if k >= len(prices) // 2:
      sell = 0
      hold = -math.inf

      for price in prices:
        sell = max(sell, hold + price)
        hold = max(hold, sell - price)

      return sell

    sell = [0] * (k + 1)
    hold = [-math.inf] * (k + 1)

    for price in prices:
      for i in range(k, 0, -1):
        sell[i] = max(sell[i], hold[i] + price)
        hold[i] = max(hold[i], sell[i - 1] - price)

    return sell[k]

```

## 2093. Minimum Cost to Reach City With Discounts_2093.py
```python
class Solution:
  def minimumCost(self, n: int, highways: List[List[int]], discounts: int) -> int:
    graph = [[] for _ in range(n)]
    minHeap = [(0, 0, discounts)]  # (d, u, leftDiscounts)
    minDiscounts = {}

    for city1, city2, toll in highways:
      graph[city1].append((city2, toll))
      graph[city2].append((city1, toll))

    while minHeap:
      d, u, leftDiscounts = heapq.heappop(minHeap)
      if u == n - 1:
        return d
      if u in minDiscounts and minDiscounts[u] >= leftDiscounts:
        continue
      minDiscounts[u] = leftDiscounts
      for v, w in graph[u]:
        heapq.heappush(minHeap, (d + w, v, leftDiscounts))
        if leftDiscounts > 0:
          heapq.heappush(minHeap, (d + w // 2, v, leftDiscounts - 1))

    return -1

```

## 2340. Minimum Adjacent Swaps to Make a Valid Array_2340.py
```python
class Solution:
  def minimumSwaps(self, nums: List[int]) -> int:
    minIndex = self._getLeftmostMinIndex(nums)
    maxIndex = self._getRightmostMaxIndex(nums)
    swaps = minIndex + (len(nums) - 1 - maxIndex)
    return swaps if minIndex <= maxIndex else swaps - 1

  def _getLeftmostMinIndex(self, nums: List[int]) -> int:
    mn = nums[0]
    minIndex = 0
    for i in range(1, len(nums)):
      if nums[i] < mn:
        mn = nums[i]
        minIndex = i
    return minIndex

  def _getRightmostMaxIndex(self, nums: List[int]) -> int:
    mx = nums[-1]
    maxIndex = len(nums) - 1
    for i in range(len(nums) - 2, -1, -1):
      if nums[i] > mx:
        mx = nums[i]
        maxIndex = i
    return maxIndex

```

## 2075. Decode the Slanted Ciphertext_2075.py
```python
class Solution:
  def decodeCiphertext(self, encodedText: str, rows: int) -> str:
    n = len(encodedText)
    cols = n // rows

    ans = []
    matrix = [[' '] * cols for _ in range(rows)]

    for i in range(rows):
      for j in range(cols):
        matrix[i][j] = encodedText[i * cols + j]

    for col in range(cols):
      i = 0
      j = col
      while i < rows and j < cols:
        ans.append(matrix[i][j])
        i += 1
        j += 1

    return ''.join(ans).rstrip()

```

## 2963. Count the Number of Good Partitions_2963.py
```python
class Solution:
  def numberOfGoodPartitions(self, nums: List[int]) -> int:
    kMod = 1_000_000_007
    ans = 1
    # lastSeen[num] := the index of the last time `num` appeared
    lastSeen = {}

    for i, num in enumerate(nums):
      lastSeen[num] = i

    # Track the maximum right index of each running partition by ensuring that
    # the first and last occurrences of a number fall within the same partition.
    maxRight = 0
    for i, num in enumerate(nums):
      if i > maxRight:
        # Start a new partition that starts from nums[i].
        # Each partition doubles the total number of good partitions.
        ans = ans * 2 % kMod
      maxRight = max(maxRight, lastSeen[num])

    return ans

```

## 400. Nth Digit_400.py
```python
class Solution:
  def findNthDigit(self, n: int) -> int:
    def getDigit(num: int, pos: int, digitSize: int):
      if pos == 0:
        return num % 10
      for _ in range(digitSize - pos):
        num //= 10
      return num % 10

    digitSize = 1
    startNum = 1
    count = 9

    while digitSize * count < n:
      n -= digitSize * count
      digitSize += 1
      startNum *= 10
      count *= 10

    targetNum = startNum + (n - 1) // digitSize
    pos = n % digitSize

    return getDigit(targetNum, pos, digitSize)

```

